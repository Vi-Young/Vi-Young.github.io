<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vi-Young Space</title>
  
  <subtitle>Talk Less Think More</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://vi-young.com/"/>
  <updated>2018-07-07T15:15:32.466Z</updated>
  <id>http://vi-young.com/</id>
  
  <author>
    <name>Vi-Young</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java技术体系以及写作计划</title>
    <link href="http://vi-young.com/2018/07/08/Java%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB%E4%BB%A5%E5%8F%8A%E5%86%99%E4%BD%9C%E8%AE%A1%E5%88%92/"/>
    <id>http://vi-young.com/2018/07/08/Java技术体系以及写作计划/</id>
    <published>2018-07-08T07:15:00.000Z</published>
    <updated>2018-07-07T15:15:32.466Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p> 如果把Java比喻成一颗繁荣茂盛的大树。</p><p>   首先，它需要土壤（JVM），需要主干（基础），枝杈（扩展），肥料（设计模式）。当然，如果想要让这个树茁壮的成长，我们还需要学习一些灌溉的知识（操作系统），甚至来说我们还需要一些生物专业的知识（数据结构和算法），甚至于我们了解树的每一个细胞，可以去研学细胞学的知识（源码）。</p><p>   现在我们有了一棵树，我们还需要知道如果这棵树上有了害虫之后怎么除虫（安全攻防）。当然，我们如果不满足一颗树，我们需要的是一片树林，那么我们需要知道怎么把这些树合理的安排而可以茁壮互不影响的成长（分布式架构）。</p><p>   所以，我们下面就来详细的了解如果想要把这些搞明白，需要学习哪些知识：</p><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><ul><li>数据类型</li><li>运算符</li><li>字符串</li><li>控制流程</li><li>数组</li><li>对象与类</li><li>static关键字</li><li>对象构造</li><li>注释</li><li>继承</li><li>Object</li><li>对象包装与自动装箱机制</li><li>枚举</li><li>反射</li><li>接口</li><li>Lambda</li><li>内部类</li><li>代理</li><li>异常</li><li>断言</li><li>日志</li><li>泛型</li><li>了解泛型</li><li>泛型的约束和局限性</li><li>继承规则</li><li>通配符类型</li><li>反射和泛型<ul><li>集合</li><li>集合整体认知</li><li>集合详解</li><li>映射</li><li>视图与包装器<ul><li>集合中的算法</li></ul></li></ul></li><li>Java IO</li><li>单元测试</li><li>序列化</li><li>并发 <ul><li>线程认知 </li><li>线程安全 </li><li>锁 </li><li>死锁 </li><li>volatile域 </li><li>synchronized关键字 </li><li>原子性 </li><li>执行器 </li><li>同步器 </li><li>notify ,notifyAll, wait, sleep</li></ul></li><li>语法糖</li></ul><h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><ul><li>类的加载机制</li><li>Jvm内存结构</li><li>GC算法　垃圾回收</li><li>GC分析　命令调优</li><li>HotSpot</li><li>工具的使用篇</li></ul><h4 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h4><ul><li>分布式事务 </li><li>分布式数据库</li><li>分布式文件系统</li><li>分布式缓存</li><li>Docker &amp; k8s</li><li>Spring Cloud</li><li>Spring Boot</li><li>分库分表</li><li>消息中间件</li><li>Zookeeper</li></ul><h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><ul><li>网络知识<ul><li>网络协议</li><li>Socket编程</li><li>Netty</li><li>Nginx实现反向代理，负载均衡</li><li>CDN</li><li>DNS</li></ul></li><li>数据库<ul><li>SQL优化</li><li>数据库锁</li><li>缓存数据库 Redis Memcached</li><li>事务</li></ul></li><li>搜索引擎<ul><li>Solr</li><li>Lucene</li><li>ES</li></ul></li><li>权限管理：<ul><li>Shiro</li></ul></li><li>AI<ul><li>Python</li><li>概率论</li><li>机器学习</li><li>人工神经网络</li><li>深度学习</li><li>TensorFlow</li></ul></li></ul><h4 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h4><p>详细目录需精读《Head First 设计模式》之后再进行补充</p><h4 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h4><ul><li>Linux常用命令</li><li>其他目录需阅读《鸟哥的Linux私房菜》之后再进行完善</li></ul><h4 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h4><p>详细目录需精读《算法》和《算法导论》之后在进行补充</p><p>###安全攻防</p><p>详细目录需详细阅读《黑客攻防技术宝典》以及更多的书籍后进行补充。</p><h4 id="写作计划"><a href="#写作计划" class="headerlink" title="写作计划"></a>写作计划</h4><p>顺序如下：</p><p>基础 -&gt; JVM -&gt; 分布式架构 -&gt; 扩展 -&gt; 设计模式 -&gt; 操作系统 -&gt; 数据结构和算法 -&gt; 安全攻防。（源码的学习穿插于大多数步骤，一般会对一些经典的类和框架进行源码的研读）</p><p>每日一更，详细讲解上述内容，除了个别的会单独拿出来作为一个系列（比如docker，springboot），基本上是按照顺序来讲解。计划三到五年写完，每周末更新预告下周目录。</p><h4 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h4><p>文章首发于公众号和个人博客 <a href="http://vi-young.com">http://vi-young.com</a><br>扫码或微信搜索Vi的技术博客，关注公众号，不定期送书活动各种福利~</p><p><img src="http://upload-images.jianshu.io/upload_images/10641481-961b717327e333ab.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt; 如果把Java比喻成一颗繁荣茂盛的大树。&lt;/p&gt;
&lt;p&gt;   首先，它需要土壤（JVM），需要主干（基础），枝杈（扩展），肥料（设计模式）
      
    
    </summary>
    
      <category term="Java" scheme="http://vi-young.com/categories/Java/"/>
    
    
      <category term="生活" scheme="http://vi-young.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Python3 系列（五）：Number</title>
    <link href="http://vi-young.com/2018/06/28/Python3-%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9ANumber/"/>
    <id>http://vi-young.com/2018/06/28/Python3-系列（五）：Number/</id>
    <published>2018-06-28T11:58:00.000Z</published>
    <updated>2018-06-28T03:58:49.745Z</updated>
    
    <content type="html"><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>在Python中，支持3种不同的数据类型：</p><ul><li><strong>整型（Int）</strong>，通常被称为是整型或整数，是正或负整数，不带小数点。Python3 整型是没有限制大小的，可以当作 Long 类型使用，所以 Python3 没有 Python2 的 Long 类型。</li><li><strong>浮点型（float）</strong>，浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 = 2.5 x 102 = 250）</li><li><strong>复数（complex）</strong>，复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。</li><li><strong>小数（Decimal）</strong>，比起float拥有更高的精度。</li><li><strong>分数（Fraction）</strong>，由构造函数来实例化，<code>ractions.Fraction(numerator, denominator)</code>，其中 numerator为分子，denominator为分母。<h5 id="数字运算"><a href="#数字运算" class="headerlink" title="数字运算"></a>数字运算</h5></li></ul><p>Python 解释器可以作为一个简单的计算器，您可以在解释器里输入一个表达式，它将输出表达式的值。表达式的语法很直白： <code>+</code>, <code>-</code>, <code>*</code> 和 <code>/</code>, 和其它语言（如Pascal或C）里一样。例如：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="number">2</span> + <span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">&gt;&gt;&gt; <span class="number">50</span> - <span class="number">5</span>*<span class="number">6</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line">&gt;&gt;&gt; (<span class="number">50</span> - <span class="number">5</span>*<span class="number">6</span>) / <span class="number">4</span></span><br><span class="line"><span class="number">5.0</span></span><br><span class="line">&gt;&gt;&gt; <span class="number">8</span> / <span class="number">5</span>  # 总是返回一个浮点数</span><br><span class="line"><span class="number">1.6</span></span><br></pre></td></tr></table></figure><p>这里，我们可以注意到Python中除法<code>/</code>总是返回的是一个浮点数，如果我们只想取到整数的结果，丢弃分数的部分，可以使用运算符<code>//</code>,计算余数的话可以使用<code>%</code>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; 17 / 3  <span class="comment"># 整数除法返回浮点型</span></span></span><br><span class="line">5.666666666666667</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; 17 // 3  <span class="comment"># 整数除法返回向下取整后的结果</span></span></span><br><span class="line">5</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; 17 % 3  <span class="comment"># 整数除法返回得到商之后，余数的结果</span></span></span><br><span class="line">2</span><br></pre></td></tr></table></figure><p>这里需要注意一点，<code>//</code>得到的并不一定是整数类型的数，它与分母分子的数据类型有关</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="number">7</span><span class="comment">//2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">&gt;&gt;&gt; <span class="number">7.0</span><span class="comment">//2</span></span><br><span class="line"><span class="number">3.0</span></span><br><span class="line">&gt;&gt;&gt; <span class="number">7</span><span class="comment">//2.0</span></span><br><span class="line"><span class="number">3.0</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>Python中可以用<code>**</code>操作进行幂运算：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="number">5</span> ** <span class="number">2</span>  # <span class="number">5</span> 的平方</span><br><span class="line"><span class="number">25</span></span><br><span class="line">&gt;&gt;&gt; <span class="number">2</span> ** <span class="number">7</span>  # <span class="number">2</span>的<span class="number">7</span>次方</span><br><span class="line"><span class="number">128</span></span><br></pre></td></tr></table></figure><p>等号( ‘=’ )用于给变量赋值。赋值之后，在下一个提示符之前不会有任何结果显示:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; width = <span class="number">20</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; height = <span class="number">5</span>*<span class="number">9</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; width * height</span><br><span class="line"><span class="number">900</span></span><br></pre></td></tr></table></figure><p>变量在使用前必须 “定义”(赋值)，否则会出错:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; <span class="comment"># try to access an undefined variable</span></span><br><span class="line">... n</span><br><span class="line">Traceback (most recent call last)<span class="symbol">:</span></span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;<span class="class"><span class="keyword">module</span>&gt;</span></span><br><span class="line"><span class="symbol">NameError:</span> name <span class="string">'n'</span> is <span class="keyword">not</span> <span class="keyword">defined</span></span><br></pre></td></tr></table></figure><p>交互模式中，最近一个表达式的值赋给变量 _。这样我们就可以把它当作一个桌面计算器，很方便的用于连续计算，例如:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; tax = <span class="number">12.5</span> / <span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; price = <span class="number">100.50</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; price * tax</span><br><span class="line"><span class="number">12.5625</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; price + <span class="number">_</span></span><br><span class="line"><span class="number">113.0625</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; round(<span class="number">_</span>, <span class="number">2</span>)</span><br><span class="line"><span class="number">113.06</span></span><br></pre></td></tr></table></figure><p>此变量对于用户是只读的。不要尝试给它赋值 —— 你只会创建一个独立的同名局部变量，它屏蔽了系统内置变量的魔术效果。</p><h5 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h5><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">返回值</th></tr></thead><tbody><tr><td style="text-align:left"><code>abs(x)</code></td><td style="text-align:left">返回数字的绝对值，如abs(-10) 返回 10</td></tr><tr><td style="text-align:left"><code>ceil(x)</code></td><td style="text-align:left">返回数字的上入整数，如math.ceil(4.1) 返回 5</td></tr><tr><td style="text-align:left"><code>exp(x)</code></td><td style="text-align:left">返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045</td></tr><tr><td style="text-align:left"><code>fabs(x)</code></td><td style="text-align:left">返回数字的绝对值，如math.fabs(-10) 返回10.0</td></tr><tr><td style="text-align:left"><code>floor(x)</code></td><td style="text-align:left">返回数字的下舍整数，如math.floor(4.9)返回 4</td></tr><tr><td style="text-align:left"><code>log(x)</code></td><td style="text-align:left">如math.log(math.e)返回1.0,math.log(100,10)返回2.0</td></tr><tr><td style="text-align:left"><code>log10(x)</code></td><td style="text-align:left">返回以10为基数的x的对数，如math.log10(100)返回 2.0</td></tr><tr><td style="text-align:left"><code>max(x1, x2,...)</code></td><td style="text-align:left">返回给定参数的最大值，参数可以为序列。</td></tr><tr><td style="text-align:left"><code>min(x1, x2,...)</code></td><td style="text-align:left">返回给定参数的最小值，参数可以为序列。</td></tr><tr><td style="text-align:left"><code>modf(x)</code></td><td style="text-align:left">返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。</td></tr><tr><td style="text-align:left"><code>pow(x, y)</code></td><td style="text-align:left">x**y 运算后的值。</td></tr><tr><td style="text-align:left"><code>round(x [,n])</code></td><td style="text-align:left">返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数。</td></tr><tr><td style="text-align:left"><code>sqrt(x)</code></td><td style="text-align:left">返回数字x的平方根。</td></tr></tbody></table><h5 id="随机数函数"><a href="#随机数函数" class="headerlink" title="随机数函数"></a>随机数函数</h5><p>随机数可以用于数学，游戏，安全等领域中，还经常被嵌入到算法中，用以提高算法效率，并提高程序的安全性。<br>Python包含以下常用随机数函数：</p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>choice(seq)</code></td><td style="text-align:left">从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。</td></tr><tr><td style="text-align:left"><code>randrange ([start,] stop [,step])</code></td><td style="text-align:left">从指定范围内，按指定基数递增的集合中获取一个随机数，基数缺省值为1</td></tr><tr><td style="text-align:left"><code>random()</code></td><td style="text-align:left">随机生成下一个实数，它在[0,1)范围内。</td></tr><tr><td style="text-align:left"><code>seed([x])</code></td><td style="text-align:left">改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。</td></tr><tr><td style="text-align:left"><code>shuffle(lst)</code></td><td style="text-align:left">将序列的所有元素随机排序</td></tr><tr><td style="text-align:left"><code>uniform(x, y)</code></td><td style="text-align:left">随机生成下一个实数，它在[x,y]范围内。</td></tr><tr><td style="text-align:left"><code>randint(x,y)</code></td><td style="text-align:left">随机生成下一个整数int类型，它在[x, y]范围之内</td></tr><tr><td style="text-align:left"><code>sample(sequence,length)</code></td><td style="text-align:left">在某个序列中，随机的截取指定长度的片段，不改变原序列</td></tr></tbody></table><h5 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h5><p>Python包括以下三角函数：</p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left"><code>acos(x)</code></td><td style="text-align:left">返回x的反余弦弧度值。</td></tr><tr><td style="text-align:left"><code>asin(x)</code></td><td style="text-align:left">返回x的反正弦弧度值。</td></tr><tr><td style="text-align:left"><code>atan(x)</code></td><td style="text-align:left">返回x的反正切弧度值。</td></tr><tr><td style="text-align:left"><code>atan2(y, x)</code></td><td style="text-align:left">返回给定的 X 及 Y 坐标值的反正切值。</td></tr><tr><td style="text-align:left"><code>cos(x)</code></td><td style="text-align:left">返回x的弧度的余弦值。</td></tr><tr><td style="text-align:left"><code>hypot(x, y)</code></td><td style="text-align:left">返回欧几里德范数 <code>sqrt(x*x + y*y)</code>。</td></tr><tr><td style="text-align:left"><code>sin(x)</code></td><td style="text-align:left">返回的x弧度的正弦值。</td></tr><tr><td style="text-align:left"><code>tan(x)</code></td><td style="text-align:left">返回x弧度的正切值。</td></tr><tr><td style="text-align:left"><code>degrees(x)</code></td><td style="text-align:left">将弧度转换为角度,如<code>degrees(math.pi/2)</code> ， 返回90.0</td></tr><tr><td style="text-align:left"><code>radians(x)</code></td><td style="text-align:left">将角度转换为弧度</td></tr></tbody></table><h5 id="数学常量"><a href="#数学常量" class="headerlink" title="数学常量"></a>数学常量</h5><table><thead><tr><th style="text-align:left">常量</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">pi</td><td style="text-align:left">数学常量 pi（圆周率，一般以π来表示）</td></tr><tr><td style="text-align:left">e</td><td style="text-align:left">数学常量 e，e即自然常数（自然常数）。</td></tr></tbody></table><h5 id="关于round的一些看法"><a href="#关于round的一些看法" class="headerlink" title="关于round的一些看法"></a>关于round的一些看法</h5><p>“4舍6入5看齐,奇进偶不进”我觉得并不是因为浮点数在计算机表示的问题。计算机浮点数的表示是 ieee 定义的标准规则，如果 python 中存在，没道理其他语言中不存在。事实上是因为该取舍方法比过去的 “四舍五入” 方法在科学计算中更准确。而国家标准也已经规定使用 “4舍6入5看齐,奇进偶不进” 取代”四舍五入”.</p><p>从统计学的角度上来讲,如果大量数据无脑的采用四舍五入会造成统计结果偏大。而”奇进偶舍”可以将舍入误差降到最低。</p><p>奇进偶舍是一种比较精确比较科学的计数保留法，是一种数字修约规则。</p><p>其具体要求如下（以保留两位小数为例）：</p><p> （1）要求保留位数的后一位如果是4或者4以下的数字，则舍去， 例如 5.214保留两位小数为5.21。<br> （2）如果保留位数的后一位如果是6或者6以上的数字，则进上去， 例如5.216保留两位小数为5.22。<br> （3）如果保留位数是保留整数部分或保留一位小数，则要根据保留位来决定奇进偶舍：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; round(<span class="number">5.215</span>,<span class="number">2</span>)#实际并没有进位</span><br><span class="line"><span class="number">5.21</span></span><br><span class="line">&gt;&gt;&gt; round(<span class="number">5.225</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">5.22</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; round(<span class="number">1.5</span>)#此处进位</span><br><span class="line"><span class="number">2</span></span><br><span class="line">&gt;&gt;&gt; round(<span class="number">1.5</span>)==round(<span class="number">2.5</span>)#偶数舍去</span><br><span class="line">True</span><br><span class="line">&gt;&gt;&gt; round(<span class="number">1.15</span>,<span class="number">1</span>)</span><br><span class="line"><span class="number">1.1</span></span><br><span class="line">&gt;&gt;&gt; round(<span class="number">1.25</span>,<span class="number">1</span>)</span><br><span class="line"><span class="number">1.2</span></span><br><span class="line">&gt;&gt;&gt; round(<span class="number">1.151</span>,<span class="number">1</span>)</span><br><span class="line"><span class="number">1.2</span></span><br><span class="line">&gt;&gt;&gt; round(<span class="number">1.251</span>,<span class="number">1</span>)</span><br><span class="line"><span class="number">1.3</span></span><br></pre></td></tr></table></figure><p> (4) 如果保留位数的后一位如果是5，且该位数后有数字。则进上去，例如5.2152保留两位小数为5.22，5.2252保留两位小数为5.23，5.22500001保留两位小数为5.23。<br>从统计学的角度，“奇进偶舍”比“四舍五入”要科学，在大量运算时，它使舍入后的结果误差的均值趋于零，而不是像四舍五入那样逢五就入，导致结果偏向大数，使得误差产生积累进而产生系统误差，“奇进偶舍”使测量结果受到舍入误差的影响降到最低。</p><h5 id="下节预告"><a href="#下节预告" class="headerlink" title="下节预告"></a>下节预告</h5><p>Python中的字符串</p><hr><h5 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h5><p>扫码或微信搜索Vi的技术博客，关注公众号，不定期送书活动各种福利~</p><p><img src="http://upload-images.jianshu.io/upload_images/10641481-961b717327e333ab.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h5&gt;&lt;p&gt;在Python中，支持3种不同的数据类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;整型（Int）&lt;/strong&gt;，通常被称为是整型或整
      
    
    </summary>
    
      <category term="Python" scheme="http://vi-young.com/categories/Python/"/>
    
    
      <category term="Python3" scheme="http://vi-young.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Java基础专题（四）：控制流程</title>
    <link href="http://vi-young.com/2018/06/28/Java%E5%9F%BA%E7%A1%80%E4%B8%93%E9%A2%98%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B/"/>
    <id>http://vi-young.com/2018/06/28/Java基础专题（四）：控制流程/</id>
    <published>2018-06-28T09:28:00.000Z</published>
    <updated>2018-06-28T01:29:34.468Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>和其他程序设计语言一样，Java使用条件语句和循环结构确定控制流程，在介绍这些条件语句和循环结构之前，我们先来了解一下块作用域这个概念。</p><h5 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h5><p>块（block，即复合语句）是指由一对大括号括起来的若干条简单的Java语句，块确定了变量的作用域。一个块可以嵌套在另一个块中。下面是在main方法块中嵌套另一个语句块的实例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//变量k在此处无法使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是，不能在嵌套的两个块中声明同名的变量。比如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">...</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">int</span> n;<span class="comment">//错误，不能在这里定义n</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h5><p>在Java中，条件语句的格式为<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">(condition)</span> stateme<span class="symbol">nt</span></span><br></pre></td></tr></table></figure></p><p>这里的条件必须用括号括起来。<br>在Java中，我们通常需要在条件为真的时候执行多条语句，在这种情况下，就需要使用到我们前面说到的块语句。条件语句格式变成如下：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">(condition)</span> &#123;</span><br><span class="line">stateme<span class="symbol">nt1</span></span><br><span class="line">stateme<span class="symbol">nt2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有时，我们需要在条件为真的时候执行一组语句，当这个条件为假的时候，执行另一种语句，这是需要用到else。于是条件语句的更一般的写法变为:<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">(condition)</span> &#123;</span><br><span class="line">stateme<span class="symbol">nt1</span></span><br><span class="line">stateme<span class="symbol">nt2</span></span><br><span class="line">&#125; else &#123;</span><br><span class="line">stateme<span class="symbol">nt3</span></span><br><span class="line">stateme<span class="symbol">nt4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里需要一点的是，else子句与最邻近的if构成一组，比如：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &lt;= <span class="number">0</span>) <span class="keyword">if</span> (<span class="attr">x</span> == <span class="number">0</span>) <span class="attr">sign</span> = <span class="number">0</span>; <span class="keyword">else</span> <span class="attr">sign</span> = -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>当然，这种写法在我们日常中很少见到，但是我们要知道这里的else是与第二个if配对的。写成如下就会显得很清晰：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (x &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="attr">x</span> == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="attr">sign</span> = <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="attr">sign</span> = -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就体现了大括号和缩进的合理使用对于代码可读性的重要性。</p><h5 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h5><p>当条件为true的时候，while循环执行一条语句（或者一个语句块）。一般格式为：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition) &#123;</span><br><span class="line">statement</span><br><span class="line"><span class="params">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，如果开始循环的时候条件就是false的话，该循环是一次也不会执行的。也正是因为while循环语句首先检测循环条件。因此，循环体中的代码有可能不被执行。如果希望循环体至少执行一次，应该把检测条件放到最后，这时我们的do…while语句就派上了用场，它的基本格式如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> <span class="keyword">statement</span> <span class="keyword">while</span> (condition);</span><br></pre></td></tr></table></figure><h5 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h5><p>for循环语句是支持迭代的一种通用结构，利用每次迭代之后更新的计数器或者类似的变量来控制迭代次数。for语句的第1部分通常用于对计数器进行初始化，第2部分给出每次新一轮循环执行前要检测的循环条件，第3部分指示如何更新计数器。<br>与C++一样，尽管Java允许在for循环的各个部分放置任何表达式，但是有一个不成文的约定俗成的规则：for语句的三个部分应该对同一个计数器变量进行初始化，检测和更新。<br>这里需要注意一点，当你使用浮点数作为计数器时，很可能会出现一些奇奇怪怪的BUG，例如：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (double x = <span class="number">0</span>; x != <span class="number">10</span>; x += <span class="number">0.1</span>)</span><br></pre></td></tr></table></figure></p><p>这个循环永远也不会结束，由于舍入的误差，最终可能得不到精确值。例如，在上面的循环中，因为0.1无法用二进制精确的表示，所以，x将从9.9999999999998跳到10.0999999999998。</p><p>当在for语句的第1部分中声明了一个变量之后，这个变量的作用域就为for循环的整个循环体，如果在for语句中定义一个变量，这个变量就不能在循环体外使用。如果需要使用循环体中的变量数据，需要提前在循环外进行定义。</p><h5 id="增强for循环"><a href="#增强for循环" class="headerlink" title="增强for循环"></a>增强for循环</h5><p>Java有一种功能很强的循环结构，可以用来依次处理数组中的每一个元素而不必为指定下标值分心。<br>这种增强的for循环的语句格式为：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (variable : <span class="type">collection</span>) &#123;</span><br><span class="line">statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义一个变量用于暂存集合中的每一个元素，并执行相应的语句（或语句块）。collection这一集合表达式必须是一个数组或者是一个实现了Iterable接口的类对象（比如ArrayList）。当然，实践中我们发现，增强for循环虽然简洁，但是无论是应用场景还是运行速率上来说，都是不如传统的for循环的。只是为我们程序员编码提供了一种更加简洁的方式~</p><h5 id="多重选择：switch语句"><a href="#多重选择：switch语句" class="headerlink" title="多重选择：switch语句"></a>多重选择：switch语句</h5><p>在处理多个选项的时候，使用if/else就会略显笨拙，这时switch语句就发挥了他应有的作用，如下所示：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (<span class="keyword">choice</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'1'</span>:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'2'</span>:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>switch语句将从与选项值相匹配的case标签处开始执行直到遇到break语句，或者执行到switch语句的结束处为止。如果没有相匹配的case标签，而有default子句，就执行这个子句。如果在case分支语句的末尾没有break语句，那么就会接着执行下一个case分支语句。这种情况称之为case穿透，一般来说，我们不希望看到这种情况的出现，所以，为了程序的安全起见，若不是非常必要的情况下，不要使用switch语句。</p><p>case标签可以是：</p><ul><li>类型为char，byte，short或int的常量表达式</li><li>枚举常量</li><li>如果你的JDK版本是1.7以上，他还可以是字符串字面量</li></ul><h5 id="中断控制流程语句"><a href="#中断控制流程语句" class="headerlink" title="中断控制流程语句"></a>中断控制流程语句</h5><p>我们在使用的过程中，如果遇到需要中断一个流程的情况，通常会使用到以下两个关键字：break和continue，虽然goto是Java的保留字，但是我希望永远不要出现在Java中，无休止的使用goto会将一个程序弄得非常糟糕，无法阅读。</p><p>break 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。break 跳出最里层的循环，并且继续执行该循环下面的语句。当然我们也可以使用标签的方式来跳出某个指定的循环。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">read_data:</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">...</span>) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">...</span>) &#123;</span><br><span class="line"><span class="keyword">break</span> read_data;//这里就是直接跳出了<span class="keyword">while</span>循环</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>continue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。在 for 循环中，continue 语句使程序立即跳转到更新语句。在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。当然，continue也有一种带标签的形式，将跳到与标签匹配的循环首部。用法和break一样，这里就不再举例说明。</p><hr><h5 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h5><p>扫码或微信搜索Vi的技术博客，关注公众号，不定期送书活动各种福利~</p><p><img src="https://i.imgur.com/jK9vpVj.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;和其他程序设计语言一样，Java使用条件语句和循环结构确定控制流程，在介绍这些条件语句和循环结构之前，我们先来了解一下块作用域这个概念。&lt;/
      
    
    </summary>
    
      <category term="Java" scheme="http://vi-young.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://vi-young.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Python3 系列（四）：运算符</title>
    <link href="http://vi-young.com/2018/06/28/Python3-%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>http://vi-young.com/2018/06/28/Python3-系列（四）：运算符/</id>
    <published>2018-06-28T09:27:00.000Z</published>
    <updated>2018-06-28T01:28:34.850Z</updated>
    
    <content type="html"><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>比如：4 +5 = 9 。 例子中，4 和 5 被称为操作数，”+” 称为运算符。<br>Python语言包括以下九种运算符：</p><ul><li>算术运算符</li><li>比较（关系）运算符</li><li>赋值运算符</li><li>逻辑运算符</li><li>位运算符</li><li>成员运算符</li><li>身份运算符</li></ul><h5 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h5><p>Python具有以下六种算术运算符：</p><ul><li>加（+），两个对象相加</li><li>减（-），得到负数或是一个数减去另一个数</li><li>乘（*），两个数相乘，或者将字符串重复若干次后返回</li><li>除（/），运算符左侧的操作数除以运算符右侧的操作数</li><li>取模（%），返回除法运算所得的余数</li><li>幂（**），返回的是运算符左侧操作数的右侧操作数次幂</li><li>取整除（//），返回除法运算的商的整数部分</li></ul><p>以下是该运算符的一些实例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="comment"># __author__ = 'Vi-Young'</span></span><br><span class="line"></span><br><span class="line">a = 7</span><br><span class="line">b = 6</span><br><span class="line">c = 5</span><br><span class="line"></span><br><span class="line">c = a + b</span><br><span class="line">print(<span class="string">"1 - c 的值为："</span>, c)</span><br><span class="line"></span><br><span class="line">c = a - b</span><br><span class="line">print(<span class="string">"2 - c 的值为："</span>, c)</span><br><span class="line"></span><br><span class="line">c = a * b</span><br><span class="line">print(<span class="string">"3 - c 的值为："</span>, c)</span><br><span class="line"></span><br><span class="line">c = a / b</span><br><span class="line">print(<span class="string">"4 - c 的值为："</span>, c)</span><br><span class="line"></span><br><span class="line">c = a % b</span><br><span class="line">print(<span class="string">"5 - c 的值为："</span>, c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改变量 a 、b 、c</span></span><br><span class="line">a = 4</span><br><span class="line">b = 3</span><br><span class="line">c = a ** b</span><br><span class="line">print(<span class="string">"6 - c 的值为："</span>, c)</span><br><span class="line"></span><br><span class="line">a = 3</span><br><span class="line">b = 2</span><br><span class="line">c = a // b</span><br><span class="line">print(<span class="string">"7 - c 的值为："</span>, c)</span><br><span class="line"></span><br><span class="line">a = 3.0</span><br><span class="line">b = 2.0</span><br><span class="line">c = a // b</span><br><span class="line">print(<span class="string">"7 - c 的值为："</span>, c)</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">输出结果为：</span><br></pre></td></tr></table></figure><p>1 - c 的值为： 13<br>2 - c 的值为： 1<br>3 - c 的值为： 42<br>4 - c 的值为： 1.1666666666666667<br>5 - c 的值为： 1<br>6 - c 的值为： 64<br>7 - c 的值为： 1<br>7 - c 的值为： 1.0<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### 比较运算符</span><br><span class="line"></span><br><span class="line">与其他语言类似，Python的比较运算符与Java，C并无太大区别，需要注意一点的是，所有比较运算符返回1表示真，返回0表示假。他们分别与特殊的变量True和False等价（这些变量首字母必须是大写！）</span><br><span class="line"></span><br><span class="line">Python具有以下六种比较运算符</span><br><span class="line"></span><br><span class="line">-<span class="ruby"> 等于（=）比较运算符两侧对象是否相等</span></span><br><span class="line"><span class="ruby">- 不等于（!=）比较运算符两侧对象是否不相等</span></span><br><span class="line"><span class="ruby">- 大于（&gt;）返回运算符左侧操作数是否大于右侧操作数</span></span><br><span class="line"><span class="ruby">- 小于（&lt;）返回运算符左侧操作数是否小于右侧操作数</span></span><br><span class="line"><span class="ruby">- 大于等于（&gt;=）返回运算符左侧操作数是否大于等于右侧操作数</span></span><br><span class="line"><span class="ruby">- 小于等于（&lt;=）返回运算符左侧操作数是否小于等于于右侧操作数</span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">以下是该运算符的一些实例：</span></span><br></pre></td></tr></table></figure></p><h1 id="coding-utf-8"><a href="#coding-utf-8" class="headerlink" title="coding=utf-8"></a>coding=utf-8</h1><h1 id="author-‘Vi-Young’"><a href="#author-‘Vi-Young’" class="headerlink" title="author = ‘Vi-Young’"></a><strong>author</strong> = ‘Vi-Young’</h1><p>a = 21<br>b = 10<br>c = 0</p><p>if a != b:<br>    print(“2 - a 不等于 b”)z<br>else:<br>    print(“2 - a 等于 b”)</p><p>if a &lt; b:<br>    print(“3 - a 小于 b”)<br>else:<br>    print(“3 - a 大于等于 b”)</p><p>if a &gt; b:<br>    print(“4 - a 大于 b”)<br>else:<br>    print(“4 - a 小于等于 b”)</p><h1 id="修改变量-a-和-b-的值"><a href="#修改变量-a-和-b-的值" class="headerlink" title="修改变量 a 和 b 的值"></a>修改变量 a 和 b 的值</h1><p>a = 5;<br>b = 20;<br>if a &lt;= b:<br>    print(“5 - a 小于等于 b”)<br>else:<br>    print(“5 - a 大于  b”)</p><p>if b &gt;= a:<br>    print(“6 - b 大于等于 a”)<br>else:<br>    print(“6 - b 小于 a”)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">输出结果：</span><br></pre></td></tr></table></figure><p>False<br>1 - a 不等于 b<br>2 - a 不等于 b<br>3 - a 大于等于 b<br>4 - a 大于 b<br>5 - a 小于等于 b<br>6 - b 大于等于 a<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### 赋值运算符</span><br><span class="line"></span><br><span class="line">Python中赋值运算符有以下八种：</span><br><span class="line"></span><br><span class="line">-<span class="ruby">  基础赋值运算符（=） 将运算符右侧操作数赋值给左侧变量</span></span><br><span class="line"><span class="ruby">-  加法赋值运算符（+=） 将运算符左侧变量加上右侧操作数后再赋值给左侧变量</span></span><br><span class="line"><span class="ruby">-  减法赋值运算符（-=） 将运算符左侧变量减去右侧操作数后再赋值给左侧变量</span></span><br><span class="line"><span class="ruby">-  乘法赋值运算符（*=） 将运算符左侧变量乘以右侧操作数后再赋值给左侧变量</span></span><br><span class="line"><span class="ruby">-  除法赋值运算符（/=） 将运算符左侧变量除以右侧操作数后再赋值给左侧变量</span></span><br><span class="line"><span class="ruby">-  取模赋值运算符（%=） 将运算符左侧变量取模右侧操作数后再赋值给左侧变量</span></span><br><span class="line"><span class="ruby">-  幂赋值运算符（**=） 将运算符左侧变量进行右侧操作数次幂后再赋值给左侧变量</span></span><br><span class="line"><span class="ruby">-  取整除赋值运算符（/<span class="regexp">/+） 将运算符左侧变量对右侧操作数取整除后再赋值给左侧变量</span></span></span><br><span class="line"><span class="ruby"></span></span><br><span class="line"><span class="ruby">以下是该运算符的一些实例：</span></span><br></pre></td></tr></table></figure></p><h1 id="coding-utf-8-1"><a href="#coding-utf-8-1" class="headerlink" title="coding=utf-8"></a>coding=utf-8</h1><h1 id="author-‘Vi-Young’-1"><a href="#author-‘Vi-Young’-1" class="headerlink" title="author = ‘Vi-Young’"></a><strong>author</strong> = ‘Vi-Young’</h1><p>a = 15<br>b = 10<br>c = 0</p><p>c = a + b<br>print(“1 - c 的值为：”, c)</p><p>c += a<br>print(“2 - c 的值为：”, c)</p><p>c *= a<br>print(“3 - c 的值为：”, c)</p><p>c /= a<br>print(“4 - c 的值为：”, c)</p><p>c = 2<br>c %= a<br>print(“5 - c 的值为：”, c)</p><p>c **= a<br>print(“6 - c 的值为：”, c)</p><p>c //= a<br>print(“7 - c 的值为：”, c)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">输出结果：</span><br></pre></td></tr></table></figure><p>1 - c 的值为： 25<br>2 - c 的值为： 40<br>3 - c 的值为： 600<br>4 - c 的值为： 40.0<br>5 - c 的值为： 2<br>6 - c 的值为： 32768<br>7 - c 的值为： 2184<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### 位运算符</span><br><span class="line"></span><br><span class="line">顾名思义，位运算符就是把数字转换成二进制之后，再按位进行相应的运算。</span><br><span class="line"></span><br><span class="line">Python中有六种位运算符：</span><br><span class="line"></span><br><span class="line">- 按位与运算符（&amp;），参与运算的操作数，对应位都为<span class="number">1</span>时，结果为<span class="number">1</span>，否则为<span class="number">0</span>（ 同 <span class="number">1</span> 则 <span class="number">1</span>）</span><br><span class="line">- 按位或运算符（|），参与运算的操作数，对应位只要存在<span class="number">1</span>，结果就是<span class="number">1</span>，否则为<span class="number">0</span>（有 <span class="number">1</span> 则 <span class="number">1</span>）</span><br><span class="line">- 按位异或运算符（^），参与运算的操作数，对应位不相同结果时为<span class="number">1</span>，否则为<span class="number">0</span>（不同为<span class="number">1</span>）</span><br><span class="line">- 按位取反运算符（~），对数据的每位都进行取反，<span class="number">1</span>变为<span class="number">0</span>，<span class="number">0</span>变为<span class="number">1</span>（<span class="number">1</span>变<span class="number">0</span>，<span class="number">0</span>变<span class="number">1</span>）</span><br><span class="line">- 左移运算符（&lt;&lt;），运算数的二进制位全部左移若干位，高位舍弃，低位补<span class="number">0</span></span><br><span class="line">- 右移运算符（&gt;&gt;），运算数的二进制位全部右移若干位，低位丢弃，高位补<span class="number">0</span></span><br><span class="line"></span><br><span class="line">以下是该运算符的一些实例：</span><br></pre></td></tr></table></figure></p><p>#!/usr/bin/python3</p><p>a = 60            # 60 = 0011 1100<br>b = 13            # 13 = 0000 1101<br>c = 0</p><p>c = a &amp; b;        # 12 = 0000 1100<br>print (“1 - c 的值为：”, c)</p><p>c = a | b;        # 61 = 0011 1101<br>print (“2 - c 的值为：”, c)</p><p>c = a ^ b;        # 49 = 0011 0001<br>print (“3 - c 的值为：”, c)</p><p>c = ~a;           # -61 = 1100 0011<br>print (“4 - c 的值为：”, c)</p><p>c = a &lt;&lt; 2;       # 240 = 1111 0000<br>print (“5 - c 的值为：”, c)</p><p>c = a &gt;&gt; 2;       # 15 = 0000 1111<br>print (“6 - c 的值为：”, c)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">输出结果：</span><br></pre></td></tr></table></figure></p><p>1 - c 的值为： 12<br>2 - c 的值为： 61<br>3 - c 的值为： 49<br>4 - c 的值为： -61<br>5 - c 的值为： 240<br>6 - c 的值为： 15<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">##### 逻辑运算符</span></span><br><span class="line"></span><br><span class="line">Python中逻辑运算符有以下三种：</span><br><span class="line"></span><br><span class="line">- 布尔“与”（<span class="keyword">and</span>），例如：<span class="keyword">a</span> <span class="keyword">and</span> b，如果<span class="keyword">a</span>为False，则返回False，否则返回b的计算值</span><br><span class="line">- 布尔“或”（<span class="keyword">or</span>），例如：<span class="keyword">a</span> <span class="keyword">or</span> b，如果<span class="keyword">a</span>为True，返回<span class="keyword">a</span>的运算值，否则返回y的运算值</span><br><span class="line">- 布尔“非”（<span class="keyword">not</span>），例如：<span class="keyword">not</span> <span class="keyword">a</span>,如果<span class="keyword">a</span>为True，返回False，如果<span class="keyword">a</span>为False，返回True</span><br><span class="line"></span><br><span class="line">以下是该运算符的一些实例：</span><br></pre></td></tr></table></figure></p><h1 id="coding-utf-8-2"><a href="#coding-utf-8-2" class="headerlink" title="coding=utf-8"></a>coding=utf-8</h1><h1 id="author-‘Vi-Young’-2"><a href="#author-‘Vi-Young’-2" class="headerlink" title="author = ‘Vi-Young’"></a><strong>author</strong> = ‘Vi-Young’</h1><h1 id="usr-bin-python3"><a href="#usr-bin-python3" class="headerlink" title="!/usr/bin/python3"></a>!/usr/bin/python3</h1><p>a = 10<br>b = 20</p><p>if a and b:<br>    print(“1 - 变量 a 和 b 都为 true”)<br>else:<br>    print(“1 - 变量 a 和 b 有一个不为 true”)</p><p>if a or b:<br>    print(“2 - 变量 a 和 b 都为 true，或其中一个变量为 true”)<br>else:<br>    print(“2 - 变量 a 和 b 都不为 true”)</p><h1 id="修改变量-a-的值"><a href="#修改变量-a-的值" class="headerlink" title="修改变量 a 的值"></a>修改变量 a 的值</h1><p>a = 0<br>if a and b:<br>    print(“3 - 变量 a 和 b 都为 true”)<br>else:<br>    print(“3 - 变量 a 和 b 有一个不为 true”)</p><p>if a or b:<br>    print(“4 - 变量 a 和 b 都为 true，或其中一个变量为 true”)<br>else:<br>    print(“4 - 变量 a 和 b 都不为 true”)</p><p>if not (a and b):<br>    print(“5 - 变量 a 和 b 都为 false，或其中一个变量为 false”)<br>else:<br>    print(“5 - 变量 a 和 b 都为 true”)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">输出结果：</span><br></pre></td></tr></table></figure></p><p>1 - 变量 a 和 b 都为 true<br>2 - 变量 a 和 b 都为 true，或其中一个变量为 true<br>3 - 变量 a 和 b 有一个不为 true<br>4 - 变量 a 和 b 都为 true，或其中一个变量为 true<br>5 - 变量 a 和 b 都为 false，或其中一个变量为 false</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### 成员运算符</span><br><span class="line"></span><br><span class="line">Python中的成员运算符包括以下两种：</span><br><span class="line"></span><br><span class="line">- <span class="keyword">in</span>，如果在指定的序列中找到值返回<span class="literal">True</span>，否则返回<span class="literal">False</span></span><br><span class="line">- not <span class="keyword">in</span>，如果在指定的序列中没有找到值返回<span class="literal">True</span>，否则返回<span class="literal">False</span></span><br><span class="line"></span><br><span class="line">下面是该运算符的一些实例：</span><br></pre></td></tr></table></figure><h1 id="coding-utf-8-3"><a href="#coding-utf-8-3" class="headerlink" title="coding=utf-8"></a>coding=utf-8</h1><h1 id="author-‘Vi-Young’-3"><a href="#author-‘Vi-Young’-3" class="headerlink" title="author = ‘Vi-Young’"></a><strong>author</strong> = ‘Vi-Young’</h1><h1 id="usr-bin-python3-1"><a href="#usr-bin-python3-1" class="headerlink" title="!/usr/bin/python3"></a>!/usr/bin/python3</h1><p>a = 10<br>b = 20<br>testList = [1, 2, 3, 4, 5];</p><p>if a in testList:<br>    print(“1 - 变量 a 在给定的列表中 list 中”)<br>else:<br>    print(“1 - 变量 a 不在给定的列表中 list 中”)</p><p>if b not in testList:<br>    print(“2 - 变量 b 不在给定的列表中 list 中”)<br>else:<br>    print(“2 - 变量 b 在给定的列表中 list 中”)</p><h1 id="修改变量-a-的值-1"><a href="#修改变量-a-的值-1" class="headerlink" title="修改变量 a 的值"></a>修改变量 a 的值</h1><p>a = 2<br>if (a in testList):<br>    print(“3 - 变量 a 在给定的列表中 list 中”)<br>else:<br>    print(“3 - 变量 a 不在给定的列表中 list 中”)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">输出结果：</span><br></pre></td></tr></table></figure><p>1 - 变量 a 不在给定的列表中 list 中<br>2 - 变量 b 不在给定的列表中 list 中<br>3 - 变量 a 在给定的列表中 list 中</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">##### 身份运算符</span></span><br><span class="line"></span><br><span class="line">Python的身份运算符包括以下两种：</span><br><span class="line"></span><br><span class="line">- <span class="keyword">is</span>，<span class="keyword">is</span>是判断两个标识符是不是引用自一个对象（后面会单独开一章说python中<span class="keyword">is</span>和==的区别）</span><br><span class="line">- <span class="keyword">is</span> <span class="keyword">not</span>，<span class="keyword">is</span> <span class="keyword">not</span>是判断两个标识符是不是引用自不同对象</span><br><span class="line"></span><br><span class="line">下面是该运算符的一些实例：</span><br></pre></td></tr></table></figure><h1 id="coding-utf-8-4"><a href="#coding-utf-8-4" class="headerlink" title="coding=utf-8"></a>coding=utf-8</h1><h1 id="author-‘Vi-Young’-4"><a href="#author-‘Vi-Young’-4" class="headerlink" title="author = ‘Vi-Young’"></a><strong>author</strong> = ‘Vi-Young’</h1><h1 id="usr-bin-python3-2"><a href="#usr-bin-python3-2" class="headerlink" title="!/usr/bin/python3"></a>!/usr/bin/python3</h1><p>a = 400</p><p>b = 400</p><p>if a is b:<br>    print(“1 - a 和 b 有相同的标识”)<br>else:<br>    print(“1 - a 和 b 没有相同的标识”)</p><p>if id(a) == id(b):<br>    print(“2 - a 和 b 有相同的标识”)<br>else:<br>    print(“2 - a 和 b 没有相同的标识”)</p><h1 id="修改变量-b-的值"><a href="#修改变量-b-的值" class="headerlink" title="修改变量 b 的值"></a>修改变量 b 的值</h1><p>b = 30<br>if a is b:<br>    print(“3 - a 和 b 有相同的标识”)<br>else:<br>    print(“3 - a 和 b 没有相同的标识”)</p><p>if a is not b:<br>    print(“4 - a 和 b 没有相同的标识”)<br>else:<br>    print(“4 - a 和 b 有相同的标识”)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">输出结果：</span><br></pre></td></tr></table></figure></p><p>1 - a 和 b 有相同的标识<br>2 - a 和 b 有相同的标识<br>3 - a 和 b 没有相同的标识<br>4 - a 和 b 没有相同的标识<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">##### 运算符优先级</span></span><br><span class="line"></span><br><span class="line">|<span class="string">运算符</span>|<span class="string"> 描述 </span>|<span class="string"> </span></span><br><span class="line">|<span class="string">:------------- </span>|<span class="string">:-------------</span>|<span class="string"> </span></span><br><span class="line">|<span class="string">** </span>|<span class="string">指数 (最高优先级) </span>|<span class="string"> </span></span><br><span class="line">|<span class="string">~，+，- </span>|<span class="string">按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@) </span>|<span class="string"> </span></span><br><span class="line">|<span class="string">*，/，%，//</span>|<span class="string"> 乘，除，取模和取整除</span>|<span class="string"> </span></span><br><span class="line">|<span class="string">+- </span>|<span class="string"> 加法减法</span>|<span class="string"> </span></span><br><span class="line">|<span class="string">‘&gt;&gt;’，&lt;&lt; </span>|<span class="string">右移，左移运算符 </span>|<span class="string"> </span></span><br><span class="line">|<span class="string">&amp; </span>|<span class="string"> 位 'AND'</span>|<span class="string"> </span></span><br><span class="line">|<span class="string">或，异或</span>|<span class="string"> 位运算符</span>|<span class="string"> </span></span><br><span class="line">|<span class="string">&lt;=，&lt;，&gt;，&gt;= </span>|<span class="string"> 比较运算符</span>|<span class="string"> </span></span><br><span class="line">|<span class="string">&lt;&gt;，==，!=</span>|<span class="string">等于运算符</span>|</span><br><span class="line">|<span class="string">=，%=，/=，//=，-=，+=，*=，**= </span>|<span class="string"> 赋值运算符</span>|<span class="string"> </span></span><br><span class="line">|<span class="string">is，is not</span>|<span class="string">身份运算符 </span>|<span class="string"> </span></span><br><span class="line">|<span class="string">in，not in</span>|<span class="string"> 成员运算符</span>|</span><br><span class="line">|<span class="string">and，or，not</span>|<span class="string">逻辑运算符</span>|<span class="string"> </span></span><br><span class="line"></span><br><span class="line"><span class="string">下面是一些实例：</span></span><br></pre></td></tr></table></figure></p><p>a = 20<br>b = 10<br>c = 15<br>d = 5<br>e = 0</p><p>e = (a + b) <em> c / d       #( 30 </em> 15 ) / 5<br>print (“(a + b) * c / d 运算结果为：”,  e)</p><p>e = ((a + b) <em> c) / d     # (30 </em> 15 ) / 5<br>print (“((a + b) * c) / d 运算结果为：”,  e)</p><p>e = (a + b) <em> (c / d);    # (30) </em> (15/5)<br>print (“(a + b) * (c / d) 运算结果为：”,  e)</p><p>e = a + (b <em> c) / d;      #  20 + (150/5)<br>print (“a + (b </em> c) / d 运算结果为：”,  e)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">输出结果：</span><br></pre></td></tr></table></figure></p><p>(a + b) <em> c / d 运算结果为： 90.0<br>((a + b) </em> c) / d 运算结果为： 90.0<br>(a + b) <em> (c / d) 运算结果为： 90.0<br>a + (b </em> c) / d 运算结果为： 50.0<br><code>`</code></p><hr><h5 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h5><p>扫码或微信搜索Vi的技术博客，关注公众号，不定期送书活动各种福利~</p><p><img src="http://upload-images.jianshu.io/upload_images/10641481-961b717327e333ab.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h5&gt;&lt;p&gt;比如：4 +5 = 9 。 例子中，4 和 5 被称为操作数，”+” 称为运算符。&lt;br&gt;Python语言包括以下九种运算符：&lt;/p&gt;
&lt;u
      
    
    </summary>
    
      <category term="Python" scheme="http://vi-young.com/categories/Python/"/>
    
    
      <category term="Python3" scheme="http://vi-young.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Python3 系列（三）：基本数据类型</title>
    <link href="http://vi-young.com/2018/06/28/Python3-%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://vi-young.com/2018/06/28/Python3-系列（三）：基本数据类型/</id>
    <published>2018-06-28T07:55:00.000Z</published>
    <updated>2018-06-27T07:57:07.035Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h4><p><strong>Python中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。</strong></p><p>在Python中，变量就是变量，它没有类型，我们所说的”类型”是变量所指的内存中对象的类型。</p><p>Python 3 中有六个标准的数据类型：</p><ul><li>Numbers（数字）</li><li>String（字符串）</li><li>List（列表）</li><li>Tuple（元组）</li><li>Sets（集合）</li><li>Dictionaries（字典）</li></ul><p>Python3 的六个标准数据类型中：</p><ul><li>不可变数据（3个）：Number，String，Tuple</li><li>可变数据（3个）：List，Dictionary，Set</li></ul><h4 id="Number（数字）"><a href="#Number（数字）" class="headerlink" title="Number（数字）"></a>Number（数字）</h4><p>Python3 支持int，float，bool，complex（复数）<br>在Python 3里，只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。</p><p>像大多数语言一样，数值类型的赋值和计算都是很直观的。</p><h5 id="type和isinstance"><a href="#type和isinstance" class="headerlink" title="type和isinstance"></a>type和isinstance</h5><p>内置的 type() 函数可以用来查询变量所指的对象类型。</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="title">a</span>, b, c, d = <span class="number">20</span>, <span class="number">5.5</span>, <span class="type">True</span>, <span class="number">4</span>+<span class="number">3</span>j</span><br><span class="line"><span class="title">print</span>(<span class="keyword">type</span>(a), <span class="keyword">type</span>(b), <span class="keyword">type</span>(c), <span class="keyword">type</span>(d))</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">class</span> <span class="string">'int'</span>&gt; &lt;<span class="keyword">class</span> <span class="string">'float'</span>&gt; &lt;<span class="keyword">class</span> <span class="string">'bool'</span>&gt; &lt;<span class="keyword">class</span> <span class="string">'complex'</span>&gt;</span><br></pre></td></tr></table></figure><p>当然，你也可以选择使用instance来判断类型：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(isinstance(a, int)</span></span>)</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>isinstance 和 type 的区别在于：</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">A</span>:</span></span><br><span class="line"><span class="class">    pass</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">B</span>(<span class="type">A</span>):</span></span><br><span class="line"><span class="class">    pass</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">print(<span class="title">isinstance</span>(<span class="type">A</span>(), <span class="type">A</span>))</span></span><br><span class="line"><span class="class">print((<span class="title">type</span>(<span class="type">A</span>()) == <span class="type">A</span>))</span></span><br><span class="line"><span class="class">print(<span class="title">isinstance</span>(<span class="type">B</span>(), <span class="type">A</span>))</span></span><br><span class="line"><span class="class">print((<span class="title">type</span>(<span class="type">B</span>()) == <span class="type">A</span>))</span></span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p>由此可以看出这两者的区别在于：</p><ul><li>type()不会认为子类是一种父类类型</li><li>isinstance()会认为子类是一种父类类型</li></ul><blockquote><p>在 Python2 中是没有布尔型的，它用数字 0 表示 False，用 1 表示 True。到 Python3 中，把 True 和 False 定义成关键字了，但它们的值还是 1 和 0，它们可以和数字相加。</p></blockquote><h5 id="del函数"><a href="#del函数" class="headerlink" title="del函数"></a>del函数</h5><p>当你指定一个值时，Number对象就会被创建：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">var1</span> = <span class="number">1</span></span><br><span class="line"><span class="attr">var2</span> = <span class="number">10</span></span><br></pre></td></tr></table></figure><p>如果我们不想使用该对象，可以使用del()删除一些对象的引用，del用法如下：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">del var1<span class="comment">[, var2<span class="comment">[,var3<span class="comment">[...,varN]</span>]</span>]</span>]</span><br></pre></td></tr></table></figure><p>比如：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var1 = <span class="number">1</span>;</span><br><span class="line">var2 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">var3 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">del var1, var3[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">print(var2)</span><br><span class="line">print(var3)</span><br><span class="line">print(var1)</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">[2, 3, 4]</span><br><span class="line">Traceback (most recent <span class="keyword">call</span> <span class="keyword">last</span>):</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"C:/Users/18530/PycharmProjects/HelloWorld/helloworld.py"</span>, line <span class="number">12</span>, <span class="keyword">in</span> &lt;<span class="keyword">module</span>&gt;</span><br><span class="line">    print(var1)</span><br><span class="line">NameError: <span class="keyword">name</span> <span class="string">'var1'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure><p>这里可以看到，var1变量被删除后，打印时会出错，而var3的第一个元素被删除后，只打印出了后三个元素。</p><h5 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h5><p>直接上例子：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var1 = 5 + 4  <span class="comment"># 加法</span></span><br><span class="line">var2 = 4.3 - 2 <span class="comment"># 减法</span></span><br><span class="line">var3 = 3 * 7  <span class="comment"># 乘法</span></span><br><span class="line">var4 = 2 / 4  <span class="comment"># 除法，得到一个浮点数</span></span><br><span class="line">var5 = 2 // 4 <span class="comment"># 除法，得到一个整数</span></span><br><span class="line">var6 = 17 % 3 <span class="comment"># 取余</span></span><br><span class="line">var7 = 2 ** 5 <span class="comment"># 乘方</span></span><br><span class="line"></span><br><span class="line">print(var1)</span><br><span class="line">print(var2)</span><br><span class="line">print(var3)</span><br><span class="line">print(var4)</span><br><span class="line">print(var5)</span><br><span class="line">print(var6)</span><br><span class="line">print(var7)</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">2.3</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">0.5</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">32</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>Python可以同时为多个变量赋值，如a, b = 1, 2。</li><li>一个变量可以通过赋值指向不同类型的对象。</li><li>数值的除法包含两个运算符：/ 返回一个浮点数，// 返回一个整数。</li><li>在混合计算时，Python会把整型转换成为浮点数。</li></ul><p>数值类型实例：</p><table><thead><tr><th style="text-align:center">int</th><th style="text-align:center">float</th><th style="text-align:center">complex</th></tr></thead><tbody><tr><td style="text-align:center">10</td><td style="text-align:center">0.0</td><td style="text-align:center">3.14j</td></tr><tr><td style="text-align:center">100</td><td style="text-align:center">15.20</td><td style="text-align:center">45.j</td></tr><tr><td style="text-align:center">-786</td><td style="text-align:center">21.9</td><td style="text-align:center">9.322e-36j</td></tr><tr><td style="text-align:center">080</td><td style="text-align:center">32.3e+18</td><td style="text-align:center">.876j</td></tr><tr><td style="text-align:center">-0490</td><td style="text-align:center">-90.</td><td style="text-align:center">-.6546+0J</td></tr><tr><td style="text-align:center">-0x260</td><td style="text-align:center">-32.54e100</td><td style="text-align:center">3e+26J</td></tr><tr><td style="text-align:center">0x69</td><td style="text-align:center">70.2E-12</td><td style="text-align:center">4.53e-7j</td></tr></tbody></table><p> Python还支持复数，复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型</p><h4 id="String（字符串）"><a href="#String（字符串）" class="headerlink" title="String（字符串）"></a>String（字符串）</h4><p>字符串在上次的基本语法中已经详细介绍过了，这里再补充几点：</p><ul><li>Python使用反斜杠转义特殊字符，如果你不想让反斜杠发生转移，可以在字符串前面添加一个r，表示原始字符</li><li>Python 没有单独的字符类型，一个字符就是长度为1的字符串。</li><li>字符串可以用+运算符连接在一起，用*运算符重复。 </li><li>Python中的字符串有两种索引方式，从左往右以0开始，从右往左以-1开始。</li><li>Python中的字符串不能改变。</li></ul><h4 id="List（列表）"><a href="#List（列表）" class="headerlink" title="List（列表）"></a>List（列表）</h4><p>List（列表） 是 Python 中使用最频繁的数据类型。</p><p>列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。</p><p>列表是写 [] 之间、用逗号分隔开的元素列表。</p><p>和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。</p><p>列表截取的语法格式如下：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量<span class="string">[头下标:尾下标]</span></span><br></pre></td></tr></table></figure><p>索引值以 0 为开始值，-1 为从末尾的开始位置。</p><p>加号（+）是列表连接运算符，星号（*）是重复操作。如下实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="string">'abcd'</span>, 786, 2.23, <span class="string">'vi'</span>, 70.2]</span><br><span class="line">list2 = [123, <span class="string">'vi'</span>]</span><br><span class="line">list3 = [list1, list2]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(list1)  <span class="comment"># 输出完整列表</span></span><br><span class="line"><span class="built_in">print</span>(list1[0])  <span class="comment"># 输出列表第一个元素</span></span><br><span class="line"><span class="built_in">print</span>(list1[1:3])  <span class="comment"># 从第二个开始输出到第三个元素</span></span><br><span class="line"><span class="built_in">print</span>(list1[2:])  <span class="comment"># 输出从第三个元素开始的所有元素</span></span><br><span class="line"><span class="built_in">print</span>(list2 * 2)  <span class="comment"># 输出两次列表</span></span><br><span class="line"><span class="built_in">print</span>(list1 + list2)  <span class="comment"># 连接列表</span></span><br><span class="line"><span class="built_in">print</span>(list3)    <span class="comment">#输出列表元素为列表的列表</span></span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'abcd'</span>, <span class="number">786</span>, <span class="number">2.23</span>, <span class="string">'vi'</span>, <span class="number">70.2</span>]</span><br><span class="line">abcd</span><br><span class="line">[<span class="number">786</span>, <span class="number">2.23</span>]</span><br><span class="line">[<span class="number">2.23</span>, <span class="string">'vi'</span>, <span class="number">70.2</span>]</span><br><span class="line">[<span class="number">123</span>, <span class="string">'vi'</span>, <span class="number">123</span>, <span class="string">'vi'</span>]</span><br><span class="line">[<span class="string">'abcd'</span>, <span class="number">786</span>, <span class="number">2.23</span>, <span class="string">'vi'</span>, <span class="number">70.2</span>, <span class="number">123</span>, <span class="string">'vi'</span>]</span><br><span class="line">[[<span class="string">'abcd'</span>, <span class="number">786</span>, <span class="number">2.23</span>, <span class="string">'vi'</span>, <span class="number">70.2</span>], [<span class="number">123</span>, <span class="string">'vi'</span>]]</span><br></pre></td></tr></table></figure><p>与字符串不同，列表中的元素可以改变：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="selector-tag">a</span>[<span class="number">0</span>] = <span class="number">9</span></span><br><span class="line"><span class="selector-tag">a</span>[<span class="number">2</span>:<span class="number">5</span>] = [<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(a)</span></span></span><br><span class="line"><span class="selector-tag">a</span>[<span class="number">2</span>:<span class="number">5</span>] = []</span><br><span class="line"><span class="function"><span class="title">print</span><span class="params">(a)</span></span></span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">9</span>, <span class="number">2</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>, <span class="number">6</span>]</span><br><span class="line">[<span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li>List写在方括号之间，元素用逗号隔开。</li><li>和字符串一样，list可以被索引和切片。</li><li>List可以使用+操作符进行拼接。</li><li>List中的元素是可以改变的。</li></ul><h4 id="Tuple（元组）"><a href="#Tuple（元组）" class="headerlink" title="Tuple（元组）"></a>Tuple（元组）</h4><p>元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号 () 里，元素之间用逗号隔开。</p><p>元组中的元素类型也可以不相同：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">list1 = [1, 2, 3]</span><br><span class="line">tuple1 = (<span class="string">'abcd'</span>, 786, 2.23, <span class="string">'runoob'</span>, 70.2)</span><br><span class="line">tuple2 = (123, <span class="string">'runoob'</span>)</span><br><span class="line">tuple3 = [list1, tuple1, tuple2]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(tuple1)  <span class="comment"># 输出完整元组</span></span><br><span class="line"><span class="built_in">print</span>(tuple1[0])  <span class="comment"># 输出元组的第一个元素</span></span><br><span class="line"><span class="built_in">print</span>(tuple1[1:3])  <span class="comment"># 输出从第二个元素开始到第三个元素</span></span><br><span class="line"><span class="built_in">print</span>(tuple1[2:])  <span class="comment"># 输出从第三个元素开始的所有元素</span></span><br><span class="line"><span class="built_in">print</span>(tuple2 * 2)  <span class="comment"># 输出两次元组</span></span><br><span class="line"><span class="built_in">print</span>(tuple1 + tuple2)  <span class="comment"># 连接元组</span></span><br><span class="line"><span class="built_in">print</span>(tuple3)   <span class="comment"># 输出元组中元素为元组和列表的元组</span></span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">('abcd', <span class="number">786</span>, <span class="number">2.23</span>, 'runoob', <span class="number">70.2</span>)</span><br><span class="line">abcd</span><br><span class="line">(<span class="number">786</span>, <span class="number">2.23</span>)</span><br><span class="line">(<span class="number">2.23</span>, 'runoob', <span class="number">70.2</span>)</span><br><span class="line">(<span class="number">123</span>, 'runoob', <span class="number">123</span>, 'runoob')</span><br><span class="line">('abcd', <span class="number">786</span>, <span class="number">2.23</span>, 'runoob', <span class="number">70.2</span>, <span class="number">123</span>, 'runoob')</span><br><span class="line">[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], ('abcd', <span class="number">786</span>, <span class="number">2.23</span>, 'runoob', <span class="number">70.2</span>), (<span class="number">123</span>, 'runoob')]</span><br></pre></td></tr></table></figure><p>元组与字符串类似，可以被索引且下标索引从0开始，-1 为从末尾开始的位置。也可以进行截取（看上面，这里不再赘述）。</p><p>其实，可以把字符串看作一种特殊的元组。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tup = (1, 2, 3, 4, 5, 6)</span><br><span class="line">print(tup[0])</span><br><span class="line"><span class="section">print(tup[1:5])</span></span><br><span class="line">tup[0] = 11 <span class="comment"># 修改元组元素的操作是非法的</span></span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">Traceback (most recent <span class="keyword">call</span> <span class="keyword">last</span>):</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">  <span class="keyword">File</span> <span class="string">"C:/Users/18530/PycharmProjects/HelloWorld/helloworld.py"</span>, line <span class="number">7</span>, <span class="keyword">in</span> &lt;<span class="keyword">module</span>&gt;</span><br><span class="line">    tup[<span class="number">0</span>] = <span class="number">11</span></span><br><span class="line">TypeError: <span class="string">'tuple'</span> <span class="keyword">object</span> does <span class="keyword">not</span> support item assignment</span><br></pre></td></tr></table></figure><p>如上所示，如果试图修改tuple中的元素系统就会出错，虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。</p><p>构造包含 0 个或 1 个元素的元组比较特殊，所以有一些额外的语法规则：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tup1 = ()    <span class="comment"># 空元组</span></span><br><span class="line">tup2 = (20,) <span class="comment"># 一个元素，需要在元素后添加逗号</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>与字符串一样，元组的元素不能修改。</li><li>元组也可以被索引和切片，方法一样。</li><li>注意构造包含0或1个元素的元组的特殊语法规则。</li><li>元组也可以使用+操作符进行拼接。</li></ul><h4 id="Set（集合）"><a href="#Set（集合）" class="headerlink" title="Set（集合）"></a>Set（集合）</h4><p>集合（set）是一个无序不重复元素的序列。</p><p>基本功能是进行成员关系测试和删除重复元素。</p><p>可以使用大括号 <code>{ }</code> 或者 <code>set()</code> 函数创建集合，注意：创建一个空集合必须用 <code>set()</code> 而不是 <code>{ }</code>，因为 <code>{ }</code> 是用来创建一个空字典。</p><p>Example：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">student = &#123;<span class="string">'Tom'</span>, <span class="string">'Jim'</span>, <span class="string">'Mary'</span>, <span class="string">'Tom'</span>, <span class="string">'Jack'</span>, <span class="string">'Rose'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(student)  <span class="comment"># 输出集合，重复的元素被自动去掉</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 成员测试</span></span><br><span class="line"><span class="keyword">if</span> (<span class="string">'Rose'</span> <span class="keyword">in</span> student):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Rose 在集合中'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Rose 不在集合中'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># set可以进行集合运算</span></span><br><span class="line">a = <span class="built_in">set</span>(<span class="string">'abracadabra'</span>)</span><br><span class="line">b = <span class="built_in">set</span>(<span class="string">'alacazam'</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"><span class="built_in">print</span>(b)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a - b)  <span class="comment"># a和b的差集</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a | b)  <span class="comment"># a和b的并集</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a &amp; b)  <span class="comment"># a和b的交集</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a ^ b)  <span class="comment"># a和b中不同时存在的元素</span></span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">'Tom'</span>, <span class="string">'Mary'</span>, <span class="string">'Rose'</span>, <span class="string">'Jack'</span>, <span class="string">'Jim'</span>&#125;</span><br><span class="line">Rose 在集合中</span><br><span class="line">&#123;<span class="string">'d'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'r'</span>, <span class="string">'b'</span>&#125;</span><br><span class="line">&#123;<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'z'</span>, <span class="string">'l'</span>, <span class="string">'m'</span>&#125;</span><br><span class="line">&#123;<span class="string">'d'</span>, <span class="string">'r'</span>, <span class="string">'b'</span>&#125;</span><br><span class="line">&#123;<span class="string">'d'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'z'</span>, <span class="string">'r'</span>, <span class="string">'l'</span>, <span class="string">'m'</span>, <span class="string">'b'</span>&#125;</span><br><span class="line">&#123;<span class="string">'a'</span>, <span class="string">'c'</span>&#125;</span><br><span class="line">&#123;<span class="string">'d'</span>, <span class="string">'l'</span>, <span class="string">'b'</span>, <span class="string">'z'</span>, <span class="string">'m'</span>, <span class="string">'r'</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="Dictionary（字典）"><a href="#Dictionary（字典）" class="headerlink" title="Dictionary（字典）"></a>Dictionary（字典）</h4><p>字典（dictionary）是Python中另一个非常有用的内置数据类型。</p><p>列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。</p><p>字典是一种映射类型，字典用”{ }”标识，它是一个无序的键(key) : 值(value)对集合。</p><p>键(key)必须使用不可变类型。</p><p>在同一个字典中，键(key)必须是唯一的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dict1 = &#123;&#125;</span><br><span class="line">dict1[<span class="string">'one'</span>] = <span class="string">"Young"</span></span><br><span class="line">dict1[2] = <span class="string">"Vi"</span></span><br><span class="line"></span><br><span class="line">dict2 = &#123;<span class="string">'name'</span>: <span class="string">'Vi_Young'</span>, <span class="string">'code'</span>: 200, <span class="string">'site'</span>: <span class="string">'vi-young.com'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dict1)</span><br><span class="line"><span class="built_in">print</span>(dict1[<span class="string">'one'</span>])  <span class="comment"># 输出键为 'one' 的值</span></span><br><span class="line"><span class="built_in">print</span>(dict1[2])  <span class="comment"># 输出键为 2 的值</span></span><br><span class="line"><span class="built_in">print</span>(dict2)  <span class="comment"># 输出完整的字典</span></span><br><span class="line"><span class="built_in">print</span>(dict2.keys())  <span class="comment"># 输出所有键</span></span><br><span class="line"><span class="built_in">print</span>(dict2.values())  <span class="comment"># 输出所有值</span></span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">'one'</span>: <span class="string">'Young'</span>, <span class="number">2</span>: <span class="string">'Vi'</span>&#125;</span><br><span class="line">Young</span><br><span class="line">Vi</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'Vi_Young'</span>, <span class="string">'code'</span>: <span class="number">200</span>, <span class="string">'site'</span>: <span class="string">'vi-young.com'</span>&#125;</span><br><span class="line"><span class="function"><span class="title">dict_keys</span><span class="params">([<span class="string">'name'</span>, <span class="string">'code'</span>, <span class="string">'site'</span>])</span></span></span><br><span class="line"><span class="function"><span class="title">dict_values</span><span class="params">([<span class="string">'Vi_Young'</span>, <span class="number">200</span>, <span class="string">'vi-young.com'</span>])</span></span></span><br></pre></td></tr></table></figure><p>构建函数dict()可以直接从键值对序列中构建字典如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dict1 = dict([(<span class="string">'Google'</span>, 1), (<span class="string">'Taobao'</span>, 2)])</span><br><span class="line">dict2 = &#123;x: x ** 2 <span class="keyword">for</span> x <span class="keyword">in</span> (2, 4, 6)&#125;</span><br><span class="line">dict3 = dict(Google=1, Taobao=2)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dict1)</span><br><span class="line"><span class="built_in">print</span>(dict2)</span><br><span class="line"><span class="built_in">print</span>(dict3)</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">'Google'</span>: <span class="number">1</span>, <span class="string">'Taobao'</span>: <span class="number">2</span>&#125;</span><br><span class="line">&#123;<span class="number">2</span>: <span class="number">4</span>, <span class="number">4</span>: <span class="number">16</span>, <span class="number">6</span>: <span class="number">36</span>&#125;</span><br><span class="line">&#123;<span class="string">'Google'</span>: <span class="number">1</span>, <span class="string">'Taobao'</span>: <span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><p>另外，字典类型也有一些内置的函数，例如clear()、keys()、values()等。</p><p><strong>注意：</strong></p><ul><li>字典是一种映射类型，它的元素是键值对。</li><li>字典的关键字必须为不可变类型，且不能重复。</li><li>创建空字典使用 { }。</li></ul><h4 id="Python数据类型转换"><a href="#Python数据类型转换" class="headerlink" title="Python数据类型转换"></a>Python数据类型转换</h4><p>有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。</p><p>以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。</p><table><thead><tr><th style="text-align:left">函数</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">int(x [,base])</td><td style="text-align:left">将x转换为一个整数</td></tr><tr><td style="text-align:left">float(x)</td><td style="text-align:left">将x转换到一个浮点数</td></tr><tr><td style="text-align:left">complex(real [,imag])</td><td style="text-align:left">创建一个复数</td></tr><tr><td style="text-align:left">str(x)</td><td style="text-align:left">将对象 x 转换为字符串</td></tr><tr><td style="text-align:left">repr(x)</td><td style="text-align:left">将对象 x 转换为表达式字符串</td></tr><tr><td style="text-align:left">eval(str)</td><td style="text-align:left">用来计算在字符串中的有效Python表达式,并返回一个对象</td></tr><tr><td style="text-align:left">tuple(s)</td><td style="text-align:left">将序列 s 转换为一个元组</td></tr><tr><td style="text-align:left">list(s)</td><td style="text-align:left">将序列 s 转换为一个列表</td></tr><tr><td style="text-align:left">set(s)</td><td style="text-align:left">转换为可变集合</td></tr><tr><td style="text-align:left">dict(d)</td><td style="text-align:left">创建一个字典。d 必须是一个序列 (key,value)元组。</td></tr><tr><td style="text-align:left">frozenset(s)</td><td style="text-align:left">转换为不可变集合</td></tr><tr><td style="text-align:left">chr(x)</td><td style="text-align:left">将一个整数转换为一个字符</td></tr><tr><td style="text-align:left">ord(x)</td><td style="text-align:left">将一个字符转换为它的整数值</td></tr><tr><td style="text-align:left">hex(x)</td><td style="text-align:left">将一个整数转换为一个十六进制字符串</td></tr><tr><td style="text-align:left">oct(x)</td><td style="text-align:left">将一个整数转换为一个八进制字符串</td></tr></tbody></table><h4 id="下节预告："><a href="#下节预告：" class="headerlink" title="下节预告："></a>下节预告：</h4><p>运算符</p><hr><h4 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h4><p>扫码或微信搜索Vi的技术博客，关注公众号，不定期送书活动各种福利~</p><p><img src="https://i.imgur.com/jK9vpVj.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;Python中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。&lt;/strong&gt;&lt;/p&gt;
      
    
    </summary>
    
      <category term="Python" scheme="http://vi-young.com/categories/Python/"/>
    
    
      <category term="Python3" scheme="http://vi-young.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Python3 系列（二）：语法</title>
    <link href="http://vi-young.com/2018/06/27/Python3-%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%AF%AD%E6%B3%95/"/>
    <id>http://vi-young.com/2018/06/27/Python3-系列（二）：语法/</id>
    <published>2018-06-26T17:07:00.000Z</published>
    <updated>2018-06-26T09:09:02.004Z</updated>
    
    <content type="html"><![CDATA[<h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><p>Python 3 源码文件在默认情况下以UTF-8编码，所有的字符串都是unicode字符串，当然，如果加上<code># coding=utf-8</code>是最稳妥的选择，我们也可以给源码文件指定不同的编码：<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">_</span>*<span class="keyword">_</span> coding: cp<span class="number">-1252</span> -*-</span><br></pre></td></tr></table></figure></p><blockquote><p>ps: cp-1252对应适合语言为保加利亚语、白罗斯语、马其顿语、俄语、塞尔维亚语。</p></blockquote><h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><ul><li>第一个字符必须是字母或下划线_</li><li>其他部分由字母，数字和下划线组成</li><li>严格区分大小写</li></ul><blockquote><p>首位：(a~z ，A~Z ，_ ) + 其他位：(a~z ，A~Z ，0-9 ，_ ) </p></blockquote><h4 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> coding=utf-8</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> __author__ = <span class="string">'Vi-Young'</span></span></span><br><span class="line"></span><br><span class="line">import keyword</span><br><span class="line"></span><br><span class="line">print(keyword.kwlist)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="symbol">'False</span>', <span class="symbol">'None</span>', <span class="symbol">'True</span>', <span class="symbol">'and</span>', <span class="symbol">'as</span>', <span class="symbol">'assert</span>', <span class="symbol">'break</span>', <span class="symbol">'class</span>', <span class="symbol">'continue</span>', <span class="symbol">'def</span>', <span class="symbol">'del</span>', <span class="symbol">'elif</span>', <span class="symbol">'else</span>', <span class="symbol">'except</span>', <span class="symbol">'finally</span>', <span class="symbol">'for</span>', <span class="symbol">'from</span>', <span class="symbol">'global</span>', <span class="symbol">'if</span>', <span class="symbol">'import</span>', <span class="symbol">'in</span>', <span class="symbol">'is</span>', <span class="symbol">'lambda</span>', <span class="symbol">'nonlocal</span>', <span class="symbol">'not</span>', <span class="symbol">'or</span>', <span class="symbol">'pass</span>', <span class="symbol">'raise</span>', <span class="symbol">'return</span>', <span class="symbol">'try</span>', <span class="symbol">'while</span>', <span class="symbol">'with</span>', <span class="symbol">'yield</span>']</span><br></pre></td></tr></table></figure><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><ol><li><p>单行注释</p><p> 以#开头</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#第一个注释</span></span><br><span class="line">print(<span class="string">"I Love Python!"</span>) <span class="comment">#我爱python</span></span><br></pre></td></tr></table></figure></li><li><p>多行注释</p><ol start="3"><li>多个#号</li><li><p>使用’’’ 或 “””</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注释第一行</span></span><br><span class="line"><span class="comment"># 注释第二行</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">第一行注释</span></span><br><span class="line"><span class="string">第二行注释</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">第一行注释</span></span><br><span class="line"><span class="string">第二行注释</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure></li></ol></li></ol><h4 id="行与缩进"><a href="#行与缩进" class="headerlink" title="行与缩进"></a>行与缩进</h4><p>python最具特色的就是使用缩进来表示代码块，不需要使用大括号 {} 。缩进的空格数是可变的（这里一般要求缩进为四个空格，美观且规范），但是同一个代码块的语句必须包含相同的缩进空格数，否则就会抛出<code>IndentationError</code>这个错误</p><h4 id="多行语句"><a href="#多行语句" class="headerlink" title="多行语句"></a>多行语句</h4><p>当我们遇到语句过长的情况时，可以使用反斜杠来实现多行语句</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">number = <span class="selector-tag">a</span> + \</span><br><span class="line"> <span class="selector-tag">b</span> + \</span><br><span class="line"> c</span><br></pre></td></tr></table></figure><p>当然，如果语句包含在[],{}或()时，不需要使用反斜杠</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">number</span> = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span></span><br><span class="line">  <span class="string">'d'</span>]</span><br></pre></td></tr></table></figure><h4 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h4><p>python中数字由四种类型：整数，长整数，浮点数和复数</p><ul><li>整数，如 1</li><li>长整数 是比较大的整数</li><li>浮点数 如 1.23，3E-2</li><li>复数 如 1 + 2j, 1.1 + 2.2j</li></ul><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><ul><li>python中单引号和双引号使用完全相同。</li><li>使用三引号(‘’’或”””)可以指定一个多行字符串。</li><li>转义符 ‘\’</li><li>反斜杠可以用来转义，使用r可以让反斜杠不发生转义。。 如 r”this is a line with \n” 则\n会显示，并不是换行。</li><li>按字面意义级联字符串，如”this “ “is “ “string”会被自动转换为this is string。</li><li>字符串可以用 + 运算符连接在一起，用 * 运算符重复。</li><li>Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。</li><li>Python中的字符串不能改变。</li><li>Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。</li><li>字符串的截取的语法格式如下：变量[头下标:尾下标]</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">word</span> = <span class="string">'词'</span></span><br><span class="line"><span class="attr">sentence</span> = <span class="string">"句"</span></span><br><span class="line"><span class="attr">paragraph</span> = <span class="string">"""段，</span></span><br><span class="line"><span class="string">可以由多行组成"""</span></span><br></pre></td></tr></table></figure><p>Example:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="comment"># __author__ = 'Vi-Young'</span></span><br><span class="line"></span><br><span class="line">str = <span class="string">'Vi_Young'</span></span><br><span class="line"></span><br><span class="line">print(str)  <span class="comment"># 输出字符串</span></span><br><span class="line">print(str[<span class="number">0</span>:<span class="number">-1</span>])  <span class="comment"># 输出第一个到倒数第二个的所有字符</span></span><br><span class="line">print(str[<span class="number">0</span>])  <span class="comment"># 输出字符串第一个字符</span></span><br><span class="line">print(str[<span class="number">2</span>:<span class="number">5</span>])  <span class="comment"># 输出从第三个开始到第五个的字符</span></span><br><span class="line">print(str[<span class="number">2</span>:])  <span class="comment"># 输出从第三个开始的后的所有字符</span></span><br><span class="line">print(str * <span class="number">2</span>)  <span class="comment"># 输出字符串两次</span></span><br><span class="line">print(str + <span class="string">'你好'</span>)  <span class="comment"># 连接字符串</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'------------------------------'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'hello\nrunoob'</span>)  <span class="comment"># 使用反斜杠(\)+n转义特殊字符</span></span><br><span class="line">print(<span class="string">r'hello\nrunoob'</span>)  <span class="comment"># 在字符串前面添加一个 r，表示原始字符串，不会发生转义</span></span><br></pre></td></tr></table></figure><p>输出：<br><img src="https://i.imgur.com/LE9LpaA.png" alt=""></p><h4 id="同一行显示多条语句"><a href="#同一行显示多条语句" class="headerlink" title="同一行显示多条语句"></a>同一行显示多条语句</h4><p>如果想要在同一行中使用多条语句，可以使用分号将语句间隔开。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"></span><br><span class="line">import sys; x = <span class="string">'vi_young'</span>; sys.<span class="keyword">stdout</span>.<span class="built_in">write</span>(x + <span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure><p>输出：<br><img src="https://i.imgur.com/oQUeJhq.png" alt=""></p><h4 id="多个语句构成代码组"><a href="#多个语句构成代码组" class="headerlink" title="多个语句构成代码组"></a>多个语句构成代码组</h4><p>缩进相同的一组语句构成一个代码块，我们称之为代码组。一般体现在控制流程的语句中。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">boolean</span>:</span><br><span class="line">todo</span><br><span class="line">elif <span class="built_in">boolean</span>:</span><br><span class="line">todo</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">todo</span><br></pre></td></tr></table></figure><h4 id="import与from…import"><a href="#import与from…import" class="headerlink" title="import与from…import"></a>import与from…import</h4><ul><li><p>在 python 用 import 或者 from…import 来导入相应的模块。</p></li><li><p>将整个模块(somemodule)导入，格式为： import somemodule</p></li><li><p>从某个模块中导入某个函数,格式为： from somemodule import somefunction</p></li><li><p>从某个模块中导入多个函数,格式为： from somemodule import firstfunc, secondfunc, thirdfunc</p></li><li><p>将某个模块中的全部函数导入，格式为： from somemodule import *</p></li></ul><p>导入sys<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'================Python import mode=========================='</span>);</span><br><span class="line"><span class="built_in">print</span> (<span class="string">'命令行参数为:'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sys.argv:</span><br><span class="line">    <span class="built_in">print</span> (i)</span><br><span class="line"><span class="built_in">print</span> (<span class="string">'\n python 路径为'</span>,sys.path)</span><br></pre></td></tr></table></figure></p><p>导入sys模块的argv,path成员</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> argv,path  <span class="comment">#  导入特定的成员</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>(<span class="string">'================python from import==================================='</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'path:'</span>,path) <span class="comment"># 因为已经导入path成员，所以此处引用时不需要加sys.path</span></span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="http://www.runoob.com/python3/python3-basic-syntax.html" target="_blank" rel="noopener">Python3 基础语法|菜鸟教程</a></p><p><a href="https://www.w3cschool.cn/python3/python3-basic-syntax.html" target="_blank" rel="noopener">Python3 基础语法|W3Cschool</a></p><h4 id="下节预告"><a href="#下节预告" class="headerlink" title="下节预告"></a>下节预告</h4><p>基本数据类型~</p><hr><h4 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h4><p>扫码或微信搜索Vi的技术博客，关注公众号，不定期送书活动各种福利~</p><p><img src="https://i.imgur.com/jK9vpVj.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;编码&quot;&gt;&lt;a href=&quot;#编码&quot; class=&quot;headerlink&quot; title=&quot;编码&quot;&gt;&lt;/a&gt;编码&lt;/h4&gt;&lt;p&gt;Python 3 源码文件在默认情况下以UTF-8编码，所有的字符串都是unicode字符串，当然，如果加上&lt;code&gt;# coding=u
      
    
    </summary>
    
      <category term="Python" scheme="http://vi-young.com/categories/Python/"/>
    
    
      <category term="Python3" scheme="http://vi-young.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 2.0 系列（四）：开发者工具</title>
    <link href="http://vi-young.com/2018/06/27/Spring-Boot-2-0-%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/"/>
    <id>http://vi-young.com/2018/06/27/Spring-Boot-2-0-系列（四）：开发者工具/</id>
    <published>2018-06-26T17:04:00.000Z</published>
    <updated>2018-06-26T09:05:52.665Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>Spring Boot包括一组额外的工具，这些工具可以使应用程序开发体验变得更加愉快。<code>spring-boot-devtools</code>模块可以包含在任何项目中，以提供额外的开发时特性。如果要想支持devtools，要将模块依赖项添加到构建中，如以下Maven和Gradle清单所示:</p><p><strong>Maven</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p><strong>Gradle</strong></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line"><span class="keyword">compile</span>(<span class="string">"org.springframework.boot:spring-boot-devtools"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在运行完全打包的应用程序时，会自动禁用开发人员工具。如果您的应用程序是从<code>java -jar</code>启动的，或者是从一个特殊的类加载器开始的，那么它就被认为是一个“生产应用程序”。将Maven中的依赖项的<code>optional</code>设置为true或使用<code>compileOnly</code>在Gradle中，这样可以防止devtools被传递到其他使用的项目的模块中。</p><p>重新打包的archives默认不包含devtools。如果我们想使用某个远程devtools功能，我们需要禁用<code>excludeDevtools</code> 的build属性以包含它。Maven和Gradle插件都支持这个属性。</p><h4 id="属性默认值"><a href="#属性默认值" class="headerlink" title="属性默认值"></a>属性默认值</h4><p>Spring Boot支持的几个库使用缓存来提高性能。例如，模板引擎缓存已编译的模板，以避免重复解析模板文件。此外，Spring MVC可以在服务静态资源时向响应添加HTTP缓存头。</p><p>虽然缓存在生产中非常有用，但在开发过程中它可能会产生反作用，防止我们看到我们在应用程序中所做的更改。出于这个原因，spring-boot-devtools默认禁用缓存选项。</p><p>缓存选项通常由<code>application.properties</code> 文件配置。例如，Thymeleaf提供了<code>spring.thymeleaf.cache</code>属性。<code>spring-boot-devtools</code>模块不需要手动设置这些属性，而是自动应用合理的开发时配置。</p><p>有关devtools应用的属性的完整列表（默认配置）：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order</span>(Ordered.LOWEST_PRECEDENCE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DevToolsPropertyDefaultsPostProcessor</span> <span class="keyword">implements</span> <span class="title">EnvironmentPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Object&gt; PROPERTIES;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">Map&lt;String, Object&gt; devToolsProperties = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">devToolsProperties.put(<span class="string">"spring.thymeleaf.cache"</span>, <span class="string">"false"</span>);</span><br><span class="line">devToolsProperties.put(<span class="string">"spring.freemarker.cache"</span>, <span class="string">"false"</span>);</span><br><span class="line">devToolsProperties.put(<span class="string">"spring.groovy.template.cache"</span>, <span class="string">"false"</span>);</span><br><span class="line">devToolsProperties.put(<span class="string">"spring.mustache.cache"</span>, <span class="string">"false"</span>);</span><br><span class="line">devToolsProperties.put(<span class="string">"server.servlet.session.persistent"</span>, <span class="string">"true"</span>);</span><br><span class="line">devToolsProperties.put(<span class="string">"spring.h2.console.enabled"</span>, <span class="string">"true"</span>);</span><br><span class="line">devToolsProperties.put(<span class="string">"spring.resources.cache.period"</span>, <span class="string">"0"</span>);</span><br><span class="line">devToolsProperties.put(<span class="string">"spring.resources.chain.cache"</span>, <span class="string">"false"</span>);</span><br><span class="line">devToolsProperties.put(<span class="string">"spring.template.provider.cache"</span>, <span class="string">"false"</span>);</span><br><span class="line">devToolsProperties.put(<span class="string">"spring.mvc.log-resolved-exception"</span>, <span class="string">"true"</span>);</span><br><span class="line">devToolsProperties.put(<span class="string">"server.servlet.jsp.init-parameters.development"</span>, <span class="string">"true"</span>);</span><br><span class="line">devToolsProperties.put(<span class="string">"spring.reactor.stacktrace-mode.enabled"</span>, <span class="string">"true"</span>);</span><br><span class="line">PROPERTIES = Collections.unmodifiableMap(devToolsProperties);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> postProcessEnvironment(ConfigurableEnvironment environment,</span><br><span class="line">SpringApplication application) &#123;</span><br><span class="line"><span class="keyword">if</span> (isLocalApplication(environment) &amp;&amp; canAddProperties(environment)) &#123;</span><br><span class="line">PropertySource&lt;?&gt; propertySource = <span class="keyword">new</span> MapPropertySource(<span class="string">"refresh"</span>,</span><br><span class="line">PROPERTIES);</span><br><span class="line">environment.getPropertySources().addLast(propertySource);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isLocalApplication</span><span class="params">(ConfigurableEnvironment environment)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> environment.getPropertySources().get(<span class="string">"remoteUrl"</span>) == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">boolean</span> <span class="title">canAddProperties</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> isRestarterInitialized() || isRemoteRestartEnabled(environment);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isRestarterInitialized</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Restarter restarter = Restarter.getInstance();</span><br><span class="line"><span class="keyword">return</span> (restarter != <span class="keyword">null</span> &amp;&amp; restarter.getInitialUrls() != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isRemoteRestartEnabled</span><span class="params">(Environment environment)</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">return</span> environment.<span class="title">containsProperty</span><span class="params">(<span class="string">"spring.devtools.remote.secret"</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自动重启"><a href="#自动重启" class="headerlink" title="自动重启"></a>自动重启</h4><p>使用<code>spring-boot-devtools</code>的应用程序在类路径上的文件发生更改时自动重新启动。在IDE中工作时，这可能是一个有用的特性，因为它为代码更改提供了一个非常快速的反馈循环。默认情况下，指向文件夹的类路径中的任何条目都将受到监视，以查看是否有更改。注意，某些资源(如静态资源和视图模板)不需要重新启动应用程序。</p><p>由于DevTools监控类路径资源，触发重新启动的惟一方法是更新类路径。使类路径更新的方式取决于您使用的IDE。在Eclipse中，保存修改后的文件会更新类路径并触发重新启动。在IntelliJ IDEA中，构建项目(Build -&gt; Build project)也有着同样的效果。</p><p>只要启用了fork，您还可以通过使用受支持的构建插件(Maven和Gradle)启动应用程序，因为DevTools需要一个独立的应用程序类加载程序来正常运行。默认情况下，Gradle和Maven在类路径上检测DevTools时是这样做的。</p><p>自动重新启动在使用<code>LiveReload</code>时非常有效。如果您使用JRebel，自动重启被禁用，以支持动态类重载。其他devtools特性(如LiveReload和property overrides)仍然可以使用。</p><p>DevTools依赖于应用程序上下文的shutdown hook在重新启动时关闭它。如果禁用了shutdown hook(SpringApplication.setRegisterShutdownHook(false))，那么它就不能正常工作。</p><p>当决定类路径上的条目是否应该在更改时触发重新启动时，DevTools会自动忽略名为<code>spring-boot</code>、<code>spring-boot-devtools</code> 、<code>spring-boot-autoconfigure</code>、<code>spring-boot-actuator</code>和<code>spring-boot-starter</code>的项目。</p><p>DevTools需要自定义<code>ApplicationContext</code>使用的<code>ResourceLoader</code>。如果您的应用程序已经提供了一个，那么它将被包装。不支持在<code>ApplicationContext</code>上直接覆盖<code>getResource</code>方法。</p><font color="red"> <strong>热加载和热部署</strong> </font><p>Spring Boot提供的热部署技术使用两个类加载器。不改变的类(例如，来自第三方jar的类)被加载到一个基类加载器中。正在积极开发的类被加载到restart classloader中。当重新启动应用程序时，会丢弃restart classloader，并创建一个新的。这种方法意味着应用程序重新启动通常比“冷启动”快得多，因为基类加载程序已经可用并填充。</p><p>如果发现热部署对应用程序来说不够快，或者遇到了类加载问题，可以考虑热加载技术，如零周转期的JRebel。这些工作通过重写类，使它们更适合热加载。</p><blockquote><p>PS：后面会出一期单章说明热加载和热部署的区别，以及在IntelliJ IDEA中的使用方式。</p></blockquote><h5 id="日志记录变化"><a href="#日志记录变化" class="headerlink" title="日志记录变化"></a>日志记录变化</h5><p>默认情况下，每次应用程序重新启动时，都会记录显示变化的报告。报告显示了应用程序自动配置的更改，如添加或删除bean和设置配置属性。</p><p>要禁用报告的日志记录，设置以下属性:</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.devtools.<span class="built_in">restart</span>.<span class="built_in">log</span>-condition-evaluation-<span class="built_in">delta</span>=<span class="literal">false</span></span><br></pre></td></tr></table></figure><h5 id="不包括的资源"><a href="#不包括的资源" class="headerlink" title="不包括的资源"></a>不包括的资源</h5><p>某些资源在更改时不一定需要触发重新启动。例如，可以就地编辑Thymeleaf模板。默认情况下，在/<code>META-INF/maven</code>、<code>/META-INF/resources</code>、<code>/resources</code>、<code>/static</code>、<code>/public</code>或<code>/template</code>中更改资源不会触发重新启动，但会触发实时重新加载。如果想自定义把这些排除，可以使用spring.devtools.restart.exclude属性。例如，仅排除/静态和/public，我们可以设置以下属性:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring<span class="selector-class">.devtools</span><span class="selector-class">.restart</span><span class="selector-class">.exclude</span>=static<span class="comment">/**,public/**</span></span><br></pre></td></tr></table></figure><p>如果您想保留这些默认值并添加额外的排除，可以使用<code>spring.devtools.restart.additional- rejection</code>属性。</p><h5 id="监听更多的路径"><a href="#监听更多的路径" class="headerlink" title="监听更多的路径"></a>监听更多的路径</h5><p>当我们对不在类路径上的文件进行更改时，我们可能希望应用程序重新启动或重新加载。为此，使用<code>spring.devtools.restart.additional-paths</code>属性配置其他路径以监视更改。我们可以使用前面描述的<code>spring.devtools.restart.exclude</code>属性来控制附加路径下的更改是触发完全重新启动还是实时重新加载。</p><h5 id="禁用重启"><a href="#禁用重启" class="headerlink" title="禁用重启"></a>禁用重启</h5><p>如果不想使用重启功能，可以使用<code>spring.devtools.restart.enabled</code>属性禁用它。在大多数情况下，我们可以在<code>application.properties</code>设置此属性(这样做仍然初始化重启类加载器，但它不注意文件的更改)。<br>如果需要完全禁用重新启动支持(例如，因为它不能使用特定的库)，您需要在调用<code>SpringApplication.run(…)</code>之前将<code>spring.devtools.restart.enabled</code> <code>System</code>属性设置为false，如下面的示例所示:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">System.setProperty(<span class="string">"spring.devtools.restart.enabled"</span>, <span class="string">"false"</span>);</span><br><span class="line">SpringApplication.<span class="built_in">run</span>(MyApp.class, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用触发器"><a href="#使用触发器" class="headerlink" title="使用触发器"></a>使用触发器</h5><p>如果我们使用的IDE不断地编译已更改的文件，但是我们可能更希望只在特定的时间触发重新启动。为此，我们可以使用“trigger file”，这是一个特殊的文件，当我们希望实际触发重新启动检查时，必须对其进行修改。修改文件只会触发检查，只有在Devtools检测到它必须做一些事情时才会重新启动。触发器文件可以手动更新或使用IDE插件更新。</p><p>要使用触发器文件，请将<code>spring.devtools.restart.trigger-file</code>属性设置为触发器文件的路径。</p><h5 id="自定义类加载器重启"><a href="#自定义类加载器重启" class="headerlink" title="自定义类加载器重启"></a>自定义类加载器重启</h5><p>如前所述，在Restart vs Reload部分中，使用两个classloaders实现了Restart功能。对于大多数应用程序来说，这种方法运行良好。但是，它有时会导致类加载问题。<br>默认情况下，IDE中的任何打开的项目都装载“重启”类加载器，任何常规的.jar文件都装载“基”类加载器。如果您正在处理一个多模块项目，并且不是每个模块都被导入到您的IDE中，那么您可能需要自定义一些东西。为此，您可以创建一个<code>META-INF/spring-devtools.properties</code>文件。</p><p><code>spring-devtools.properties</code>文件可以包含以<code>restart.exclude</code>和<code>restart.include</code>为前缀的属性。include元素是应该被拉到“重启”类加载器中的项，而exclude元素则是应该被推入“基”类加载器的项。属性的值是应用于类路径的regex模式，如下面的示例所示:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">restart<span class="selector-class">.exclude</span><span class="selector-class">.companycommonlibs</span>=/mycorp-common-[\\w-]+\.jar</span><br><span class="line">restart<span class="selector-class">.include</span><span class="selector-class">.projectcommon</span>=/mycorp-myproj-[\\w-]+\.jar</span><br></pre></td></tr></table></figure><p>所有属性键必须是唯一的。它被认为是只要一个属性从<code>restart.include</code>或<code>restart.exclude</code>开始。</p><p>所有META-INF/spring-devtools.properties加载自类路径。我们可以在项目内部或项目所使用的库中打包文件。</p><h5 id="已知限制"><a href="#已知限制" class="headerlink" title="已知限制"></a>已知限制</h5><p>通过使用标准的<code>ObjectInputStream</code>反序列化的对象，重新启动功能不能很好地工作。如果需要反序列化数据，可能需要结合使用Spring的<code>ConfigurableObjectInputStream</code>和<code>Thread.currentThread().getcontextclassloader()</code>。<br>不幸的是，一些第三方库在不考虑上下文类加载器的情况下反序列化。如果发现这样的问题，我们需要向原始作者请求修复。</p><h4 id="LiveReload"><a href="#LiveReload" class="headerlink" title="LiveReload"></a>LiveReload</h4><p>spring-boot-devtools模块包含一个嵌入式LiveReload服务器，当资源发生更改时，该服务器可用于触发浏览器刷新。LiveReload可以从livereload.com免费获得Chrome、Firefox和Safari浏览器扩展。</p><p>如果不希望在应用程序运行时启动LiveReload服务器，可以将<code>spring.devtools.livereload.enabled</code>属性设置为false。</p><p>一次只能运行一个LiveReload服务器。在启动应用程序之前，请确保没有其他LiveReload服务器正在运行。如果我们从IDE启动多个应用程序，只有第一个具有LiveReload支持。</p><h4 id="全局设置"><a href="#全局设置" class="headerlink" title="全局设置"></a>全局设置</h4><p>您可以通过添加名为.spring-boot-devtools.properties的文件来配置全局devtools设置到$HOME文件夹(注意文件名以“.”开头)。任何添加到这个文件的属性都适用于使用devtools的计算机上的所有Spring Boot应用程序。例如，要配置restart始终使用触发器文件，需要添加以下属性:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~/<span class="selector-class">.spring-boot-devtools</span><span class="selector-class">.properties</span>. </span><br><span class="line"></span><br><span class="line">spring<span class="selector-class">.devtools</span><span class="selector-class">.reload</span><span class="selector-class">.trigger-file</span>=.reloadtrigger</span><br></pre></td></tr></table></figure><h4 id="远程应用"><a href="#远程应用" class="headerlink" title="远程应用"></a>远程应用</h4><p>Spring Boot developer工具不仅限于本地开发。在远程运行应用程序时，还可以使用几个特性。远程支持是可选的。要启用它，需要确保<code>devtools</code>包含在重新打包的归档文件中，如下所示:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">excludeDevtools</span>&gt;</span>false<span class="tag">&lt;/<span class="name">excludeDevtools</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后需要设置一个spring.devtools.remote.secret属性，如下面的示例所示:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring<span class="selector-class">.devtools</span><span class="selector-class">.remote</span><span class="selector-class">.secret</span>=mysecret</span><br></pre></td></tr></table></figure><p>在远程应用程序上启用spring-boot-devtools存在安全风险。我们不应该在生产部署中启用支持。</p><p>远程devtools支持分为两部分:接受连接的服务器端端点和在IDE中运行的客户端应用程序。在设置好<code>spring.devtools.remote.secret</code>属性后，服务器组件将自动启用。必须手动启动客户端组件。</p><h5 id="运行远程客户端应用程序"><a href="#运行远程客户端应用程序" class="headerlink" title="运行远程客户端应用程序"></a>运行远程客户端应用程序</h5><p>远程客户端应用程序设计为在IDE中运行。我们需要运行<code>org.springframe.boot.devtools.Remotespringapplication</code>，其类路径与连接到的远程项目相同。应用程序的唯一必需参数是它连接的远程URL。</p><p>例如，如果我们正在使用Eclipse或STS，并且我们已经将一个名为<code>my-app</code>的项目部署到Cloud Foundry，那么您将执行以下操作:</p><ul><li>从Run菜单中选择”Run Configuration…”。</li><li>创建一个新的Java应用程序“launch configuration”。</li><li>浏览my-app项目。</li><li>使用<code>org.springframe.boot.devtools.remotespringapplication</code>作为主类。</li><li>添加<code>https://myapp.cfapps.io</code>到程序参数(或任何远程URL)。</li></ul><p>正在运行的远程客户端可能类似以下清单:</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> .   ____          <span class="keyword">_</span>                                              __ <span class="keyword">_</span> <span class="keyword">_</span></span><br><span class="line"> /\\ / ___'<span class="keyword">_</span> __ <span class="keyword">_</span> <span class="keyword">_</span>(<span class="keyword">_</span>)<span class="keyword">_</span> __  __ <span class="keyword">_</span>          ___               <span class="keyword">_</span>      \ \ \ \</span><br><span class="line">( ( )\___ | <span class="type">'_</span> | <span class="type">'_</span>| <span class="type">| '_</span> \/ <span class="keyword">_</span>` |        <span class="type">| _</span> \___ <span class="keyword">_</span> __  ___| <span class="type">|_</span> ___ \ \ \ \</span><br><span class="line"> \\/  ___)| <span class="type">|_</span>)| <span class="type">| | | | || (_</span>| <span class="type">[]::::::[]   / -_</span>) '  \/ <span class="keyword">_</span> \  <span class="keyword">_</span>/ -<span class="keyword">_</span>) ) ) ) )</span><br><span class="line">  '  |<span class="type">____</span>| <span class="type">.__</span>|<span class="type">_</span>| <span class="type">|_</span>|<span class="type">_</span>| <span class="type">|_</span>\__, |        <span class="type">|_</span>|<span class="type">_</span>\___|<span class="type">_</span>|<span class="type">_</span>|<span class="type">_</span>\___/\__\___|<span class="type">/ / / /</span></span><br><span class="line"><span class="type"> =========|_</span>|<span class="type">==============|___</span>/===================================/<span class="keyword">_</span>/<span class="keyword">_</span>/<span class="keyword">_</span>/</span><br><span class="line"> :: Spring Boot Remote :: <span class="number">2.0</span><span class="number">.3</span>.RELEASE</span><br><span class="line"></span><br><span class="line"><span class="number">2015</span><span class="number">-06</span><span class="number">-10</span> <span class="number">18</span>:<span class="number">25</span>:<span class="number">06.632</span>  INFO <span class="number">14938</span> --- [           main] o.s.b.devtools.RemoteSpringApplication   : Starting RemoteSpringApplication on pwmbp <span class="built_in">with</span> PID <span class="number">14938</span> (/Users/pwebb/projects/spring-boot/code/spring-boot-devtools/target/classes started <span class="built_in">by</span> pwebb <span class="built_in">in</span> /Users/pwebb/projects/spring-boot/code/spring-boot-samples/spring-boot-sample-devtools)</span><br><span class="line"><span class="number">2015</span><span class="number">-06</span><span class="number">-10</span> <span class="number">18</span>:<span class="number">25</span>:<span class="number">06.671</span>  INFO <span class="number">14938</span> --- [           main] s.c.a.AnnotationConfigApplicationContext : Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@<span class="number">2</span>a17b7b6: startup date [Wed Jun <span class="number">10</span> <span class="number">18</span>:<span class="number">25</span>:<span class="number">06</span> PDT <span class="number">2015</span>]; root of context hierarchy</span><br><span class="line"><span class="number">2015</span><span class="number">-06</span><span class="number">-10</span> <span class="number">18</span>:<span class="number">25</span>:<span class="number">07.043</span>  WARN <span class="number">14938</span> --- [           main] o.s.b.d.r.c.RemoteClientConfiguration    : The connection to http://localhost:<span class="number">8080</span> is insecure. You should use a URL starting <span class="built_in">with</span> 'https://'.</span><br><span class="line"><span class="number">2015</span><span class="number">-06</span><span class="number">-10</span> <span class="number">18</span>:<span class="number">25</span>:<span class="number">07.074</span>  INFO <span class="number">14938</span> --- [           main] o.s.b.d.a.OptionalLiveReloadServer       : LiveReload server is running on port <span class="number">35729</span></span><br><span class="line"><span class="number">2015</span><span class="number">-06</span><span class="number">-10</span> <span class="number">18</span>:<span class="number">25</span>:<span class="number">07.130</span>  INFO <span class="number">14938</span> --- [           main] o.s.b.devtools.RemoteSpringApplication   : Started RemoteSpringApplication <span class="built_in">in</span> <span class="number">0.74</span> seconds (JVM running <span class="keyword">for</span> <span class="number">1.105</span>)</span><br></pre></td></tr></table></figure><p>因为远程客户端使用与实际应用程序相同的类路径，所以可以直接读取应用程序属性。这就是<code>spring.devtools.remote.secret</code>属性的读取方式，并将其传递给服务器进行身份验证。</p><p>通常建议使用https:// 作为连接协议，这样就可以加密通信，无法截获密码。</p><p>如果需要使用代理访问远程应用程序，请配置spring.devtools.remote.proxy.host和spring.devtools.remote.proxy.port属性。</p><h5 id="远程更新"><a href="#远程更新" class="headerlink" title="远程更新"></a>远程更新</h5><p>远程客户端以与本地重启相同的方式监视应用程序类路径的更改。将任何更新的资源推到远程应用程序，并(如果需要)触发重新启动。如果您对使用本地没有的云服务的特性进行迭代，这将非常有用。通常，远程更新和重新启动要比完整的重新构建和部署周期快得多。</p><p>只有在远程客户端运行时才对文件进行监视。如果在启动远程客户端之前更改文件，则不会将其推到远程服务器。</p><hr><h4 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h4><p>扫码或微信搜索Vi的技术博客，关注公众号，不定期送书活动各种福利~</p><p><img src="http://upload-images.jianshu.io/upload_images/10641481-961b717327e333ab.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;Spring Boot包括一组额外的工具，这些工具可以使应用程序开发体验变得更加愉快。&lt;code&gt;spring-boot-devtools&lt;
      
    
    </summary>
    
      <category term="Java" scheme="http://vi-young.com/categories/Java/"/>
    
    
      <category term="Spring Boot" scheme="http://vi-young.com/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Python3 系列（一）：HelloWorld</title>
    <link href="http://vi-young.com/2018/06/21/Python3-%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AHelloWorld/"/>
    <id>http://vi-young.com/2018/06/21/Python3-系列（一）：HelloWorld/</id>
    <published>2018-06-21T12:17:00.000Z</published>
    <updated>2018-06-27T08:06:21.849Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h4><p>本系列教程面向有一定编程基础的人，熟悉IDE的操作，有面向对象的基础更佳。</p><h4 id="简介"><a href="#简介" class="headerlink" title="简介:"></a>简介:</h4><p>Python是著名的“龟叔”Guido van Rossum在1989年圣诞节期间，为了打发无聊的圣诞节而编写的一个编程语言。龟叔给Python的定位是“优雅”、“明确”、“简单”，所以Python程序看上去总是简单易懂，初学者学Python，不但入门容易，而且将来深入下去，可以编写那些非常非常复杂的程序。总的来说，Python的哲学就是极简既极美。</p><h4 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h4><ul><li>网络应用（网站，后台服务）</li><li>小工具（爬虫）</li></ul><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol><li>运行速度非常慢，因为Python是解释型语言，就是你的代码在运行的时候会一行一行的翻译成机器码，与C相比，这个效率要慢许多。（不过无伤大雅，用户基本无感）</li><li>代码不能加密，发布你的Python的程序的时候，实际上就是在公布你的源码。</li></ol><h4 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h4><ol><li><p><a href="https://www.python.org/ftp/python/3.6.5/python-3.6.5-amd64.exe" target="_blank" rel="noopener">下载地址</a></p></li><li><p>下载完成之后，双击打开，这里需要注意一点：<br><img src="https://upload-images.jianshu.io/upload_images/10641481-52a2698f63288e70.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="勾选环境变量.jpg"></p></li></ol><ol start="3"><li>打开命令行窗口，输入python，结果如下所示：<br><img src="https://upload-images.jianshu.io/upload_images/10641481-4874d7c1e7dbbfa5.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="cmd截图.jpg"></li></ol><h4 id="Pycharm下编写第一个HelloWorld"><a href="#Pycharm下编写第一个HelloWorld" class="headerlink" title="Pycharm下编写第一个HelloWorld"></a>Pycharm下编写第一个HelloWorld</h4><ol><li><a href="https://www.jetbrains.com/zh/pycharm/specials/pycharm/pycharm.html?utm_source=baidu&amp;utm_medium=cpc&amp;utm_campaign=cn-bai-br-pycharm-ex-pc&amp;utm_content=pycharm-pure&amp;utm_term=pycharm&amp;gclid=CJDwxpXl49sCFUGWvAodN40Nfg&amp;gclsrc=ds&amp;dclid=CL3Sz5Xl49sCFcQYKgodnkILhg" target="_blank" rel="noopener">Pycharm下载</a></li></ol><ol start="2"><li><p>破解</p><ol><li><p>修改hosts文件</p><p> 将 0.0.0.0 account.jetbrains.com 添加到hosts文件最后，注意hosts文件无后缀，如果遇到无法修改或权限问题，可以采用覆盖的方法去替换hosts文件<br> 修改后请检查hosts文件是否修改，激活码无法激活的原因99.99%是因为hosts没有修改正确<br> Windows系统hosts文件路径为：c:\windows\system32\drivers\etc</p><p> <img src="https://upload-images.jianshu.io/upload_images/10641481-e729259a9b4aab3d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Pycharm破解host文件.jpg"></p></li><li><p>复制激活码</p><p>打开PyCharm选择Activation code激活，然后复制下面的激活码点击激活。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EB101IWSWD-eyJsaWNlbnNlSWQiOiJFQjEwMUlXU1dEIiwibGljZW5zZWVOYW1lIjoibGFuIHl1IiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IkZvciBlZHVjYXRpb25hbCB1c2Ugb25seSIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiSUkiLCJwYWlkVXBUbyI6IjIwMTgtMTAtMTQifSx7ImNvZGUiOiJSUzAiLCJwYWlkVXBUbyI6IjIwMTgtMTAtMTQifSx7ImNvZGUiOiJXUyIsInBhaWRVcFRvIjoiMjAxOC0xMC0xNCJ9LHsiY29kZSI6IlJEIiwicGFpZFVwVG8iOiIyMDE4LTEwLTE0In0seyJjb2RlIjoiUkMiLCJwYWlkVXBUbyI6IjIwMTgtMTAtMTQifSx7ImNvZGUiOiJEQyIsInBhaWRVcFRvIjoiMjAxOC0xMC0xNCJ9LHsiY29kZSI6IkRCIiwicGFpZFVwVG8iOiIyMDE4LTEwLTE0In0seyJjb2RlIjoiUk0iLCJwYWlkVXBUbyI6IjIwMTgtMTAtMTQifSx7ImNvZGUiOiJETSIsInBhaWRVcFRvIjoiMjAxOC0xMC0xNCJ9LHsiY29kZSI6IkFDIiwicGFpZFVwVG8iOiIyMDE4LTEwLTE0In0seyJjb2RlIjoiRFBOIiwicGFpZFVwVG8iOiIyMDE4LTEwLTE0In0seyJjb2RlIjoiUFMiLCJwYWlkVXBUbyI6IjIwMTgtMTAtMTQifSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjAxOC0xMC0xNCJ9LHsiY29kZSI6IlBDIiwicGFpZFVwVG8iOiIyMDE4LTEwLTE0In0seyJjb2RlIjoiUlNVIiwicGFpZFVwVG8iOiIyMDE4LTEwLTE0In1dLCJoYXNoIjoiNjk0NDAzMi8wIiwiZ3JhY2VQZXJpb2REYXlzIjowLCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-Gbb7jeR8JWOVxdUFaXfJzVU<span class="regexp">/O7c7xHQyaidCnhYLp7v32zdeXiHUU7vlrrm5y9ZX0lmQk3plCCsW+phrC9gGAPd6WDKhkal10qVNg0larCR2tQ3u8jfv1t2JAvWrMOJfFG9kKsJuw1P4TozZ/</span>E7Qvj1cupf<span class="regexp">/rldhoOmaXMyABxNN1af1RV3bVhe4FFZe0p7xlIJF/</span>ctZkFK62HYmh8V3AyhUNTzrvK2k+t<span class="regexp">/tlDJz2LnW7nYttBLHld8LabPlEEjpTHswhzlthzhVqALIgvF0uNbIJ5Uwpb7NqR4U/</span><span class="number">2</span>ob0Z+FIcRpFUIAHEAw+RLGwkCge5DyZKfx+RoRJ<span class="regexp">/In4q/</span>UpA==-MIIEPjCCAiagAwIBAgIBBTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE1MTEwMjA4MjE0OFoXDTE4MTEwMTA4MjE0OFowETEPMA0GA1UEAwwGcHJvZDN5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO<span class="regexp">/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/</span><span class="number">78</span>TmVqFl8nOeD5+<span class="number">07</span>B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB<span class="regexp">/xVy/</span>VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE<span class="regexp">/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/</span>GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQC9WZuYgQedSuOc5TOUSrRigMw4<span class="regexp">/+wuC5EtZBfvdl4HT/</span><span class="number">8</span>vzMW<span class="regexp">/oUlIP4YCvA0XKyBaCJ2iX+ZCDKoPfiYXiaSiH+HxAPV6J79vvouxKrWg2XV6ShFtPLP+0gPdGq3x9R3+kJbmAm8w+FOdlWqAfJrLvpzMGNeDU14YGXiZ9bVzmIQbwrBA+c/</span>F4tlK<span class="regexp">/DV07dsNExihqFoibnqDiVNTGombaU2dDup2gwKdL81ua8EIcGNExHe82kjF4zwfadHk3bQVvbfdAwxcDy4xBjs3L4raPLU3yenSzr/</span>OEur1+jfOxnQSmEcMXKXgrAQ9U55gwjcOFKrgOxEdek<span class="regexp">/Sk1VfOjvS+nuM4eyEruFMfaZHzoQiuw4IqgGc45ohFH0UUyjYcuFxxDSU9lMCv8qdHKm+wnPRb0l9l5vXsCBDuhAGYD6ss+Ga+aDY6f/</span>qXZuUCEUOH3QUNbbCUlviSz6+GiRnt1kA9N2Qachl+<span class="number">2</span>yBfaqUqr8h7Z2gsx5LcIf5kYNsqJ0GavXTVyWh7PYiKX4bs354ZQLUwwa<span class="regexp">/cG++2+wNWP+HtBhVxMRNTdVhSm38AknZlD+PTAsWGu9GyLmhti2EnVwGybSD2Dxmhxk3IPCkhKAK+pl0eWYGZWG3tJ9mZ7SowcXLWDFAk0lRJnKGFMTggrWjV8GYpw5bq23VmIqqDLgkNzuoog==</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>开始编写</p><p> 打开Pycharm，点击 Create new project</p><p> 新建一个HelloWorld的项目</p><p> <img src="https://upload-images.jianshu.io/upload_images/10641481-214f3b4ebab1f217.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="新建项目.jpg"></p><p> 目录结构如下（关于venv虚拟环境会在后面单独讲解）</p><p> <img src="https://upload-images.jianshu.io/upload_images/10641481-2c793f8c45726b34.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="目录结构.png"></p><p>  新建文件</p><p> <img src="https://upload-images.jianshu.io/upload_images/10641481-a8a6c5a1811fa930.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="新建文件.png"></p><p> 文件内容</p><p> <img src="https://upload-images.jianshu.io/upload_images/10641481-a52d8756f6497dfe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="文件内容.png"></p><p>  启动项目，展示成果</p><p> <img src="https://upload-images.jianshu.io/upload_images/10641481-33e41a992aaaf0e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HelloWorld.png"></p></li></ol><p>HelloWorld至此就大功告成了~</p><h4 id="下节预告"><a href="#下节预告" class="headerlink" title="下节预告:"></a>下节预告:</h4><p>下节我们来一起学习Python的基础语法~</p><hr><h4 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h4><p>扫码或微信搜索Vi的技术博客，关注公众号，不定期送书活动各种福利~</p><p><img src="https://upload-images.jianshu.io/upload_images/10641481-afbc61fbfe00fb8c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h4&gt;&lt;p&gt;本系列教程面向有一定编程基础的人，熟悉IDE的操作，有面向对象的基础更佳。&lt;/p&gt;
&lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介
      
    
    </summary>
    
      <category term="Python" scheme="http://vi-young.com/categories/Python/"/>
    
    
      <category term="Python3" scheme="http://vi-young.com/tags/Python3/"/>
    
  </entry>
  
  <entry>
    <title>Java基础专题（三）：字符串</title>
    <link href="http://vi-young.com/2018/06/18/Java%E5%9F%BA%E7%A1%80%E4%B8%93%E9%A2%98%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://vi-young.com/2018/06/18/Java基础专题（三）：字符串/</id>
    <published>2018-06-18T15:47:55.000Z</published>
    <updated>2018-06-18T07:48:59.941Z</updated>
    
    <content type="html"><![CDATA[<h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>从概念上来讲，Java字符串就是Unicode字符序列。例如，”Java\u2122” 由5个Unicode字符J，a，v，a，和 ™。Java没有内置的字符串类型，而是在标准Java类库中提供了一个预定义类，叫做String。每个用双引号括起来的字符串都是String类的一个实例。</p><h5 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h5><p>String类的substring方法可以从一个较大的字符串提取出一个子串。例如：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String </span>greeting = <span class="string">"Hello"</span></span><br><span class="line"><span class="keyword">String </span>s = greeting.<span class="keyword">substring(0,3) </span> // s = <span class="string">"Hel"</span></span><br></pre></td></tr></table></figure></p><p>substring方法的第二个参数是不想复制的第一个位置。这里要复制位置为0，1和2（从0到2，包括0和2）的字符。在substring中从0开始计数，直到3为止，但不包括3。<br>substring有一个优点：容易计算字串的长度。即substring（a,b）的长度为b-a。例如，子串“Hel”的长度为3-0=3</p><h5 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h5><p>与绝大多数的程序设计语言一样，Java语言允许使用 + 号连接（拼接）两个字符串。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> expletive = <span class="string">"Expletive"</span></span><br><span class="line"><span class="keyword">String</span> PG13 = <span class="string">"deleted"</span></span><br><span class="line"><span class="keyword">String</span> <span class="keyword">message</span> = expletive + PG13 // <span class="keyword">message</span> = <span class="string">"Expletivedeleted"</span></span><br></pre></td></tr></table></figure><p>当将一个字符串与一个非字符串的值进行拼接时，后者被转换成字符串。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> age = <span class="number">13</span>;</span><br><span class="line"><span class="keyword">String</span> rating = <span class="string">"PG"</span> + age; <span class="comment">//rating为 PG13</span></span><br></pre></td></tr></table></figure><p>如果需要将多个字符串连接在一起，并用定界符分离，可以使用静态join方法</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> <span class="built_in">size</span> = <span class="keyword">String</span>.<span class="built_in">join</span>(<span class="string">" / "</span>, <span class="string">"S"</span>, <span class="string">"M"</span>, <span class="string">"L"</span>, <span class="string">"XL"</span>);</span><br><span class="line">  <span class="comment">//size = "S / M / L / XL"</span></span><br></pre></td></tr></table></figure><h5 id="不可变字符串"><a href="#不可变字符串" class="headerlink" title="不可变字符串"></a>不可变字符串</h5><p>由于不能修改Java字符串中的字符，所以在Java文档中将String类对象称为不可变字符串，如同数字3永远是数字3一样，字符串“Hello”永远包含字符 H，e，l，l 和 o 的代码单元序列，而不能修改戏中的任何一个字符。当然，可以修改字符串变量，让它引用另一个字符串。</p><p>不可变字符串的优点是：编译器可以让字符串共享，即各种字符串存储在公共的存储池中，字符串变量值相存储池中相应的位置，如果复制一个字符串变量，原始字符串与复制的字符串共享相同的字符。</p><p>Java的设计者认为共享所带来的高效率远远胜于提取，拼接字符串所带来的低效率，因为我们很少需要修改字符串，更多的，我们是对字符串进行比较。</p><h5 id="检测字符串是否相等"><a href="#检测字符串是否相等" class="headerlink" title="检测字符串是否相等"></a>检测字符串是否相等</h5><p>可以使用equals方法判断两个字符串是否相等，对于表达式：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="keyword">equals</span>(t)</span><br></pre></td></tr></table></figure></p><p>如果字符串 s 与字符串 t 相等，则返回true；否则，返回false。需要注意，s和t可以是字符串变量，也可以是字符串字面量。如果要想检测两个字符串是否相等，而不区分大小写，可以使用equalsIgnoreCase方法。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Hello"</span><span class="string">.equalsIgnoreCase</span><span class="params">("hello")</span> <span class="string">//</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>一定不要使用==运算符检测两个字符串是否相等！！！</strong><br>这个运算符只能确定两个字符串是否放在同一个位置上，当然，如果字符串放置在同一个位置上，他们必然相等。但是，完全有可能将内容相同的多个字符串的拷贝放在不同的位置上。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String greeting = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">if</span> <span class="params">(<span class="attr">greeting</span> == "hello")</span>  <span class="string">//</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> <span class="params">(greeting.substring(0,3)</span> == <span class="string">"hel"</span>)  <span class="string">//</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>因为只有字符串常量是共享的，而 + 或substring产生的结果并不是共享的。所以千万不要用 == 运算符测试字符串的相等性！</p><h5 id="空串与null串"><a href="#空串与null串" class="headerlink" title="空串与null串"></a>空串与null串</h5><p>空串 “” 是长度为0的字符串。可以调用以下代码检查一个字符串是否为空：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (<span class="name">str</span>.length() == <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p><p>或<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (<span class="name">str</span>.equals(<span class="string">""</span>))</span><br></pre></td></tr></table></figure></p><p>空串是一个Java对象，有自己的串长度（0）和内容（空）。不过，String变量还可以存放一个特殊的值，名为null，这表示目前没有任何对象与该变量关联</p><h5 id="常用String-API"><a href="#常用String-API" class="headerlink" title="常用String API"></a>常用String API</h5><ul><li><p><strong>char charAt (int index)</strong><br>返回给定位置的代码单元。除非对底层的代码单元感兴趣，否则不需要调用这个方法。</p></li><li><p><strong>int compareTo(String other)</strong><br>按照字典顺序，如果字符串位于other之前，返回一个负数；如果字符串位于other之后，返回一个正数；如果两个字符串相等，返回0</p></li><li><p><strong>boolean equals(Object other)</strong><br>如果字符串与other相等，返回true</p></li><li><p><strong>boolean equalsIgnoreCase(String other)</strong><br>如果字符串与other相等（忽略大小写），返回true</p></li><li><p><strong>boolean startWith(String prefix)</strong></p></li><li><p><strong>boolean endWith(String suffix)</strong><br>如果字符串以prefix（suffix）开头（结尾），则返回true</p></li><li><p><strong>int indexOf(String str)</strong></p></li><li><p><strong>int indexOf(String str, int fromIndex)</strong></p></li><li><p><strong>int indexOf(int cp)</strong></p></li><li><p><strong>int indexOf(int cp, int fromIndex)</strong><br>返回与字符串str或代码点cp匹配的第一个子串的开始位置。这个位置从索引0或fromIndex开始计算。如果原始串中不存在str，返回-1</p></li><li><p><strong>int lastIndexOf(String str)</strong></p></li><li><p><strong>int lastIndexOf(String str, int fromIndex)</strong></p></li><li><p><strong>int lastIndexOf(int cp)</strong></p></li><li><p><strong>int lastIndexOf(int cp, int fromIndex)</strong><br>返回与字符串str或代码点cp匹配的最后一个子串的位置。这个位置从原始串尾端或fromIndex开始计算</p></li><li><p><strong>int length()</strong><br>返回字符串的长度</p></li><li><p><strong>String replace(CharSequence oldString, CharSequence newString)</strong><br>返回一个新字符串，这个字符串用newString代替原始字符串中的所有oldString。可以用String或StringBuilder对象作为CharSequence参数</p></li><li><p><strong>String substring(int beginIndex)</strong></p></li><li><p><strong>String substring(int beginIndex, int endIndex)</strong><br>返回一个新字符串。这个字符串包含原始字符串中从beginIndex到串尾或endIndex - 1的所有代码单元 </p></li><li><p><strong>String toLowerCase()</strong></p></li><li><p><strong>String toUpperCase()</strong><br>返回一个新字符串，这个字符串将原始字符串中的大写字母改为小写，或者将原始字符串中的所有小写字母改成了大写字母。</p></li><li><p><strong>String trim()</strong><br>返回一个新字符串，这个字符串将删除了原始字符串头部和尾部的空格。</p></li><li><p><strong>String join(CharSequence delimiter, CharSequence…elements)</strong><br>返回一个新字符串，用给定的定界符连接所有元素。</p></li></ul><h5 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h5><p>Core Java Volume Ⅰ-Fundamentals</p><h5 id="下期预告"><a href="#下期预告" class="headerlink" title="下期预告"></a>下期预告</h5><p>控制流程：块作用域，条件语句，循环，等等~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h5&gt;&lt;p&gt;从概念上来讲，Java字符串就是Unicode字符序列。例如，”Java\u2122” 由5个Unicode字符J，a，v，a，和 ™。Ja
      
    
    </summary>
    
      <category term="Java" scheme="http://vi-young.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://vi-young.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 2.0 系列（三）：流程详解（下）</title>
    <link href="http://vi-young.com/2018/06/11/Spring-Boot-2-0-%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://vi-young.com/2018/06/11/Spring-Boot-2-0-系列（三）：流程详解（下）/</id>
    <published>2018-06-11T06:49:16.000Z</published>
    <updated>2018-06-10T22:52:04.589Z</updated>
    
    <content type="html"><![CDATA[<h4 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h4><p>Spring Boot自动配置尝试根据添加的jar依赖项自动配置Spring应用程序。例如，如果<code>HSQLDB</code>在我们的类路径上，并且我们没有手动配置任何数据库连接bean，那么Spring Boot将自动配置内存中的数据库。<br>我们如果需要选择加入到自动配置可以通过将<code>@EnableAutoConfiguration</code>或<code>@SpringBootApplication</code>注释添加到我们的<code>@Configuration</code>类中。</p><blockquote><p>我们应该只添加一个<code>@SpringBootApplication</code>或<code>@EnableAutoConfiguration</code>注释。我们通常建议只将一个或另一个添加到 <code>@Configuration</code> 主类中。</p></blockquote><h5 id="自定义自动配置"><a href="#自定义自动配置" class="headerlink" title="自定义自动配置"></a>自定义自动配置</h5><p>自动配置具有良好的非侵入性。在任何时候，我们都可以开始定义自己的配置，以替换自动配置的特定部分。例如，如果我们添加自己的数据源bean，默认的嵌入式数据库支持就会退居幕后,而采用我们所配置的数据源bean。<br>如果我们需要了解当前正在应用的自动配置，以及为什么要使用这些配置，可以使用<code>--debug</code>开关启动应用程序。这样做可以为核心日志记录器的选择提供调试日志，并将条件报告记录到控制台。</p><h5 id="禁用特定类的自动配置"><a href="#禁用特定类的自动配置" class="headerlink" title="禁用特定类的自动配置"></a>禁用特定类的自动配置</h5><p>如果我们发现我们不希望的特定自动配置类被应用，我们可以使用<code>@EnableAutoConfiguration</code>的排除属性来禁用它们，如下面的示例所示:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">org</span><span class="selector-class">.springframework</span><span class="selector-class">.boot</span><span class="selector-class">.autoconfigure</span>.*;</span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">org</span><span class="selector-class">.springframework</span><span class="selector-class">.boot</span><span class="selector-class">.autoconfigure</span><span class="selector-class">.jdbc</span>.*;</span><br><span class="line"><span class="selector-tag">import</span> <span class="selector-tag">org</span><span class="selector-class">.springframework</span><span class="selector-class">.context</span><span class="selector-class">.annotation</span>.*;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">Configuration</span></span><br><span class="line">@<span class="keyword">EnableAutoConfiguration</span>(<span class="keyword">exclude</span>=&#123;<span class="selector-tag">DataSourceAutoConfiguration</span><span class="selector-class">.class</span>&#125;)</span><br><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">class</span> <span class="selector-tag">MyConfiguration</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果类不在类路径上，则可以使用注释的 <code>excludeName</code> 属性并指定完全限定的名称。最后，我们还可以通过使用<code>spring.autoconfigure.exclude</code>排除属性来控制自动配置类的列表。</p><blockquote><p>  我们可以在注释级别和通过使用属性定义排除。</p></blockquote><h4 id="Spring-bean和依赖项注入"><a href="#Spring-bean和依赖项注入" class="headerlink" title="Spring bean和依赖项注入"></a>Spring bean和依赖项注入</h4><p>我们可以自由地使用任何标准Spring框架技术来定义bean及其注入的依赖项。为了简单起见，我们经常发现使用@ComponentScan(查找bean)和使用@Autowired(进行构造函数注入)非常有效。<br>如果我们按照上面的建议构造代码(将应用程序类定位到根包中)，我们可以添加@ComponentScan，而不需要任何参数。所有应用程序组件(@Component， @Service， @Repository， @Controller等)都自动注册为Spring bean。<br>下面的示例显示了一个@Service Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseAccountService</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RiskAssessor riskAssessor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DatabaseAccountService</span><span class="params">(RiskAssessor riskAssessor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.riskAssessor = riskAssessor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个bean有一个构造函数，可以省略@Autowired，如下面的示例所示:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DatabaseAccountService</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> RiskAssessor riskAssessor;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DatabaseAccountService</span><span class="params">(RiskAssessor riskAssessor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.riskAssessor = riskAssessor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：如何使用构造函数注入让<code>riskAssessor</code>字段被标记为<code>final</code>，表明它不能随后更改。</p></blockquote><h4 id="使用-SpringBootApplication注解"><a href="#使用-SpringBootApplication注解" class="headerlink" title="使用@SpringBootApplication注解"></a>使用@SpringBootApplication注解</h4><p>许多Spring Boot开发人员喜欢他们的应用程序使用自动配置、组件扫描并能够在“application class”上定义额外的配置。可以使用一个<code>@SpringBootApplication</code>注释来启用这三个特性，即:<br><code>@EnableAutoConfiguration</code>:启用Spring Boot的自动配置机制<br><code>@ComponentScan</code>:在应用程序所在的包上启用@Component扫描<br><code>@Configuration</code>:允许在上下文中注册额外的bean或导入额外的配置类<br><code>@SpringBootApplication</code>注释相当于使用<code>@Configuration</code>、<code>@EnableAutoConfiguration</code>和<code>@ComponentScan</code>的默认属性，如下面的示例所示:</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><span class="meta-keyword">import</span> org.springframework.boot.SpringApplication;</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span></span><br><span class="line"></span><br><span class="line">@SpringBootApplication <span class="comment">// same as @Configuration @EnableAutoConfiguration @ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(Application.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>@SpringBootApplication</code>还提供别名来定制<code>@EnableAutoConfiguration</code>和<code>@ComponentScan</code>的属性。</p></blockquote><p>这些特性中没有一个是强制性的，我们可以选择使用它支持的任何特性来替换这个单一注释。例如，我们可能不想在应用程序中使用组件扫描:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Import;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@Import</span>(&#123; MyConfig.<span class="keyword">class</span>, MyAnotherConfig.<span class="keyword">class</span> &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(Application.<span class="keyword">class</span>, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在本例中，应用程序与任何其他Spring Boot应用程序一样，只是不会自动检测到<code>@component</code> - anno类，并且显式地导入用户定义的bean(根据<code>@Import</code>)。</p><h4 id="运行应用"><a href="#运行应用" class="headerlink" title="运行应用"></a>运行应用</h4><p>将应用程序打包为jar并使用嵌入式HTTP服务器的最大好处之一是，可以像运行其他应用程序一样运行应用程序。调试SpringBoot应用程序也很容易。我们不需要任何特殊的IDE插件或扩展。</p><blockquote><p>本节只讨论基于jar的打包。如果我们选择将应用程序打包为war文件，我们应该参考服务器和IDE文档。</p></blockquote><h5 id="通过IDE启动"><a href="#通过IDE启动" class="headerlink" title="通过IDE启动"></a>通过IDE启动</h5><p>我们可以将IDE中的SpringBoot应用程序作为一个简单的Java应用程序运行。但是，我们首先需要导入项目。导入步骤取决于我们的IDE和构建系统。大多数ide都可以直接导入Maven项目。<br>如果我们不能直接将项目导入IDE，那么我们可以使用build插件生成IDE元数据。Maven包含Eclipse和IDEA的插件。Gradle提供各种ide的插件。</p><blockquote><p>如果我们不小心运行了两次web应用程序，我们会看到一个“已经使用的端口”错误。STS用户可以使用<code>Relaunch</code>按钮而不是Run按钮来确保关闭任何现有实例。</p></blockquote><h5 id="作为打包的应用程序运行"><a href="#作为打包的应用程序运行" class="headerlink" title="作为打包的应用程序运行"></a>作为打包的应用程序运行</h5><p>如果我们使用Spring Boot Maven或Gradle插件来创建可执行jar，我们可以使用java -jar来运行应用程序，如下例所示:</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -jar target/myapplication<span class="number">-0.0</span><span class="number">.1</span>-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p>还可以运行支持远程调试的打包应用程序。这样做可以将调试器附加到打包的应用程序中，如下例所示:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> java -Xdebug -Xrunjdwp:server=y,transport=dt_socket,address=8000,<span class="built_in">suspend</span>=n \</span></span><br><span class="line">       -jar target/myapplication-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><h5 id="使用Maven插件"><a href="#使用Maven插件" class="headerlink" title="使用Maven插件"></a>使用Maven插件</h5><p>Spring Boot Maven插件包含一个可以用来快速编译和运行应用程序的运行目标。应用程序迅速运行，就像它们在IDE中一样。下面的示例显示了运行Spring引导应用程序的典型Maven命令:</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mvn spring-boot:<span class="keyword">run</span><span class="bash"></span></span><br></pre></td></tr></table></figure><p>我们可能还想使用MAVEN_OPTS操作系统环境变量，如下面的示例所示:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="builtin-name">export</span> <span class="attribute">MAVEN_OPTS</span>=-Xmx1024m</span><br></pre></td></tr></table></figure><h5 id="使用Gradle插件"><a href="#使用Gradle插件" class="headerlink" title="使用Gradle插件"></a>使用Gradle插件</h5><p>Spring Boot Gradle插件还包含一个bootRun任务，该任务可用于迅速运行应用程序。每当应用org.springframework时，都会添加bootRun任务。引导和java插件，如下例所示:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gradle bootRun</span></span><br></pre></td></tr></table></figure><p>我们可能还想使用JAVA_OPTS操作系统环境变量，如下例所示:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="builtin-name">export</span> <span class="attribute">JAVA_OPTS</span>=-Xmx1024m</span><br></pre></td></tr></table></figure><hr><p>####下节预告：  </p><p>详细介绍基于Spring Boot的热加载~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;自动配置&quot;&gt;&lt;a href=&quot;#自动配置&quot; class=&quot;headerlink&quot; title=&quot;自动配置&quot;&gt;&lt;/a&gt;自动配置&lt;/h4&gt;&lt;p&gt;Spring Boot自动配置尝试根据添加的jar依赖项自动配置Spring应用程序。例如，如果&lt;code&gt;HSQLDB&lt;/
      
    
    </summary>
    
      <category term="Java" scheme="http://vi-young.com/categories/Java/"/>
    
    
      <category term="Spring Boot" scheme="http://vi-young.com/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Java基础专题（二）：运算符</title>
    <link href="http://vi-young.com/2018/06/04/Java%E5%9F%BA%E7%A1%80%E4%B8%93%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>http://vi-young.com/2018/06/04/Java基础专题（二）：运算符/</id>
    <published>2018-06-03T18:21:00.000Z</published>
    <updated>2018-06-06T00:50:47.946Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>计算机的最基本用途之一就是执行数学运算，作为一门计算机语言，Java也提供了一套丰富的运算符来操纵变量。我们可以把运算符分成以下几组：</p><ul><li>算术运算符 </li><li>关系运算符 </li><li>位运算符 </li><li>逻辑运算符 </li><li>赋值运算符 </li><li>其他运算符 </li></ul><h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><p>算术运算符的运算结果为整型值或者浮点值</p><p>算术运算符如下表所示：</p><p>设 a = 1 , b = 2</p><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">例子</th></tr></thead><tbody><tr><td style="text-align:left">+</td><td style="text-align:left">将运算符两侧数值相加</td><td style="text-align:left">a + b = 3</td></tr><tr><td style="text-align:left">-</td><td style="text-align:left">将运算符左侧数值减去右侧数值</td><td style="text-align:left">a - b = -1</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">将运算符两侧数值相乘</td><td style="text-align:left">a * b = 2</td></tr><tr><td style="text-align:left">/</td><td style="text-align:left">将运算符左侧数值除以右侧数值</td><td style="text-align:left">b / a = 2</td></tr><tr><td style="text-align:left">%</td><td style="text-align:left">运算符左侧除以右侧的余数</td><td style="text-align:left">b % a = 0</td></tr><tr><td style="text-align:left">++</td><td style="text-align:left">自增，当前数值 +1</td><td style="text-align:left">b++， b = 3</td></tr><tr><td style="text-align:left">–</td><td style="text-align:left">自减，当前数值 -1</td><td style="text-align:left">b–， b = 1</td></tr></tbody></table><p><strong>注意：</strong><br>自增和自减有两种形态：”前缀“和”后缀“，当单独使用的时候，两者并无区别，都是使当前操作的数值 +1 或 -1 ，但是当在表达式中使用的时候，二者就不太一样了，前缀形式会先完成 + 1；而后缀形式则会采用变量原来的值。</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int <span class="attr">m</span> = <span class="number">7</span>;</span><br><span class="line">int <span class="attr">n</span> = <span class="number">7</span>;</span><br><span class="line">int <span class="attr">a</span> = <span class="number">2</span> * ++m; // <span class="attr">a</span> = <span class="number">16</span>, <span class="attr">m</span> = <span class="number">8</span></span><br><span class="line">int <span class="attr">b</span> = <span class="number">2</span> * n++ // <span class="attr">b</span> = <span class="number">14</span>, <span class="attr">n</span> = <span class="number">7</span></span><br></pre></td></tr></table></figure><h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><p>关系运算符的结果为布尔值（ true / false）<br>设 a = 1，b = 2</p><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">例子</th></tr></thead><tbody><tr><td style="text-align:left">==</td><td style="text-align:left">运算符两侧数值是否相等，如果相等结果为true</td><td style="text-align:left">a == b 为 false</td></tr><tr><td style="text-align:left">!=</td><td style="text-align:left">运算符两侧数值是否不相等，如果不相等结果为true</td><td style="text-align:left">a != b 为 true</td></tr><tr><td style="text-align:left">&gt;</td><td style="text-align:left">运算符左侧的数值大于右侧，结果为true</td><td style="text-align:left">b &gt; a 为true</td></tr><tr><td style="text-align:left">&lt;</td><td style="text-align:left">运算符左侧的数值小于右侧，结果为true</td><td style="text-align:left">a &lt; b 为true</td></tr><tr><td style="text-align:left">&gt;=</td><td style="text-align:left">运算符左侧的数值大于等于右侧，结果为true</td><td style="text-align:left">b &gt;= a 为 true</td></tr><tr><td style="text-align:left">&lt;=</td><td style="text-align:left">运算符左侧的数值小于等于右侧，结果为true</td><td style="text-align:left">a &lt;= b 为true</td></tr></tbody></table><h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><p>Java定义了位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。</p><p>位运算符作用在所有的位上，并且<strong>按位运算</strong>。假设a = 60，b = 13;它们的二进制格式表示将如下：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0011</span> <span class="number">1100</span></span><br><span class="line">b = <span class="number">0000</span> <span class="number">1101</span></span><br><span class="line"></span><br><span class="line">a &amp; b = <span class="number">0000</span> <span class="number">1100</span></span><br><span class="line">a | b = <span class="number">0011</span> <span class="number">1101</span></span><br><span class="line">a ^ b = <span class="number">0011</span> <span class="number">0001</span></span><br><span class="line">~a = <span class="number">1100</span> <span class="number">0011</span></span><br></pre></td></tr></table></figure><p>运算规则如下：</p><table><thead><tr><th style="text-align:left">操作符</th><th style="text-align:left">描述</th><th style="text-align:left">例子</th></tr></thead><tbody><tr><td style="text-align:left">&amp;</td><td style="text-align:left">同1为1 ，否则为0</td><td style="text-align:left">a &amp; b = 0000 1100</td></tr><tr><td style="text-align:left">丨</td><td style="text-align:left">同0为0 ，否则为1</td><td style="text-align:left">a 丨b = 0011 1101</td></tr><tr><td style="text-align:left">^</td><td style="text-align:left">相同为0，否则为1</td><td style="text-align:left">a ^ b = 0011 0001</td></tr><tr><td style="text-align:left">~</td><td style="text-align:left">按位取反</td><td style="text-align:left">~a 即 1100 0011</td></tr><tr><td style="text-align:left">&lt;&lt;</td><td style="text-align:left">按位左移运算符。左操作数按位左移右操作数指定的位数。</td><td style="text-align:left">a &lt;&lt; 2 即 1111 0000</td></tr><tr><td style="text-align:left">>&gt;</td><td style="text-align:left">按位右移运算符。左操作数按位右移右操作数指定的位数。</td><td style="text-align:left">a &gt;&gt; 2 即 1111</td></tr><tr><td style="text-align:left">>>&gt;</td><td style="text-align:left">按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。</td><td style="text-align:left">a &gt;&gt;&gt;2 即 0000 1111</td></tr></tbody></table><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>a 为 true，b 为 false</p><table><thead><tr><th style="text-align:left">操作符</th><th style="text-align:left">描述</th><th style="text-align:left">例子</th></tr></thead><tbody><tr><td style="text-align:left">&amp;&amp;</td><td style="text-align:left">逻辑与运算符。当且仅当两个操作数都为真，条件才为真。</td><td style="text-align:left">a &amp;&amp; b 为 false</td></tr><tr><td style="text-align:left">丨丨</td><td style="text-align:left">逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。</td><td style="text-align:left">a 丨丨 b 为真</td></tr><tr><td style="text-align:left">!</td><td style="text-align:left">逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。</td><td style="text-align:left">！（a &amp;&amp; b）为真。</td></tr></tbody></table><p>注意：<br>&amp;&amp; 和 || 具有短路的特性，也就是当第一个条件可以判断最终结果的时候，就不会去判断第二个条件。</p><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><table><thead><tr><th style="text-align:left">操作符</th><th style="text-align:left">描述</th><th style="text-align:left">例子</th></tr></thead><tbody><tr><td style="text-align:left">=</td><td style="text-align:left">基础的赋值运算符，将右边的值赋给左边</td><td style="text-align:left">c = a + b 就是将 a + b 的值赋给 c</td></tr><tr><td style="text-align:left">+(-，*，/，%，&lt;&lt;, &gt;&gt; ,&amp; ,^,</td><td style="text-align:left">)=</td><td style="text-align:left">运算符左侧数值和右侧数值进行对应操作后赋给左侧</td><td>例如c += a 等价于 c = c + a</td></tr></tbody></table><h4 id="条件运算符（？：）"><a href="#条件运算符（？：）" class="headerlink" title="条件运算符（？：）"></a>条件运算符（？：）</h4><p>条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a , b;</span><br><span class="line">   a = <span class="number">10</span>;</span><br><span class="line">   <span class="comment">// 如果 a 等于 1 成立，则设置 b 为 20，否则为 30</span></span><br><span class="line">   b = (a == <span class="number">1</span>) ? <span class="number">20</span> : <span class="number">30</span>;</span><br><span class="line">   System.out.<span class="built_in">println</span>( <span class="string">"Value of b is : "</span> +  b );</span><br><span class="line">   <span class="comment">// 如果 a 等于 10 成立，则设置 b 为 20，否则为 30</span></span><br><span class="line">   b = (a == <span class="number">10</span>) ? <span class="number">20</span> : <span class="number">30</span>;</span><br><span class="line">   System.out.<span class="built_in">println</span>( <span class="string">"Value of b is : "</span> + b );</span><br></pre></td></tr></table></figure><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">运算结果如下：</span><br><span class="line">Value <span class="keyword">of</span> b <span class="keyword">is</span> : 30</span><br><span class="line">Value <span class="keyword">of</span> b <span class="keyword">is</span> : 20</span><br></pre></td></tr></table></figure><h4 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h4><p>该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。</p><p>instanceof运算符使用格式如下：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vehicle a = new Car()<span class="comment">;</span></span><br><span class="line"><span class="keyword">boolean </span>result =  a <span class="keyword">instanceof </span>Car<span class="comment">;</span></span><br><span class="line">System.out.println( result)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>结果如下：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure></p><h4 id="Java运算符优先级"><a href="#Java运算符优先级" class="headerlink" title="Java运算符优先级"></a>Java运算符优先级</h4><p>最高优先级的在该表上方，最低优先级的在该表底部</p><table><thead><tr><th style="text-align:left">类别</th><th style="text-align:left">操作符</th><th style="text-align:left">关联性</th></tr></thead><tbody><tr><td style="text-align:left">后缀</td><td style="text-align:left">（）[].(点操作符)</td><td style="text-align:left">左到右</td></tr><tr><td style="text-align:left">一元</td><td style="text-align:left">++ - ！~</td><td style="text-align:left">右到左</td></tr><tr><td style="text-align:left">乘性</td><td style="text-align:left">* / %</td><td style="text-align:left">左到右</td></tr><tr><td style="text-align:left">加性</td><td style="text-align:left">+ -</td><td style="text-align:left">左到右</td></tr><tr><td style="text-align:left">移位</td><td style="text-align:left">>> >>> &lt;&lt;</td><td style="text-align:left">左到右</td></tr><tr><td style="text-align:left">关系</td><td style="text-align:left">> >= = &lt; &lt;=</td><td style="text-align:left">左到右</td></tr><tr><td style="text-align:left">相等</td><td style="text-align:left">== ~=</td><td style="text-align:left">左到右</td></tr><tr><td style="text-align:left">按位与</td><td style="text-align:left">&amp;</td><td style="text-align:left">左到右</td></tr><tr><td style="text-align:left">按位异或</td><td style="text-align:left">^</td><td style="text-align:left">左到右</td></tr><tr><td style="text-align:left">按位或</td><td style="text-align:left">\丨</td><td style="text-align:left">左到右</td></tr><tr><td style="text-align:left">逻辑与</td><td style="text-align:left">&amp;&amp;</td><td style="text-align:left">左到右</td></tr><tr><td style="text-align:left">逻辑或</td><td style="text-align:left">丨丨</td><td style="text-align:left">左到右</td></tr><tr><td style="text-align:left">条件</td><td style="text-align:left">？：</td><td style="text-align:left">从右到左</td></tr><tr><td style="text-align:left">赋值</td><td style="text-align:left">=，+=，-=，等等</td><td style="text-align:left">从右到左</td></tr><tr><td style="text-align:left">逗号</td><td style="text-align:left">，</td><td style="text-align:left">左到右</td></tr></tbody></table><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="http://www.runoob.com/java/java-operators.html" target="_blank" rel="noopener">Java运算符|菜鸟驿站</a></p><p>Core Java Volume Ⅰ-Fundamentals</p><h4 id="下期预告"><a href="#下期预告" class="headerlink" title="下期预告"></a>下期预告</h4><p>下一期我们来聊一下关于字符串的前世今生~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;计算机的最基本用途之一就是执行数学运算，作为一门计算机语言，Java也提供了一套丰富的运算符来操纵变量。我们可以把运算符分成以下几组：&lt;/p
      
    
    </summary>
    
      <category term="Java" scheme="http://vi-young.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://vi-young.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot 2.0 系列（二）：流程详解（上）</title>
    <link href="http://vi-young.com/2018/06/01/SpringBoot-2-0-%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://vi-young.com/2018/06/01/SpringBoot-2-0-系列（二）：流程详解（上）/</id>
    <published>2018-05-31T22:46:00.000Z</published>
    <updated>2018-05-31T14:49:10.333Z</updated>
    
    <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>本节将详细介绍如何使用Spring Boot。它涵盖了诸如项目管理及自动构建工具、自动配置以及如何运行应用程序等主题。我们还介绍了一些Spring Boot最佳实践。Spring Boot没有什么特别之处(它只是另一个我们可以使用的库)，但是有一些约定俗成的建议（“习惯优于配置”），如果遵循这些建议，将使我们的开发过程变得更容易一些。</p><h3 id="项目管理及自动构建工具"><a href="#项目管理及自动构建工具" class="headerlink" title="项目管理及自动构建工具"></a>项目管理及自动构建工具</h3><p>强烈建议您选择一个支持依赖项管理的构建系统，我们可以使用该系统得到发布到Maven中心仓库的组件。这里建议选择Maven或Gradle。虽然Spring Boot可以与其他构建系统(例如Ant)一起工作，但是它们并没有得到很好的支持。</p><h4 id="1-依赖关系管理"><a href="#1-依赖关系管理" class="headerlink" title="1. 依赖关系管理"></a>1. 依赖关系管理</h4><p>Spring Boot的每一个版本都提供了它所支持的一个被整理的依赖项列表。实际上，我们不需要为构建配置中的任何依赖项提供版本，因为Spring Boot会为我们管理这些依赖项，当我们升级Spring Boot的时候，这些依赖项也会以一致的方式升级。</p><blockquote><p>当然如果需要，我们仍然可以指定一个版本并覆盖Spring Boot的默认项。</p></blockquote><blockquote><p>Spring引导的每个版本都与Spring框架的一个基本版本相关联。我们强烈建议您不要指定它的版本。</p></blockquote><h4 id="2-Maven"><a href="#2-Maven" class="headerlink" title="2. Maven"></a>2. Maven</h4><p>Maven用户可以从spring-boot-starter-parent项目继承来获得合理的默认值。parent项目提供以下特性:</p><ol><li>Java 1.8作为默认的编译器级别。</li><li>UTF - 8编码。</li><li>一个继承自spring-boot-dependencies pom的依赖管理部分，管理通用依赖项的版本。这个依赖项管理可以在自己的pom中使用这些依赖项时省略&lt; version&gt;标记。</li><li>合理的插件配置(exec插件，Git commit ID和shade)。</li><li>合理的资源过滤（例如：application.properties和application.yml）。包含特定于概要文件的文件（例如：application-dev.properties和application-dev.yml）</li></ol><h5 id="2-1-继承-Parent-POM"><a href="#2-1-继承-Parent-POM" class="headerlink" title="2.1 继承 Parent POM"></a>2.1 继承 Parent POM</h5><p>如果需要将项目配置为从spring-boot-starter-parent继承，请将 parent 设置为:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Inherit defaults from Spring Boot --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>我们应该仅在此依赖项上指定Spring Boot版本号。如果我们导入其他starter，我们可以放心地省略版本号。</p></blockquote><p>通过这种设置，我们还可以通过在自己的项目中覆盖属性来覆盖各个依赖项。例如，要升级到另一个Spring-Data release系列，我们可以在我们的pom.xml中添加以下内容:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">spring-data-releasetrain.version</span>&gt;</span>Fowler-SR2<span class="tag">&lt;/<span class="name">spring-data-releasetrain.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2-2-不继承Parent-POM"><a href="#2-2-不继承Parent-POM" class="headerlink" title="2.2 不继承Parent POM"></a>2.2 不继承Parent POM</h5><p>不是每个人都喜欢从spring-boot-starter那里继承。我们可能需要使用您自己的企业标准parent，或者我们可能希望显式声明所有的Maven配置。<br>如果我们不想使用spring-boot-starter-parent，我们仍然可以通过使用scope=import dependency来保持依赖关系管理(而不是插件管理)的好处，如下所示:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Import dependency management from Spring Boot --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>前面的示例设置不允许我们通过使用属性来覆盖各个依赖项，如上所述。要实现相同的结果，我们需要在spring-boot-dependencies条目之前在我们的项目的依赖项管理中添加一个条目。例如，要升级到另一个Spring Data release，我们可以在我们的pom.xml中添加以下元素:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Override Spring Data release train provided by Spring Boot --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-releasetrain<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>Fowler-SR2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>在前面的示例中，我们指定了一个BOM，但是任何依赖类型都可以以相同的方式重写。</p></blockquote><h5 id="3-使用Spring-Boot-Maven-Plugin"><a href="#3-使用Spring-Boot-Maven-Plugin" class="headerlink" title="3. 使用Spring Boot Maven Plugin"></a>3. 使用Spring Boot Maven Plugin</h5><p>Spring Boot包含一个Maven插件，可以将项目打包为可执行jar。如果我们想使用这个插件，请将这个插件添加到&lt; plugins&gt;部分，如下例所示:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-Gradle"><a href="#3-Gradle" class="headerlink" title="3. Gradle"></a>3. Gradle</h4><p>springboot与gradle的结合篇幅较长，将放在后面单独来讲，敬请期待~</p><h4 id="4-Starters"><a href="#4-Starters" class="headerlink" title="4. Starters"></a>4. Starters</h4><p>starters是一组依赖描述符，我们可以在应用程序中包括这些描述符。我们可以为所有Spring和相关技术提供一站式服务，而无需通过示例代码和复制粘贴的依赖描述符来进行搜索。例如，如果我们希望开始使用Spring和JPA进行数据库访问，在项目中包含Spring -boot-starter-data- JPA依赖项就好。<br>starters包含许多依赖项，我们需要这些依赖项来快速启动和运行项目，并且具有一组一致的、受支持的托管传递依赖项。</p><h3 id="代码构建"><a href="#代码构建" class="headerlink" title="代码构建"></a>代码构建</h3><p>Spring Boot不需要任何特定的代码布局来工作。然而，有一些最佳实践对于我们来说显然是很有帮助的。</p><h4 id="1-使用默认包"><a href="#1-使用默认包" class="headerlink" title="1. 使用默认包"></a>1. 使用默认包</h4><p>当一个类不包含包声明时，它被认为是在“默认包”中。一般不建议使用“默认包”，应该避免使用。它会给使用@ComponentScan、@EntityScan或@SpringBootApplication注解的Spring引导应用程序带来特别的问题，因为每个jar的每个类都被读取。</p><blockquote><p>我们建议您遵循Java推荐的包命名约定，并使用一个反向的域名(例如，com.example.project)。</p></blockquote><h4 id="2-定位-main-application-class"><a href="#2-定位-main-application-class" class="headerlink" title="2. 定位 main application class"></a>2. 定位 main application class</h4><p>我们通常建议您将main class置于其他类之上的root packge中。@SpringBootApplication注释通常放在主类上，它隐式地为某些项定义了基本的“搜索包”。例如，如果我们正在编写一个JPA应用程序，则使用@ SpringBootApplication带注释的类的包来搜索@Entity项。使用根包还允许组件扫描只应用于项目。</p><blockquote><p>如果我们不想使用@SpringBootApplication，那么它导入的@EnableAutoConfiguration和@ComponentScan注释定义了这种行为，因此我们也可以使用它。</p></blockquote><p>下面的清单展示了一个典型的布局: </p><pre><code>com +- example +- myapplication     +- Application.java     |     +- customer     |   +- Customer.java     |   +- CustomerController.java     |   +- CustomerService.java     |   +- CustomerRepository.java     |     +- order         +- Order.java         +- OrderController.java         +- OrderService.java         +- OrderRepository.java</code></pre><p> Application.java文件将声明主方法和基本的@SpringBootApplication，如下所示:</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.myapplication;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">SpringApplication.run(Application.<span class="keyword">class</span>, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h3><p>Spring Boot支持基于java的配置。虽然可以将SpringApplication与XML源一起使用，但是我们通常建议您的配置源是一个@Configuration类。通常，定义主方法的类作为主要的@Configuration是一个很好的选择。</p><blockquote><p>许多Spring配置示例已经在Internet上发布，它们使用XML配置。如果可能的话，始终尝试使用等效的基于java的配置。搜索Enable*注释可能是一个很好的起点。</p></blockquote><h4 id="1-导入额外的配置类"><a href="#1-导入额外的配置类" class="headerlink" title="1. 导入额外的配置类"></a>1. 导入额外的配置类</h4><p>不需要将所有的@Configuration放在一个类中。可以使用@Import注释来导入其他配置类，或者我们可以使用@ComponentScan自动提取所有Spring组件，包括@Configuration类。</p><h4 id="2-导入XML配置"><a href="#2-导入XML配置" class="headerlink" title="2. 导入XML配置"></a>2. 导入XML配置</h4><p>如果必须使用基于XML的配置，建议从一个@Configuration类开始。然后可以使用@ImportResource注释来加载XML配置文件。</p><hr><h3 id="下节预告："><a href="#下节预告：" class="headerlink" title="下节预告："></a>下节预告：</h3><ul><li>Auto-configuration</li><li>Spring bean和依赖项注入</li><li>使用@SpringBootApplication注释<br>……<br>敬请期待 ~</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h3&gt;&lt;p&gt;本节将详细介绍如何使用Spring Boot。它涵盖了诸如项目管理及自动构建工具、自动配置以及如何运行应用程序等主题。我们还
      
    
    </summary>
    
      <category term="Java" scheme="http://vi-young.com/categories/Java/"/>
    
    
      <category term="Spring Boot" scheme="http://vi-young.com/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Java基础专题（一）：基本数据类型</title>
    <link href="http://vi-young.com/2018/05/30/Java%E5%9F%BA%E7%A1%80%E4%B8%93%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://vi-young.com/2018/05/30/Java基础专题（一）：基本数据类型/</id>
    <published>2018-05-29T23:56:00.000Z</published>
    <updated>2018-05-29T16:22:39.413Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>今天我们来聊一下Java这门语言的数据类型，众所周知，Java是一种强类型语言。在Java中，一共有8种基本类型，其中4种整形，2种浮点类型，1种用于表示Unicode编码的字符单元的字符类型char和1种用于表示真值的boolean类型。</p><h4 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h4><p>整形用于表示没有小数部分的数值，允许为负。</p><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">存储大小</th><th style="text-align:center">取值范围</th></tr></thead><tbody><tr><td style="text-align:center">int</td><td style="text-align:center">4字节</td><td style="text-align:center">-2,147,483,648 ~ 2,147,483,647</td></tr><tr><td style="text-align:center">short</td><td style="text-align:center">2字节</td><td style="text-align:center">-32,768 ~ 32,767</td></tr><tr><td style="text-align:center">long</td><td style="text-align:center">8字节</td><td style="text-align:center">-9,223,372,036,854,775,808 ~ 9223,372,036,854,775,807</td></tr><tr><td style="text-align:center">byte</td><td style="text-align:center">1字节</td><td style="text-align:center">-128 ~ 127</td></tr></tbody></table><p>在Java中，整形的范围与运行Java代码的机器无关。这解决了软件从一个平台移植到另外一个平台，或者在同一个平台的不同操作系统之间进行移植给程序员带来的麻烦。</p><p>长整形（Long类型）数值后有一个后缀 L 或 l（这里建议不要使用小写的 l 来标识，因为在某些字体的格式下，1和 l 几乎没有任何区别，给月阅读的人带来很大的困扰）。</p><p>十六进制数值前缀为 0x 或 0X，这里需要说一点，八进制的前缀是0，比如010，这样的写法比较容易让人混淆，所以我们一般不要使用八进制来表示数据。</p><p>二进制数值的前缀为 0b 或 0B，例如0b1001所代表的十进制数据就是9。</p><p>从Java7开始，可以在数字字面量加下划线，比如1_000_000，这些下划线的作用仅仅是使代码的易读性更高，编译器在编译的时候会去除这些下划线。</p><h4 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h4><p>浮点类型用于表示有小数部分的数值，在Java中有两种浮点类型。</p><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:center">存储大小</th><th style="text-align:center">取值范围</th></tr></thead><tbody><tr><td style="text-align:left">float</td><td style="text-align:center">4字节</td><td style="text-align:center">大约 ± 3.402,823,47E+38F(有效位为6-7位)</td></tr><tr><td style="text-align:left">double</td><td style="text-align:center">8字节</td><td style="text-align:center">大约 ± 1.79769313486231570E+308（有效位15位）</td></tr></tbody></table><p>double表示这种类型的数值精度是float类型的两倍（故有人称double为双精度数值），事实上我们在使用的过程中，绝大多数情况都会选用double，因为float的精度通常无法满足我们的要求。</p><p>float类型的数值有一个后缀 f 或 F，没有后缀的浮点值就是double类型的。</p><p>可以使用十六进制来表示浮点数值，例如 0.125（2的负三次方）可以表示为 0x1.0p-3。在十六进制中，使用p表示指数，而不是e。</p><p>三个特殊的浮点数值：</p><pre><code>1. 正无穷大（Double.POSITIVE_INFINITY）2. 负无穷大（Double.NEGATIVE_INFINITY）3. NAN（Double.NaN）</code></pre><h4 id="char类型"><a href="#char类型" class="headerlink" title="char类型"></a>char类型</h4><p>一个或两个char类型的数值可以用来表示一个Unicode字符，在代码中，char类型的字面量值需要用单引号括起来，char类型的值可以表示为以 \u 开头的16进制数值，用于表示一些标点和特殊符号所用。</p><p>一些较为特殊的字符的转移序列如下：</p><table><thead><tr><th>转义序列</th><th style="text-align:center">名称</th><th style="text-align:center">Unicode值</th></tr></thead><tbody><tr><td>\b</td><td style="text-align:center">退格</td><td style="text-align:center">\u000</td></tr><tr><td>\t</td><td style="text-align:center">制表</td><td style="text-align:center">\u0009</td></tr><tr><td>\n</td><td style="text-align:center">换行</td><td style="text-align:center">\u000a</td></tr><tr><td>\r</td><td style="text-align:center">回车</td><td style="text-align:center">\u000d</td></tr><tr><td>\“</td><td style="text-align:center">双引号</td><td style="text-align:center">\u0022</td></tr><tr><td>\‘</td><td style="text-align:center">单引号</td><td style="text-align:center">\u0027</td></tr><tr><td>\\</td><td style="text-align:center">反斜杠</td><td style="text-align:center">\u005c</td></tr></tbody></table><font color="red"><strong>Unicode转义序列会在解析代码之前得到处理（大坑慎入！）</strong></font><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// download uri d:<span class="symbol">\u</span>ser<span class="symbol">\a</span>，这里会报语法错误，因为 <span class="symbol">\u</span> 后面没有跟着4个十六进制数。</span><br></pre></td></tr></table></figure><h4 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h4><p>布尔类型有两个值：false和true，用来判定逻辑条件，整型值和布尔值之间不能互相转换，这一点与C或C++不同，需要留意一下。</p><hr><h4 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h4><ol><li>《Core Java Volume Ⅰ-Fundamentals》 – Cay S.Horstmann</li></ol><hr><h4 id="下集预告"><a href="#下集预告" class="headerlink" title="下集预告"></a>下集预告</h4><p>下一期我们来见识一下Java中各种各样运算符的奥秘，三天一更，我们不见不散~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;今天我们来聊一下Java这门语言的数据类型，众所周知，Java是一种强类型语言。在Java中，一共有8种基本类型，其中4种整形，2种浮点类型
      
    
    </summary>
    
      <category term="Java" scheme="http://vi-young.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://vi-young.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 2.0 系列（一）：快速开始</title>
    <link href="http://vi-young.com/2018/05/28/Spring-Boot-2-0-%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B/"/>
    <id>http://vi-young.com/2018/05/28/Spring-Boot-2-0-系列（一）：快速开始/</id>
    <published>2018-05-27T18:35:00.000Z</published>
    <updated>2018-05-27T10:45:38.477Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><ul><li>SpringBoot版本：2.0.2 RELEASE</li><li>开发工具：IDEA 2017.2</li><li>相关资料：<a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/" target="_blank" rel="noopener">SpringBoot官方文档</a></li></ul><h2 id="1-介绍SpringBoot"><a href="#1-介绍SpringBoot" class="headerlink" title="1. 介绍SpringBoot"></a>1. 介绍SpringBoot</h2><p>Spring Boot可以使我们轻松地创建独立的、生产级的基于Spring的应用程序，由于整合了一些对Spring和第三方库的配置，我们可以快速开始一个应用程序。大多数Spring Boot应用程序都需要很少的Spring配置。</p><p>我们可以使用Spring Boot来创建Java应用程序，这些应用程序可以通过使用 <strong>java -jar</strong> 或更传统的war部署来启动。Spring Boot还提供了一个运行“spring脚本”的命令行工具。</p><p>Spring Boot 为我们都做了什么:</p><ul><li><p>为所有Spring开发人员提供一种快速而广泛的入门体验。</p></li><li><p>由于整合了一些对Spring和第三方库的配置解决了深受XML配置困扰的Spring开发人员的痛点</p></li><li><p>提供一系列非功能特性，这些特性在大型项目中是常见的(例如嵌入式服务器、安全、度量、健康检查和外部化配置)。</p></li></ul><h2 id="2-系统环境需求"><a href="#2-系统环境需求" class="headerlink" title="2.系统环境需求"></a>2.系统环境需求</h2><ul><li>Java  8 或 9</li><li>Spring 5.0.6 RELEASE 或 以上</li><li><p>构建工具</p><ul><li>Maven 3.2 +</li><li>Gradle 4 </li></ul></li><li><p>Spring Boot支持以下servlet容器:</p><ul><li>Tomcat 8.5</li><li>Jetty 9.4</li><li>Undertow 1.4 </li></ul></li></ul><h2 id="3-构建项目的方式"><a href="#3-构建项目的方式" class="headerlink" title="3. 构建项目的方式"></a>3. 构建项目的方式</h2><p><strong>1.基于Maven的构建</strong><br>        pom.xml 内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>myproject<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Inherit defaults from Spring Boot --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Add typical dependencies for a web application --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Package as an executable jar --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2.基于Gradle的构建</strong><br>    bulid.gradle 内容如下：</p><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">plugins</span> &#123;</span><br><span class="line"><span class="built_in">id</span> <span class="string">'org.springframework.boot'</span> version <span class="string">'2.0.2.RELEASE'</span></span><br><span class="line"><span class="built_in">id</span> <span class="string">'java'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">jar</span> &#123;</span><br><span class="line">baseName = <span class="string">'myproject'</span></span><br><span class="line">version =  <span class="string">'0.0.1-SNAPSHOT'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">repositories</span> &#123;</span><br><span class="line">jcenter()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">compile(<span class="string">"org.springframework.boot:spring-boot-starter-web"</span>)</span><br><span class="line">testCompile(<span class="string">"org.springframework.boot:spring-boot-starter-test"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-开发Spring-Boot-的Hello-World-项目-使用maven构建工具"><a href="#4-开发Spring-Boot-的Hello-World-项目-使用maven构建工具" class="headerlink" title="4.开发Spring Boot 的Hello World 项目(使用maven构建工具)"></a>4.开发Spring Boot 的Hello World 项目(使用maven构建工具)</h2><p><br></p><p><strong>第一步：创建pom文件</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>myproject<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Additional lines to be added here... --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>第二步：添加依赖</strong></p><p>Spring Boot提供了许多“starter”，可以让您将jar添加到classpath 中。上文已经在POM的父部分使用了spring-boot-starter-parent。spring-boot-starter-parent是一个特殊的“starter”，它提供有用的Maven默认值。它还提供了一个依赖管理部分，这样我们就就可以为关联的依赖项省略版本标记。<br>其他”starter”提供了在开发特定类型的应用程序时可能需要的依赖项。由于我们正在开发一个web应用程序，所以我们添加了一个spring-boot-starter-web依赖项。在此之前，我们可以通过运行以下命令查看当前所拥有的内容。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>第三步：编写代码</strong></p><p>要完成我们的应用程序，我们需要创建一个Java文件，Java文件包含以下代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</span><br><span class="line"><span class="function">String <span class="title">home</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Hello World!"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">SpringApplication.run(Example.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注：</strong><br>在我们的示例类上的第一个注释是@RestController。这被称为构造型注释。它为阅读代码的人们提供了一些提示，并且为Spring提供了一个特定的角色。在本例中，我们的类是一个web @Controller，所以Spring在处理传入web请求时考虑它。@RequestMapping注释提供路由信息。它告诉Spring，任何带有/ path的HTTP请求都应该映射到home方法。@RestController注释告诉Spring将生成的字符串直接呈现给调用者。</p></blockquote><blockquote><p>第二个类级别注释是@EnableAutoConfiguration。这个注释告诉Spring Boot基于您添加的jar依赖项“猜测”您想如何配置Spring，。因为Spring-boot-starter-web添加了Tomcat和Spring MVC，所以自动配置假设您正在开发一个web应用程序，并相应地设置Spring。</p></blockquote><blockquote><p>我们的应用程序的最后一部分是主方法。这只是遵循应用程序入口点的Java约定的标准方法。通过调用run，我们的main方法委托给Spring Boot的SpringApplication类。SpringApplication引导我们的应用程序启动Spring，而Spring又启动了自动配置的Tomcat web服务器。我们需要通过例子。类作为运行方法的参数，以告诉SpringApplication是主Spring组件。args数组也被传递，以公开任何命令行参数。</p></blockquote><p><strong>第四步：运行程序：</strong></p><p>运行main方法，或者在根目录运行 mvn spring-boot: run命令。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ mvn spring-boot:run</span><br><span class="line"></span><br><span class="line">  .   ____          <span class="symbol">_</span>            <span class="symbol">__</span> <span class="symbol">_</span> <span class="symbol">_</span></span><br><span class="line"> /\\ / ___'<span class="symbol">_</span> <span class="symbol">__</span> <span class="symbol">_</span> <span class="symbol">_</span>(<span class="symbol">_</span>)<span class="symbol">_</span> <span class="symbol">__</span>  <span class="symbol">__</span> <span class="symbol">_</span> \ \ \ \</span><br><span class="line">( ( )\___ | '<span class="symbol">_</span> | '<span class="symbol">_</span>| | '<span class="symbol">_</span> \/ <span class="symbol">_</span>` | \ \ \ \</span><br><span class="line"> \\/  ___)| |<span class="symbol">_</span>)| | | | | || (<span class="symbol">_</span>| |  ) ) ) )</span><br><span class="line">  '  |____| .<span class="symbol">__</span>|<span class="symbol">_</span>| |<span class="symbol">_</span>|<span class="symbol">_</span>| |<span class="symbol">_</span>\<span class="symbol">__</span>, | / / / /</span><br><span class="line"> =========|<span class="symbol">_</span>|==============|___/=/<span class="symbol">_</span>/<span class="symbol">_</span>/<span class="symbol">_</span>/</span><br><span class="line"> :: Spring Boot ::  (v2.0.2.RELEASE)</span><br><span class="line">....... . . .</span><br><span class="line">....... . . . (<span class="built_in">log</span> output here)</span><br><span class="line">....... . . .</span><br><span class="line">........ Started Example <span class="keyword">in</span> <span class="number">2.222</span> seconds (JVM running <span class="keyword">for</span> <span class="number">6.514</span>)</span><br></pre></td></tr></table></figure><p>打开浏览器，输入localhost:8080，你可以看到</p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World!</span><br></pre></td></tr></table></figure><p><strong>第五步：创建可执行的jar</strong></p><p>将下列代码添加到pom.xml文件中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>保存文件，并在命令行输入maven package，可以看到：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">mvn</span> <span class="string">package</span></span><br><span class="line"></span><br><span class="line"><span class="string">[INFO]</span> <span class="string">Scanning</span> <span class="string">for</span> <span class="string">projects...</span></span><br><span class="line"><span class="string">[INFO]</span></span><br><span class="line"><span class="string">[INFO]</span> <span class="bullet">------------------------------------------------------------------------</span></span><br><span class="line"><span class="string">[INFO]</span> <span class="string">Building</span> <span class="string">myproject</span> <span class="number">0.0</span><span class="number">.1</span><span class="bullet">-SNAPSHOT</span></span><br><span class="line"><span class="string">[INFO]</span> <span class="bullet">------------------------------------------------------------------------</span></span><br><span class="line"><span class="string">[INFO]</span> <span class="string">....</span> <span class="string">..</span></span><br><span class="line"><span class="string">[INFO]</span> <span class="meta">---</span> <span class="attr">maven-jar-plugin:2.4:jar</span> <span class="string">(default-jar)</span> <span class="string">@</span> <span class="string">myproject</span> <span class="meta">---</span></span><br><span class="line"><span class="string">[INFO]</span> <span class="string">Building</span> <span class="attr">jar:</span> <span class="string">/Users/developer/example/spring-boot-example/target/myproject-0.0.1-SNAPSHOT.jar</span></span><br><span class="line"><span class="string">[INFO]</span></span><br><span class="line"><span class="string">[INFO]</span> <span class="meta">---</span> <span class="attr">spring-boot-maven-plugin:2.0.2.RELEASE:repackage</span> <span class="string">(default)</span> <span class="string">@</span> <span class="string">myproject</span> <span class="meta">---</span></span><br><span class="line"><span class="string">[INFO]</span> <span class="bullet">------------------------------------------------------------------------</span></span><br><span class="line"><span class="string">[INFO]</span> <span class="string">BUILD</span> <span class="string">SUCCESS</span></span><br><span class="line"><span class="string">[INFO]</span> <span class="bullet">------------------------------------------------------------------------</span></span><br></pre></td></tr></table></figure><p>这时你会发现target目录下多了一个名为myprojectname-0.0.1-SNAPSHOT.jar的文件，文件大概10MB，如果你想查看文件的详细内容，可以使用</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jar tvf target/myproject<span class="number">-0.0</span><span class="number">.1</span>-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p>如果你想运行，可以使用 java -jar，如下：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ java -jar target/myproject-<span class="number">0.0</span>.1-SNAPSHOT.jar</span><br><span class="line"></span><br><span class="line">  .   ____          <span class="symbol">_</span>            <span class="symbol">__</span> <span class="symbol">_</span> <span class="symbol">_</span></span><br><span class="line"> /\\ / ___'<span class="symbol">_</span> <span class="symbol">__</span> <span class="symbol">_</span> <span class="symbol">_</span>(<span class="symbol">_</span>)<span class="symbol">_</span> <span class="symbol">__</span>  <span class="symbol">__</span> <span class="symbol">_</span> \ \ \ \</span><br><span class="line">( ( )\___ | '<span class="symbol">_</span> | '<span class="symbol">_</span>| | '<span class="symbol">_</span> \/ <span class="symbol">_</span>` | \ \ \ \</span><br><span class="line"> \\/  ___)| |<span class="symbol">_</span>)| | | | | || (<span class="symbol">_</span>| |  ) ) ) )</span><br><span class="line">  '  |____| .<span class="symbol">__</span>|<span class="symbol">_</span>| |<span class="symbol">_</span>|<span class="symbol">_</span>| |<span class="symbol">_</span>\<span class="symbol">__</span>, | / / / /</span><br><span class="line"> =========|<span class="symbol">_</span>|==============|___/=/<span class="symbol">_</span>/<span class="symbol">_</span>/<span class="symbol">_</span>/</span><br><span class="line"> :: Spring Boot ::  (v2.0.2.RELEASE)</span><br><span class="line">....... . . .</span><br><span class="line">....... . . . (<span class="built_in">log</span> output here)</span><br><span class="line">....... . . .</span><br><span class="line">........ Started Example <span class="keyword">in</span> <span class="number">2.536</span> seconds (JVM running <span class="keyword">for</span> <span class="number">2.864</span>)</span><br></pre></td></tr></table></figure><p>若知后事如何，且听下回分解~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;SpringBoot版本：2.0.2 RELEASE&lt;/li&gt;
&lt;li&gt;开发工具：IDEA 2017.2&lt;/li
      
    
    </summary>
    
      <category term="Java" scheme="http://vi-young.com/categories/Java/"/>
    
    
      <category term="Spring Boot" scheme="http://vi-young.com/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>《用户体验要素》读后笔记[完]（三）</title>
    <link href="http://vi-young.com/2018/05/05/%E3%80%8A%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%A6%81%E7%B4%A0%E3%80%8B%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://vi-young.com/2018/05/05/《用户体验要素》读后笔记（三）/</id>
    <published>2018-05-04T16:10:00.000Z</published>
    <updated>2018-05-30T01:54:45.719Z</updated>
    
    <content type="html"><![CDATA[<h1 id="结构层"><a href="#结构层" class="headerlink" title="结构层"></a>结构层</h1><p>在定义好用户需求并排序好优先级别之后，我们对于最终差您将会包括什么特性已经有了清楚的图像，然而这些需求并没有说明如何将这些分散的片段组成一个整体，这就是范围层的上面一层：为网站建立一个概念结构。</p><p>结构层适当的将我们的关注点从抽象的决策与范围问题，转移到更能影响最后的用户体验的具体因素，传统的软件开发行业，涉及”为用户设计结构化体验”的方法被称为交互设计。在内容建设方面，主要是通过信息架构来构建用户体验。这两个都强调一个重点：确定各个将要呈现给用户的元素的“模式”和“顺序”。与其针对机器的最佳工作方式来设计系统，还不如设计一个对用户而言最好的系统，用户对于“交互组件将怎么样工作”的观点成为概念模型。概念模型是用于在交互设计的开发过程中保持使用方式的一致性的，交互设计会处理每一个级别的错误，以确保更高比例的用户能有积极的体验。</p><h2 id="信息架构"><a href="#信息架构" class="headerlink" title="信息架构"></a>信息架构</h2><ul><li>信息架构所研究的是人们如何认知信息的过程，对于产品而言，信息架构关注的是呈现给用户的信息是否合理并具有意义</li><li>信息架构要求创建分类体系，创建分类体系的方法有从上向下和从下向上，但是这两种方法都有一定的局限性，唯一可避免两者缺点的方法是在两种方法中找到一个平衡点</li><li>一个高效结构的优点就是具备“容纳成长和适应变动”的能力 </li><li>信息架构的基本单位是节点</li><li>节点的结构包括层级结构（树状、辐射）、矩阵结构、自然结构、线性结构</li><li>节点在信息架构是依据组织原则来安置的</li><li>我们的困难不是创建一个结构，而是在创建一个能与“我们的目标”和“用户的需求”相对应、正确的结构</li><li>成功的用户体验，就是能事先预知用户的期望并将其带入到设计当中去</li><li>“使用客户的语言”并且“保持一致性”是非常重要的，我们把用来强调一致性的工具称为受控词典</li><li>元数据的意思，简单地说就是“关于信息的信息”，即以一个结构化的方式来描述内容的信息。   </li></ul><h1 id="框架层"><a href="#框架层" class="headerlink" title="框架层"></a>框架层</h1><p>在充满概念的结构层中开始形成大量的需求，这些需求都是来自我们的战略目标的需求。在框架层，我们要更进一步的提炼这些结构，确定很详细的界面外观，导航和信息设计，这能让晦涩的结构变得实在。对于功能性产品，我们通过界面设计来确定框架，对于信息型产品，要解决的问题是导航设计，但是这两者都应解决信息设计这一方面。</p><blockquote><p>提供给用户做某些事的能力，这属于界面设计。<br> 提供给用户去某个地方的能力，这是导航设计。<br> 传达想法给用户，那就是信息设计。</p></blockquote><ul><li>传统的习惯并非一定要死守，当某种方式有着不错的收益时，应该谨慎的试着违背一些习惯。</li><li>有效的使用比喻，即减少用户在理解你的产品时对猜测的要求。</li><li>界面设计的全部事情就是选择正确的界面元素</li><li>设计复杂系统的界面所面临的最大挑战之一，是弄清楚用户不需要哪些东西，并减少他们的可发现性。</li><li><p>导航设计必须完成以下三个目标：<br> ① 提供用户一种在网页间跳转的方法<br> ② 元素与所包含内容之间的关系<br> ③ 内容与当前用户浏览页面之间的关系<br> 多重导航系统：<br> 全局导航，局部导航，辅助导航，上下文导航，友好导航，远程导航，网络地图，索引表</p></li><li><p>将信息设计和导航设计结合到一起，有一个重要的作用：支持指示标识。</p></li><li><p>页面布局是将信息设计、界面设计和导航设计放置到一起，形成一个统一的，有内在凝聚力的架构，这个架构的具体文档的展示方式为线框图。</p></li><li><p>线框图是整合在框架层的全部三种要素的方法：通过安排和选择界面元素来整合界面设计；通过识别和定义核心导航系统来整合导航设计；通过放置和排列信息组成部分的优先级来整合信息设计。</p></li></ul><h1 id="表现层"><a href="#表现层" class="headerlink" title="表现层"></a>表现层</h1><p>在这五个模型的顶端，我们把注意力转移到产品用户会首先注意到的地方：感知设计，这里，内容、功能和美学汇集到一起来缠身一个最终设计，完成其他四个层面的所有目标，并同时满足用户的感官感受。</p><ul><li><p>表现层中几乎所有的产品都会涉及到视觉设计，在视觉设计中，我们用于吸引用户注意的一个主要工具就是对比。</p></li><li><p>在你的设计中保持一致性是另一个重要的组成部分，它能使你的设计有效地传达信息，而不会导致用户迷惑或焦虑。“一致性”在视觉设计的许多不同方面都会起到作用。</p></li><li><p>内部和外部的一致性：<br>  ① 内部一致性的问题。这是说，在产品的两个不同的地方反映了不同的设计方法。<br>  ② 外部一致性的问题。这是说，这个产品没有在同一个企业的其他产品中，反映出被使用的，相同的设计方法。</p></li><li><p>配色方案与排版对于品牌形象的建立，以及对于公众的影响显得尤为重要。</p></li><li><p>在视觉设计领域中对线框图最直接的模拟是视觉模型或设计合成品。</p></li><li><p>承载这些设计决策的权威性文档是风格指南。这个汇总文档确定了视觉设计的每个方面，从最大到最小的范围内的所有元素</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;结构层&quot;&gt;&lt;a href=&quot;#结构层&quot; class=&quot;headerlink&quot; title=&quot;结构层&quot;&gt;&lt;/a&gt;结构层&lt;/h1&gt;&lt;p&gt;在定义好用户需求并排序好优先级别之后，我们对于最终差您将会包括什么特性已经有了清楚的图像，然而这些需求并没有说明如何将这些分散的片段
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://vi-young.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="UE" scheme="http://vi-young.com/tags/UE/"/>
    
  </entry>
  
  <entry>
    <title>《用户体验要素》读后笔记（二）</title>
    <link href="http://vi-young.com/2018/05/04/%E3%80%8A%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%A6%81%E7%B4%A0%E3%80%8B%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://vi-young.com/2018/05/04/《用户体验要素》读后笔记（二）/</id>
    <published>2018-05-04T15:52:00.000Z</published>
    <updated>2018-05-09T06:42:29.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="战略层"><a href="#战略层" class="headerlink" title="战略层"></a>战略层</h1><p>成功的用户体验，其基础是一个被明确表达的“战略”，知道企业与用户双方对产品的期许和目标，有助于促进用户体验各方面战略的确定和制定。</p><blockquote><p>明确两个问题：我们要通过这个产品得到什么？ 我们的客户要通过这个产品得到什么？<br>    ①     产品目标     ②     用户需求</p></blockquote><h2 id="产品目标："><a href="#产品目标：" class="headerlink" title="产品目标："></a>产品目标：</h2><p>   ①     商业目标（商业驱动因素）<br>    ②     品牌识别<br>    ③     成功标识</p><h2 id="用户需求："><a href="#用户需求：" class="headerlink" title="用户需求："></a>用户需求：</h2><p>   ①     用户细分</p><pre><code>1. 人口统计学2. 消费心理档案</code></pre><p>   ②     可用性和用户研究</p><pre><code>1. 市场调研方法2. 现场调研3. 任务分析4. 用户测试5. 卡片排序法6. 用户模型</code></pre><p>这是就需要一篇战略文档，而战略文档的关键在于<strong>简洁明了</strong>并<strong>切中要点</strong>，战略是设计用户体验设计流程中的起点。</p><h1 id="范围层"><a href="#范围层" class="headerlink" title="范围层"></a>范围层</h1><p>带着“我们想要什么”、“我们的用户想要什么”的明确认识，我们才能弄清楚如何去满足这些战略的目标，当你把用户需求和产品目标转变成产品应该提供给用户什么样的内容和功能时，战略就变成了范围。</p><p>用文档定义产品需求的必要性：<br>    ① 这样你才知道你在建设什么<br>    ② 这样你才知道你不需要建设什么</p><blockquote><p>范围层被功能型产品和信息型产品分为了功能规格和内容需求，定义需求的详略层度往往取决于该项目的具体范围。</p></blockquote><h2 id="功能规格说明："><a href="#功能规格说明：" class="headerlink" title="功能规格说明："></a>功能规格说明：</h2><ol><li>文档不能解决问题，但定义可以，我们需要的不是文档有厚或有多详细，而是要足够清楚和准确。</li><li>乐观：描述这个系统将要做什么事情去“防止”不好的情况发生</li><li>具体：尽可能详细的解释清楚情况</li><li>在文档中要尽量避免主观的语气</li></ol><h2 id="内容需求："><a href="#内容需求：" class="headerlink" title="内容需求："></a>内容需求：</h2><ol><li>应该提供每一个特性规模的文档预估：文本的字数，图片的像素大小，下载的文件字节、PDF或音频文件等独立元素的大小等。</li><li>内容特性的更新频率来自于产品的战略目标，必须确定一个频率，它是介于你的用户期望值和有效值之间</li></ol><h2 id="确定需求优先级："><a href="#确定需求优先级：" class="headerlink" title="确定需求优先级："></a>确定需求优先级：</h2><ol><li>有些特性可能会因为技术上的局限无法实现，有些则是因为资源与时间上的不足</li><li>很少有功能时独立存在的</li><li>如果你的战略计划或愿景文档在战略目标的范围内制定了一个清晰的优先级别顺序，那么这些优先级别应该是决定是否采纳人们所建议的相关特性的首要因素</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;战略层&quot;&gt;&lt;a href=&quot;#战略层&quot; class=&quot;headerlink&quot; title=&quot;战略层&quot;&gt;&lt;/a&gt;战略层&lt;/h1&gt;&lt;p&gt;成功的用户体验，其基础是一个被明确表达的“战略”，知道企业与用户双方对产品的期许和目标，有助于促进用户体验各方面战略的确定和制定。&lt;
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://vi-young.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="UE" scheme="http://vi-young.com/tags/UE/"/>
    
  </entry>
  
  <entry>
    <title>《用户体验要素》 读后笔记（一）</title>
    <link href="http://vi-young.com/2018/05/04/%E3%80%8A%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%A6%81%E7%B4%A0%E3%80%8B%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://vi-young.com/2018/05/04/《用户体验要素》读后笔记（一）/</id>
    <published>2018-05-04T15:38:00.000Z</published>
    <updated>2018-05-09T06:42:52.092Z</updated>
    
    <content type="html"><![CDATA[<p>最近有幸拜读了Jesse James Garrett所著的用户体验要素这本书，感触颇多，感觉对于UE这门课程有了一个较为系统的认识，知道了用户体验为什么是如此的重要，以及用户体验的五个元素。</p><p>在产品开发过程中,人们更多的关注what to do, 设计师经常忽略的另一个因素是how to do, 而这一因素恰恰是决定产品成败的关键因素。</p><blockquote><p>“外形服从于功能”</p></blockquote><p>这种观点对于产品的内部运作(用户不可见的部分)是完全适用的, 但是, 对于产品直接面向用户的那些部分—按钮, 布局, 文字, 也包括外观, 正确的产品形态绝对不是由”功能”所决定的, 而是应该由”<strong>用户自身的心理感受和行为</strong>“来决定的</p><blockquote><p>提供优质的用户体验, 是一个重要的可持续的竞争优势 —— 不仅仅对网站是这样, 对所有类型的产品和服务都是如此</p></blockquote><p>创建吸引人的,高效的用户体验的方法称为”以用户为中心的设计”. 以用户为中心的设计思想非常简单,: 在开发产品的每一个步骤中, 都要把用户列入考虑范围，下面我们来认识一下这些要素。</p><h2 id="五个要素"><a href="#五个要素" class="headerlink" title="五个要素"></a>五个要素</h2><p>用户体验开发时的五个要素(5s)</p><pre><code>表现层(surface)    一系列的网页, 由图片和文字组成框架层(skeleton)    按钮, 控件, 照片和文本区域的位置, 优化设计布局, 以达到这些元素的最大效果和效率结构层(structure)    框架是结构的具体表达方式范围层(scope)    结构层确定网站各种特性和功能最合适的组合方式, 而这些特性和功能就构成了网站的范围层战略层(strategy)    网站的范围基本上是由网站战略层决定的</code></pre><h2 id="双重性"><a href="#双重性" class="headerlink" title="双重性"></a>双重性</h2><p>自下而上的建设，并且让每一个层面的工作在下一个层面可以结束之前完成，网站具有基本的双重性，描述功能型的平台类产品和描述信息的媒介类产品。</p><pre><code>功能性产品, 主要关注的任务, 所有的操作都被纳入一个过程,  去思考人们如何完成这个过程, 这里的网站实际上是用户用于完成任务的一种工具信息性产品, 主要的关注点是信息, 创建一个富信息的用户体验, 就是提供给用户一个可以寻找, 理解且有意义的组合</code></pre><h2 id="区别和联系"><a href="#区别和联系" class="headerlink" title="区别和联系"></a>区别和联系</h2><pre><code>1.战略层所关注的内容都是一样的, 来自企业外部的用户需求和来自自己对网站的期望目标。2.由范围层进入战略层, 在功能型产品一侧转化为功能规格: 对产品的&quot;功能组合&quot;的详细描述. 而在信息型产品一侧, 范围则是以内容需求的形式出现:     对各种内容元素的要求的详细描述。3.在功能性产品一侧, 结构层将从范围转化为交互设计, 在这里我们可以定义系统如何响应用户的请求,另一侧是信息架构: 合理的安排内容元素以促进人类理解信息4.在框架层, 必不可少的是信息设计, 功能性产品偏向于界面设计, 而信息类产品, 则偏向于导航设计.5.最后, 在表现层, 关注点都在于最终产品创建用户体验</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近有幸拜读了Jesse James Garrett所著的用户体验要素这本书，感触颇多，感觉对于UE这门课程有了一个较为系统的认识，知道了用户体验为什么是如此的重要，以及用户体验的五个元素。&lt;/p&gt;
&lt;p&gt;在产品开发过程中,人们更多的关注what to do, 设计师经常忽
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://vi-young.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="UE" scheme="http://vi-young.com/tags/UE/"/>
    
  </entry>
  
</feed>
