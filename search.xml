<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java基础专题（一）：基本数据类型]]></title>
    <url>%2F2018%2F05%2F30%2FJava%E5%9F%BA%E7%A1%80%E4%B8%93%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[前言今天我们来聊一下Java这门语言的数据类型，众所周知，Java是一种强类型语言。在Java中，一共有8种基本类型，其中4种整形，2种浮点类型，1种用于表示Unicode编码的字符单元的字符类型char和1种用于表示真值的boolean类型。 整型整形用于表示没有小数部分的数值，允许为负。 类型 存储大小 取值范围 int 4字节 -2,147,483,648 ~ 2,147,483,647 short 2字节 -32,768 ~ 32,767 long 8字节 -9,223,372,036,854,775,808 ~ 9223,372,036,854,775,807 byte 1字节 -128 ~ 127 在Java中，整形的范围与运行Java代码的机器无关。这解决了软件从一个平台移植到另外一个平台，或者在同一个平台的不同操作系统之间进行移植给程序员带来的麻烦。 长整形（Long类型）数值后有一个后缀 L 或 l（这里建议不要使用小写的 l 来标识，因为在某些字体的格式下，1和 l 几乎没有任何区别，给月阅读的人带来很大的困扰）。 十六进制数值前缀为 0x 或 0X，这里需要说一点，八进制的前缀是0，比如010，这样的写法比较容易让人混淆，所以我们一般不要使用八进制来表示数据。 二进制数值的前缀为 0b 或 0B，例如0b1001所代表的十进制数据就是9。 从Java7开始，可以在数字字面量加下划线，比如1_000_000，这些下划线的作用仅仅是使代码的易读性更高，编译器在编译的时候会去除这些下划线。 浮点类型浮点类型用于表示有小数部分的数值，在Java中有两种浮点类型。 类型 存储大小 取值范围 float 4字节 大约 ± 3.402,823,47E+38F(有效位为6-7位) double 8字节 大约 ± 1.79769313486231570E+308（有效位15位） double表示这种类型的数值精度是float类型的两倍（故有人称double为双精度数值），事实上我们在使用的过程中，绝大多数情况都会选用double，因为float的精度通常无法满足我们的要求。 float类型的数值有一个后缀 f 或 F，没有后缀的浮点值就是double类型的。 可以使用十六进制来表示浮点数值，例如 0.125（2的负三次方）可以表示为 0x1.0p-3。在十六进制中，使用p表示指数，而不是e。 三个特殊的浮点数值： 1. 正无穷大（Double.POSITIVE_INFINITY） 2. 负无穷大（Double.NEGATIVE_INFINITY） 3. NAN（Double.NaN） char类型一个或两个char类型的数值可以用来表示一个Unicode字符，在代码中，char类型的字面量值需要用单引号括起来，char类型的值可以表示为以 \u 开头的16进制数值，用于表示一些标点和特殊符号所用。 一些较为特殊的字符的转移序列如下：| 转义序列 | 名称 | Unicode值 || ——- |:——-:| —-:|| \b| 退格 | \u0008 || \t| 制表 | \u0009 || \n| 换行 | \u000a || \r| 回车 | \u000d || \”| 双引号 | \u0022 || \’ | 单引号 | \u0027 || \ | 反斜杠 | \u005c | Unicode转义序列会在解析代码之前得到处理（大坑慎入！） 1// download uri d:\user\a，这里会报语法错误，因为 \u 后面没有跟着4个十六进制数。 布尔类型布尔类型有两个值：false和true，用来判定逻辑条件，整型值和布尔值之间不能互相转换，这一点与C或C++不同，需要留意一下。 参考文献 《Core Java Volume Ⅰ-Fundamentals》 – Cay S.Horstmann 下集预告下一期我们来见识一下Java中各种各样运算符的奥秘，三天一更，我们不见不散~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 2.0 系列（一）：快速开始]]></title>
    <url>%2F2018%2F05%2F28%2FSpring-Boot-2-0-%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[写在前面 SpringBoot版本：2.0.2 RELEASE 开发工具：IDEA 2017.2 相关资料：SpringBoot官方文档 1. 介绍SpringBootSpring Boot可以使我们轻松地创建独立的、生产级的基于Spring的应用程序，由于整合了一些对Spring和第三方库的配置，我们可以快速开始一个应用程序。大多数Spring Boot应用程序都需要很少的Spring配置。 我们可以使用Spring Boot来创建Java应用程序，这些应用程序可以通过使用 java -jar 或更传统的war部署来启动。Spring Boot还提供了一个运行“spring脚本”的命令行工具。 Spring Boot 为我们都做了什么: 为所有Spring开发人员提供一种快速而广泛的入门体验。 由于整合了一些对Spring和第三方库的配置解决了深受XML配置困扰的Spring开发人员的痛点 提供一系列非功能特性，这些特性在大型项目中是常见的(例如嵌入式服务器、安全、度量、健康检查和外部化配置)。 2.系统环境需求 Java 8 或 9 Spring 5.0.6 RELEASE 或 以上 构建工具 Maven 3.2 + Gradle 4 Spring Boot支持以下servlet容器: Tomcat 8.5 Jetty 9.4 Undertow 1.4 3. 构建项目的方式1.基于Maven的构建 pom.xml 内容如下： 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;myproject&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- Inherit defaults from Spring Boot --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;!-- Add typical dependencies for a web application --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- Package as an executable jar --&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2.基于Gradle的构建 bulid.gradle 内容如下： 123456789101112131415161718plugins &#123; id 'org.springframework.boot' version '2.0.2.RELEASE' id 'java'&#125;jar &#123; baseName = 'myproject' version = '0.0.1-SNAPSHOT'&#125;repositories &#123; jcenter()&#125;dependencies &#123; compile("org.springframework.boot:spring-boot-starter-web") testCompile("org.springframework.boot:spring-boot-starter-test")&#125; 4.开发Spring Boot 的Hello World 项目(使用maven构建工具) 第一步：创建pom文件 123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;myproject&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;!-- Additional lines to be added here... --&gt;&lt;/project&gt; 第二步：添加依赖 Spring Boot提供了许多“starter”，可以让您将jar添加到classpath 中。上文已经在POM的父部分使用了spring-boot-starter-parent。spring-boot-starter-parent是一个特殊的“starter”，它提供有用的Maven默认值。它还提供了一个依赖管理部分，这样我们就就可以为关联的依赖项省略版本标记。其他”starter”提供了在开发特定类型的应用程序时可能需要的依赖项。由于我们正在开发一个web应用程序，所以我们添加了一个spring-boot-starter-web依赖项。在此之前，我们可以通过运行以下命令查看当前所拥有的内容。 123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 第三步：编写代码 要完成我们的应用程序，我们需要创建一个Java文件，Java文件包含以下代码: 123456789101112131415161718import org.springframework.boot.*;import org.springframework.boot.autoconfigure.*;import org.springframework.web.bind.annotation.*;@RestController@EnableAutoConfigurationpublic class Example &#123; @RequestMapping("/") String home() &#123; return "Hello World!"; &#125; public static void main(String[] args) throws Exception &#123; SpringApplication.run(Example.class, args); &#125;&#125; 注：在我们的示例类上的第一个注释是@RestController。这被称为构造型注释。它为阅读代码的人们提供了一些提示，并且为Spring提供了一个特定的角色。在本例中，我们的类是一个web @Controller，所以Spring在处理传入web请求时考虑它。@RequestMapping注释提供路由信息。它告诉Spring，任何带有/ path的HTTP请求都应该映射到home方法。@RestController注释告诉Spring将生成的字符串直接呈现给调用者。 第二个类级别注释是@EnableAutoConfiguration。这个注释告诉Spring Boot基于您添加的jar依赖项“猜测”您想如何配置Spring，。因为Spring-boot-starter-web添加了Tomcat和Spring MVC，所以自动配置假设您正在开发一个web应用程序，并相应地设置Spring。 我们的应用程序的最后一部分是主方法。这只是遵循应用程序入口点的Java约定的标准方法。通过调用run，我们的main方法委托给Spring Boot的SpringApplication类。SpringApplication引导我们的应用程序启动Spring，而Spring又启动了自动配置的Tomcat web服务器。我们需要通过例子。类作为运行方法的参数，以告诉SpringApplication是主Spring组件。args数组也被传递，以公开任何命令行参数。 第四步：运行程序： 运行main方法，或者在根目录运行 mvn spring-boot: run命令。 12345678910111213$ mvn spring-boot:run . ____ _ __ _ _ /\\ / ___'_ __ _ _(_)_ __ __ _ \ \ \ \( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \ \\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.0.2.RELEASE)....... . . ........ . . . (log output here)....... . . ......... Started Example in 2.222 seconds (JVM running for 6.514) 打开浏览器，输入localhost:8080，你可以看到 1Hello World! 第五步：创建可执行的jar 将下列代码添加到pom.xml文件中： 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 保存文件，并在命令行输入maven package，可以看到： 123456789101112131415$ mvn package[INFO] Scanning for projects...[INFO][INFO] ------------------------------------------------------------------------[INFO] Building myproject 0.0.1-SNAPSHOT[INFO] ------------------------------------------------------------------------[INFO] .... ..[INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ myproject ---[INFO] Building jar: /Users/developer/example/spring-boot-example/target/myproject-0.0.1-SNAPSHOT.jar[INFO][INFO] --- spring-boot-maven-plugin:2.0.2.RELEASE:repackage (default) @ myproject ---[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------ 这时你会发现target目录下多了一个名为myprojectname-0.0.1-SNAPSHOT.jar的文件，文件大概10MB，如果你想查看文件的详细内容，可以使用 1$ jar tvf target/myproject-0.0.1-SNAPSHOT.jar 如果你想运行，可以使用 java -jar，如下： 12345678910111213$ java -jar target/myproject-0.0.1-SNAPSHOT.jar . ____ _ __ _ _ /\\ / ___'_ __ _ _(_)_ __ __ _ \ \ \ \( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \ \\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.0.2.RELEASE)....... . . ........ . . . (log output here)....... . . ......... Started Example in 2.536 seconds (JVM running for 2.864) 若知后事如何，且听下回分解~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础回顾知识点（二）]]></title>
    <url>%2F2018%2F05%2F21%2FJava%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[基本程序设计结构 由于自增和自减运算符会改变变量的值，所以它们的操作数不能是数值。例如 4 ++ 就不是一个合法的语句。 123int n = 4;n++; //正确。4++; //错误。 ++n 与 n++ 前缀形式会改变变量的值，后缀则是使用变量原来的值。 &amp;&amp; 和 || 运算负是按照短路方法来求值的，如果第一个操作数已经可以确定表达式的值，第二个数就不必计算了。 利用&amp;（位运算符）并结合使用适当的2的幂，可以将其他位掩掉，而只保留其中的某一位。 1int fourthBitFromRight = (n &amp; 0b10000) / 0b10000; //如果第四位为1,则返回1,否则返回0; “ &gt;&gt;&gt; “运算符会用0填充高位，这与” &gt;&gt; “不同，他会用符号位填充高位，不存在” &lt;&lt;&lt; “运算符。 移位运算符的右操作数要完成模32的运算（除非左操作数是long类型，在这种情况下需要对右操作数模64）.例如，1&lt;&lt;35的值等同于1&lt;&lt;3 或 8。 有时候，变量的取值只会在一个有限的集合内，这是就会用到枚举（enum）类型的值。 12345enum Size &#123; SMALL,MEDIUM,LARGE,EXTRA_LARGE;&#125;//声明一个枚举变量Size s = Size.MEDIUM; Java字符串就是Unicode字符序列，每个用双引号括起来的字符串都是String类的一个实例。 substring(first , last)的截取方法是取头不取尾。 12String s1 = "hello";String s2 = s1.substring(0,3); // s2 = "hel" 如果需要把多个字符串放在一起，用一个定界符分离，可以使用静态join方法。 1String all = String.join("/", "S", "M", "L", "XL"); // all = "S/M/L/XL" 由于不能修改Java字符串中的字符，所以String类对象被称为不可变字符串，但是可以修改字符串变量的引用地址，将它从一个字符串引用到另一个字符串。 编译器可以让字符串共享，共享带来的高效率远远大于提取和拼接字符串所带来的低效率。 各种字符串存放在公共的存储池中，字符串变量指向存储池中相应的位置。 原始字符串放置在堆中，Java将自动地进行垃圾回收，如果一块内存不再使用了，系统最终会将其回收。 使用equals方法判断两个字符串是否相等，一定不要使用 ==运算符检测两个字符串是否相等，因为他们判断的是地址，而非值。 空串是“”，长度为0的字符串。 当一个变量等于null，说明当前没有任何对象与这个变量相关联。 Java字符串由char值序列组成，char数据类型是一个采用UTF-16编码表示Unicode码点的代码单元，辅助字符需要用一对代码单元来表示。 当需要遍历一个字符串获取每一个码点的方法是使用codePoints，会生成一个int数值的“流”，然后将流转换成数组在进行遍历，反之，如果需要转换成字符串，可以使用String的构造方法。 123456789101112String greeting = "hello";int n = greeting.length(); // length方法返回采用UTF-16编码表示的给定字符串所需要的代码单元数量。 5//得到实际的码点数量。int cpCount = greeting.codePointCount(0, n);//charAt(n) 返回位置为n的代码单元char first = greeting.charAt(0); // first is ‘h’//得到第n个码点int index = greeting.offsetByCodePoints(0, n);int cp = greeting.codePointAt(index); StringBuilder和StringBuffer的API是一样的，StringBuffer允许采用多线程的方式执行添加或删除字符串的操作，如果所有字符串在一个单线程中编辑，则应该使用StringBuilder替代它。 格式说明符：% + 索引参数值 + $ + 标志 + 宽度 + 精度 + 转换字符 12System.out.printf("%1$s %2$tB %2$te, %2$tY", "Due date:", new Date());//print Due Date: May 20, 2018 块（即复合语句）是指由一对大括号括起来的若干条简单的Java语句，块确定了变量的作用域，一个块可以嵌套在另一个块中。 不可以在嵌套的块中声明同名的变量。 使用块可以在Java程序结构中原本只能放置一条（简单）语句的地方放置多条语句。 如果开始循环的条件的值就为false，则while循环体一次也不执行。 如果希望循环体至少执行一次，则应该将检测条件放在最后。使用do/while循环语句可以实现这种操作方式。 for语句的第1部分通常用于对计数器初始化；第2部分给出每次第一轮循环执行前要检测的循环条件；第3部分指示如何更新计数器。 在for语句的第1部分中声明了一个变量后，这个变量的作用域就为for循环的整个循环体。 如果希望在for循环体之外使用循环计数器的最终值，就要确保这个变量在循环语句的前面且在外部声明。 可以在各自独立的不同for循环中定义同名的变量。 case标签可以是类型为char，byte，short或int的常量表达式，枚举常量，字符串字面量。 break是结束当前的循环，而continue是结束本次循环进行下一次循环，在循环前使用标签，可以使用break的标签决定结束哪一个循环。 BigInteger类实现了任意精度的整数计算，BigDecimal实现了任意精度的浮点数计算，但是不能用算术运算符来处理大数值，而要使用大数值类中的add和multiply方法。 数组是一种数据结构，用于存储同一类型值的集合。 创建一个数字数组时，所有元素都初始化为0。boolean数据的元素会初始化为false。对象数组的元素则初始化为一个特殊值null，这表示这些元素（还）未存放任何对象。 for each循环语句的循环变量将会遍历数组中的每个元素，而不需要使用下标值。 数组排序可以使用Arrays的sort方法 12int[] a = new int[1000];Arrays.sort(a); 数组拷贝使用的是Arrays的copyOf方法 12int[] num = &#123;1, 2, 3, 4&#125;;int[] copyNum = Arrays.copyOf(num, num.length); 二维数组的遍历需要使用两重循环来完成 123456double[][] rows = &#123;&#123;1,2&#125;,&#123;3,4&#125;,&#123;5,6&#125;&#125;;for(double[] row : rows) &#123; for(double value : row) &#123; System.out.println(value); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础回顾知识点（一）]]></title>
    <url>%2F2018%2F05%2F13%2FJava%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面本系列主要讲Java基础知识，是对自己温故知新的总结，一个标题为一个内容，同时也欢迎各方大佬指出文中不对的地方前来交流探讨技术~ Java”白皮书“的关键术语： 简单性 面向对象 分布式 健壮性 安全性 体系结构中立 可移植性 解释型 高性能 多线程 动态性 关于Java的常见误解 Java是HTML的扩展 使用XML，所以不需要Java Java是一种非常容易学习的程序设计语言 Java将成为适用于所有平台的通用性编程语言 Java只不过是另外一种程序设计语言 Java是专用的，应该避免使用 Java是解释型的，因此对于关键的应用程序速度太慢了 所有的Java程序都是在网页中运行的 JavaScript是Java的简易版 使用Java可以用廉价的Internet设备取代桌面计算机 基本程序设计结构 类作为一个加载程序逻辑的容器，程序逻辑定义了应用程序的行为。类是构建所有Java应用程序和applet的构建块。Java应用程序中的全部内容都必须放置在类中。 源代码的文件名必须与公共类的名字相同，这里需要注意的是公共类，而非所有类，比如内部类的名字就不必与源代码的文件名相同。 根据Java语言规范，main方法必须声明为public。 在Java中，所有的数值类型所占据的字节数量与平台无关。 可以使用十六进制表示浮点数值。例如，0.125 = 2的负三次方可以表示成 0x1.0p-3。在十六进制表示法中，使用p表示指数，而不是e。注意，尾数采用十六进制，指数采用十进制，指数的基数是2，而不是10。 用于表示溢出和出错情况的三个特殊的浮点数值： 正无穷大 负无穷大 NaN（Not A Number） Unicode转移序列会在解析代码之前得到处理，更隐秘的，一定要多加注意注释中的\u注释 所有”非数值“的值都认为是不相同的。然而，可以使用Double.isNaN方法。 在基本的多语言级别中，每个字符用16位表示，通常被称为代码单元。 在Java中，char类型描述了UTF-16编码中的一个代码单元。 boolean类型有两个值：false和true，用于判定逻辑条件。整数值和布尔值之间不能进1行相互转换。 如果想知道哪些Unicode字符属于Java中的“字母”，可以使用Character类的isJavaIndentifierStart和isJavaIdentifierPart方法来检查。 声明一个变量后，必须用赋值语句对变量进行显式初始化。 在Java中，利用关键字final指示常量，表示这个常量只能被赋值一次，一旦被赋值之后，就不能被更改了。习惯上，常量名使用全大写。 在Java中，可以通过static final来定义类常量，这个类常量可以在一个类的多个方法中使用，注意，类常量需要定义在main方法外部。 使用strictfp关键字来标记main方法，则main方法中所有指令都将会进行严格的浮点计算用于生成可再生的结果。 1public static strictfp void main(String[] args) 计算一个数值的平方根，可以使用sqrt方法。 123double x = 4;double y = Math.sqrt(x);System.out.println(y); //prints 2.0 借助于Math类的pow方法，可以将y的值设置为x的a次幂。 1double y = Math.pow(x,a)； floorMod方法可以防止除数为负的时候，进行 % 运算时余数为负（但是不能避免被除数为负时，floorMod得到负数结果） 如果得到一个完全可预测的结果比运行速度更重要的话，应该使用StrictMath类。它使用fdlibm来实现算法，以确保在所有平台上得到相同的结果。（ps：我们平时使用都是Math类） 如果想对浮点数进行舍入运算，以便得到最接近的整数，那就需要使用Math.round方法。 12345678double x1 = 9.997;int nx1 = (int)x1; // x = 9/*** 这里需要进行类型转换是因为round函数返回的是一个Long类型的数值，为了防止精度丢失。*/double x2 = 9.997;int nx2 = (int)Math.round(x2) // x = 10 如果试图将一个数值从一种类型强制转换成另一种类型，而又超出了目标类型的表示范围，结果就会被截断成一个完全不同的值。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《用户体验要素》读后笔记（三）]]></title>
    <url>%2F2018%2F05%2F05%2F%E3%80%8A%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%A6%81%E7%B4%A0%E3%80%8B%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[结构层在定义好用户需求并排序好优先级别之后，我们对于最终差您将会包括什么特性已经有了清楚的图像，然而这些需求并没有说明如何将这些分散的片段组成一个整体，这就是范围层的上面一层：为网站建立一个概念结构。 结构层适当的将我们的关注点从抽象的决策与范围问题，转移到更能影响最后的用户体验的具体因素，传统的软件开发行业，涉及”为用户设计结构化体验”的方法被称为交互设计。在内容建设方面，主要是通过信息架构来构建用户体验。这两个都强调一个重点：确定各个将要呈现给用户的元素的“模式”和“顺序”。与其针对机器的最佳工作方式来设计系统，还不如设计一个对用户而言最好的系统，用户对于“交互组件将怎么样工作”的观点成为概念模型。概念模型是用于在交互设计的开发过程中保持使用方式的一致性的，交互设计会处理每一个级别的错误，以确保更高比例的用户能有积极的体验。 信息架构 信息架构所研究的是人们如何认知信息的过程，对于产品而言，信息架构关注的是呈现给用户的信息是否合理并具有意义 信息架构要求创建分类体系，创建分类体系的方法有从上向下和从下向上，但是这两种方法都有一定的局限性，唯一可避免两者缺点的方法是在两种方法中找到一个平衡点 一个高效结构的优点就是具备“容纳成长和适应变动”的能力 信息架构的基本单位是节点 节点的结构包括层级结构（树状、辐射）、矩阵结构、自然结构、线性结构 节点在信息架构是依据组织原则来安置的 我们的困难不是创建一个结构，而是在创建一个能与“我们的目标”和“用户的需求”相对应、正确的结构 成功的用户体验，就是能事先预知用户的期望并将其带入到设计当中去 “使用客户的语言”并且“保持一致性”是非常重要的，我们把用来强调一致性的工具称为受控词典 元数据的意思，简单地说就是“关于信息的信息”，即以一个结构化的方式来描述内容的信息。 框架层在充满概念的结构层中开始形成大量的需求，这些需求都是来自我们的战略目标的需求。在框架层，我们要更进一步的提炼这些结构，确定很详细的界面外观，导航和信息设计，这能让晦涩的结构变得实在。对于功能性产品，我们通过界面设计来确定框架，对于信息型产品，要解决的问题是导航设计，但是这两者都应解决信息设计这一方面。 提供给用户做某些事的能力，这属于界面设计。 提供给用户去某个地方的能力，这是导航设计。 传达想法给用户，那就是信息设计。 传统的习惯并非一定要死守，当某种方式有着不错的收益时，应该谨慎的试着违背一些习惯。 有效的使用比喻，即减少用户在理解你的产品时对猜测的要求。 界面设计的全部事情就是选择正确的界面元素 设计复杂系统的界面所面临的最大挑战之一，是弄清楚用户不需要哪些东西，并减少他们的可发现性。 导航设计必须完成以下三个目标： ① 提供用户一种在网页间跳转的方法 ② 元素与所包含内容之间的关系 ③ 内容与当前用户浏览页面之间的关系 多重导航系统： 全局导航，局部导航，辅助导航，上下文导航，友好导航，远程导航，网络地图，索引表 将信息设计和导航设计结合到一起，有一个重要的作用：支持指示标识。 页面布局是将信息设计、界面设计和导航设计放置到一起，形成一个统一的，有内在凝聚力的架构，这个架构的具体文档的展示方式为线框图。 线框图是整合在框架层的全部三种要素的方法：通过安排和选择界面元素来整合界面设计；通过识别和定义核心导航系统来整合导航设计；通过放置和排列信息组成部分的优先级来整合信息设计。 表现层在这五个模型的顶端，我们把注意力转移到产品用户会首先注意到的地方：感知设计，这里，内容、功能和美学汇集到一起来缠身一个最终设计，完成其他四个层面的所有目标，并同时满足用户的感官感受。 表现层中几乎所有的产品都会涉及到视觉设计，在视觉设计中，我们用于吸引用户注意的一个主要工具就是对比。 在你的设计中保持一致性是另一个重要的组成部分，它能使你的设计有效地传达信息，而不会导致用户迷惑或焦虑。“一致性”在视觉设计的许多不同方面都会起到作用。 内部和外部的一致性： ① 内部一致性的问题。这是说，在产品的两个不同的地方反映了不同的设计方法。 ② 外部一致性的问题。这是说，这个产品没有在同一个企业的其他产品中，反映出被使用的，相同的设计方法。 配色方案与排版对于品牌形象的建立，以及对于公众的影响显得尤为重要。 在视觉设计领域中对线框图最直接的模拟是视觉模型或设计合成品。 承载这些设计决策的权威性文档是风格指南。这个汇总文档确定了视觉设计的每个方面，从最大到最小的范围内的所有元素]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>UE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《用户体验要素》读后笔记（二）]]></title>
    <url>%2F2018%2F05%2F04%2F%E3%80%8A%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%A6%81%E7%B4%A0%E3%80%8B%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[战略层成功的用户体验，其基础是一个被明确表达的“战略”，知道企业与用户双方对产品的期许和目标，有助于促进用户体验各方面战略的确定和制定。 明确两个问题：我们要通过这个产品得到什么？ 我们的客户要通过这个产品得到什么？ ① 产品目标 ② 用户需求 产品目标： ① 商业目标（商业驱动因素） ② 品牌识别 ③ 成功标识 用户需求： ① 用户细分 1. 人口统计学 2. 消费心理档案 ② 可用性和用户研究 1. 市场调研方法 2. 现场调研 3. 任务分析 4. 用户测试 5. 卡片排序法 6. 用户模型 这是就需要一篇战略文档，而战略文档的关键在于简洁明了并切中要点，战略是设计用户体验设计流程中的起点。 范围层带着“我们想要什么”、“我们的用户想要什么”的明确认识，我们才能弄清楚如何去满足这些战略的目标，当你把用户需求和产品目标转变成产品应该提供给用户什么样的内容和功能时，战略就变成了范围。 用文档定义产品需求的必要性： ① 这样你才知道你在建设什么 ② 这样你才知道你不需要建设什么 范围层被功能型产品和信息型产品分为了功能规格和内容需求，定义需求的详略层度往往取决于该项目的具体范围。 功能规格说明： 文档不能解决问题，但定义可以，我们需要的不是文档有厚或有多详细，而是要足够清楚和准确。 乐观：描述这个系统将要做什么事情去“防止”不好的情况发生 具体：尽可能详细的解释清楚情况 在文档中要尽量避免主观的语气 内容需求： 应该提供每一个特性规模的文档预估：文本的字数，图片的像素大小，下载的文件字节、PDF或音频文件等独立元素的大小等。 内容特性的更新频率来自于产品的战略目标，必须确定一个频率，它是介于你的用户期望值和有效值之间 确定需求优先级： 有些特性可能会因为技术上的局限无法实现，有些则是因为资源与时间上的不足 很少有功能时独立存在的 如果你的战略计划或愿景文档在战略目标的范围内制定了一个清晰的优先级别顺序，那么这些优先级别应该是决定是否采纳人们所建议的相关特性的首要因素]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>UE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《用户体验要素》 读后笔记（一）]]></title>
    <url>%2F2018%2F05%2F04%2F%E3%80%8A%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%A6%81%E7%B4%A0%E3%80%8B%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[最近有幸拜读了Jesse James Garrett所著的用户体验要素这本书，感触颇多，感觉对于UE这门课程有了一个较为系统的认识，知道了用户体验为什么是如此的重要，以及用户体验的五个元素。 在产品开发过程中,人们更多的关注what to do, 设计师经常忽略的另一个因素是how to do, 而这一因素恰恰是决定产品成败的关键因素。 “外形服从于功能” 这种观点对于产品的内部运作(用户不可见的部分)是完全适用的, 但是, 对于产品直接面向用户的那些部分—按钮, 布局, 文字, 也包括外观, 正确的产品形态绝对不是由”功能”所决定的, 而是应该由”用户自身的心理感受和行为“来决定的 提供优质的用户体验, 是一个重要的可持续的竞争优势 —— 不仅仅对网站是这样, 对所有类型的产品和服务都是如此 创建吸引人的,高效的用户体验的方法称为”以用户为中心的设计”. 以用户为中心的设计思想非常简单,: 在开发产品的每一个步骤中, 都要把用户列入考虑范围，下面我们来认识一下这些要素。 五个要素用户体验开发时的五个要素(5s) 表现层(surface) 一系列的网页, 由图片和文字组成 框架层(skeleton) 按钮, 控件, 照片和文本区域的位置, 优化设计布局, 以达到这些元素的最大效果和效率 结构层(structure) 框架是结构的具体表达方式 范围层(scope) 结构层确定网站各种特性和功能最合适的组合方式, 而这些特性和功能就构成了网站的范围层 战略层(strategy) 网站的范围基本上是由网站战略层决定的 双重性自下而上的建设，并且让每一个层面的工作在下一个层面可以结束之前完成，网站具有基本的双重性，描述功能型的平台类产品和描述信息的媒介类产品。 功能性产品, 主要关注的任务, 所有的操作都被纳入一个过程, 去思考人们如何完成这个过程, 这里的网站实际上是用户用于完成任务的一种工具 信息性产品, 主要的关注点是信息, 创建一个富信息的用户体验, 就是提供给用户一个可以寻找, 理解且有意义的组合 区别和联系1.战略层所关注的内容都是一样的, 来自企业外部的用户需求和来自自己对网站的期望目标。 2.由范围层进入战略层, 在功能型产品一侧转化为功能规格: 对产品的&quot;功能组合&quot;的详细描述. 而在信息型产品一侧, 范围则是以内容需求的形式出现: 对各种内容元素的要求的详细描述。 3.在功能性产品一侧, 结构层将从范围转化为交互设计, 在这里我们可以定义系统如何响应用户的请求,另一侧是信息架构: 合理的安排内容元素以促进人类理解信息 4.在框架层, 必不可少的是信息设计, 功能性产品偏向于界面设计, 而信息类产品, 则偏向于导航设计. 5.最后, 在表现层, 关注点都在于最终产品创建用户体验]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>UE</tag>
      </tags>
  </entry>
</search>
