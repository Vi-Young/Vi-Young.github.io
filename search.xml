<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java技术体系以及写作计划]]></title>
    <url>%2F2018%2F07%2F08%2FJava%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB%E4%BB%A5%E5%8F%8A%E5%86%99%E4%BD%9C%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[前言 如果把Java比喻成一颗繁荣茂盛的大树。 首先，它需要土壤（JVM），需要主干（基础），枝杈（扩展），肥料（设计模式）。当然，如果想要让这个树茁壮的成长，我们还需要学习一些灌溉的知识（操作系统），甚至来说我们还需要一些生物专业的知识（数据结构和算法），甚至于我们了解树的每一个细胞，可以去研学细胞学的知识（源码）。 现在我们有了一棵树，我们还需要知道如果这棵树上有了害虫之后怎么除虫（安全攻防）。当然，我们如果不满足一颗树，我们需要的是一片树林，那么我们需要知道怎么把这些树合理的安排而可以茁壮互不影响的成长（分布式架构）。 所以，我们下面就来详细的了解如果想要把这些搞明白，需要学习哪些知识： 基础 数据类型 运算符 字符串 控制流程 数组 对象与类 static关键字 对象构造 注释 继承 Object 对象包装与自动装箱机制 枚举 反射 接口 Lambda 内部类 代理 异常 断言 日志 泛型 了解泛型 泛型的约束和局限性 继承规则 通配符类型 反射和泛型 集合 集合整体认知 集合详解 映射 视图与包装器 集合中的算法 Java IO 单元测试 序列化 并发 线程认知 线程安全 锁 死锁 volatile域 synchronized关键字 原子性 执行器 同步器 notify ,notifyAll, wait, sleep 语法糖 JVM 类的加载机制 Jvm内存结构 GC算法 垃圾回收 GC分析 命令调优 HotSpot 工具的使用篇 分布式架构 分布式事务 分布式数据库 分布式文件系统 分布式缓存 Docker &amp; k8s Spring Cloud Spring Boot 分库分表 消息中间件 Zookeeper 扩展 网络知识 网络协议 Socket编程 Netty Nginx实现反向代理，负载均衡 CDN DNS 数据库 SQL优化 数据库锁 缓存数据库 Redis Memcached 事务 搜索引擎 Solr Lucene ES 权限管理： Shiro AI Python 概率论 机器学习 人工神经网络 深度学习 TensorFlow 设计模式详细目录需精读《Head First 设计模式》之后再进行补充 操作系统 Linux常用命令 其他目录需阅读《鸟哥的Linux私房菜》之后再进行完善 数据结构和算法详细目录需精读《算法》和《算法导论》之后在进行补充 ###安全攻防 详细目录需详细阅读《黑客攻防技术宝典》以及更多的书籍后进行补充。 写作计划顺序如下： 基础 -&gt; JVM -&gt; 分布式架构 -&gt; 扩展 -&gt; 设计模式 -&gt; 操作系统 -&gt; 数据结构和算法 -&gt; 安全攻防。（源码的学习穿插于大多数步骤，一般会对一些经典的类和框架进行源码的研读） 每日一更，详细讲解上述内容，除了个别的会单独拿出来作为一个系列（比如docker，springboot），基本上是按照顺序来讲解。计划三到五年写完，每周末更新预告下周目录。 公众号文章首发于公众号和个人博客 http://vi-young.com扫码或微信搜索Vi的技术博客，关注公众号，不定期送书活动各种福利~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础系列（七）：对象与类（下）]]></title>
    <url>%2F2018%2F07%2F08%2FJava%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%83%EF%BC%89%EF%BC%9A%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言上节我们学习了对象和对象变量的概念，以及它们之间的区别。与此同时，我们还知道了如何自定义一个属于我们自己的类，以及多个源文件的时候的编译机制。这节课我们来剖析一下我们上节课建造的这个类。 解读类Employee类如下： 12345678910111213141516171819202122232425262728293031public class Employee &#123; //fields private String name; private double salary; private LocalDate hireday; //constructor public Employee(String n, double s, int year, int month, int day) &#123; name = n; salary = s; hireday = LocalDate.of(year, month, day); &#125; //methods public String getName() &#123; return name; &#125; public double getSalary() &#123; return salary; &#125; public LocalDate getHireday() &#123; return hireday; &#125; public void raiseSalary(double byPercent) &#123; double raise = salary * byPercent / 100; &#125;&#125; 对这个的方法进行剖析，我们会发现这个类有一个构造器和四个方法： 12345678//构造器public Employee(String n, double s, int year, int month, int day) &#123;&#125;//方法public String getName()&#123;&#125;public double getSalary()&#123;&#125;public localDate getHireDay()&#123;&#125;public void raiseSalary(double byPercent)&#123;&#125; 这些类的所有方法被标记为public，关键字public意味着任何类的任何方法都可以通过构造一个对象的方式来调用这些方法。当然，在Employee类的实例中有三个实例域用来存放将要操作的数据： 123private String name;private double salary;private LocalDate hireDay; 关键字private确保只有Employee类自身的方法能够访问这些实例域，而其他类的方法不能访问这些实例域，这确保了类与类之间的隔离性，它们之间的数据不会相互影响。在这需要注意一点，类通常包括类型属于另外某个类类型的实例域，比如name域是String类对象，hireDay是LocalDate类对象。 构造器12345public Employee(String n, double s, int year, int month, int day) &#123; name = n; salary = s; hireday = LocalDate.of(year, month, day);&#125; 可以看到，构造器必须与类名保持一致，在构造Employee类的对象时，构造器会运行，以便将实例域初始化为所希望的状态。这里需要注意一点，构造器与其他的方法有一个重要的不同，构造器总是伴随着new操作符的执行被调用，而不能对一个已经存在的对象调用构造器来达到重新设置实例域的目的。比如： 1faker.Employee("Faker", 1000000000, 1997, 08, 25) //会报编译错误 后面我会单开一节详细讲解构造器，我们现在只需记住： 构造器与类同名 每个类可以有一个以上的构造器 构造器可以有0个，1个或多个参数 构造器没有返回值 构造器总是随着new操作一起调用 方法以及它的参数方法用于操作对象以及存取它们的实例域，比如： 123456public void raiseSalary(double byPercent) &#123; double raise = salary * byPercent / 100; salary += raise;&#125;faker.raiseSalary(5) 方法调用的结果是把faker.salary域的值增加5%，实际上，它执行了以下的过程： 12double raise = faker.salary * byPercent / 100;faker.salary += raise; 由此可以看出，这个方法并不像我们想像的那样只有一个byPercent参数，它实际上还包括了一个隐式参数，是出现在方法名前的Employee对象，第二个参数是位于方法名后面括号中的数值。这是一个显式参数。在每一个方法中，关键字this表示隐式参数，比如刚刚那个方法可以写成如下形式： 1234public void raiseSalary(double byPercent) &#123; double raise = this.salary * byPercent / 100; this.salary += raise;&#125; 域访问器和域修改器12345678910111213141516171819202122232425 //域访问器 public String getName() &#123; return name; &#125; public double getSalary() &#123; return salary; &#125; public LocalDate getHireday() &#123; return hireday; &#125; //域修改器public void setName(String name) &#123; this.name = name;&#125;public void setSalary(double salary) &#123; this.salary = salary;&#125;public void setHireday(int year, int month, int day) &#123; this.hireday = LocalDate.of(year, month, day);&#125; 我们为什么会需要这些方法呢？直接将实例域设置为public不是更好？这里就需要知道一点，类的实例域如果是public ，当我们在许多地方构造了这个类的对象并对实例域进行修改，出现错误之后，你将无法找到是哪个方法对他进行了修改，比如，上例中的salary，它只能通过raiseSalary()进行修改，一旦出错，我们只需要去调试这个方法即可。 如果想要获得或者设置实例域的值，应该提供以下三个内容： 私有的数据域 公有的域访问器（get方法） 公有的域修改器（set方法） 这样看起来要比提供一个公有数据域要复杂，但是却有其他的好处，利大于弊： 可以改变内部实现，除了该类的其他方法以外，不会影响其他代码（安全性） 更改器可以进行错误检查，而直接对域赋值不能进行这样的操作 这样做，更符合面向对象的编程思想，每个对象的个体都是隐私且独立的。 final实例域可以将实例域定义为final，构造对象的时候必须初始化这样的域，也就是说，必须确保在每一个构造器执行之后，这个域的值被设置，并且在后面的操作中，不能再对它进行修改。 final修饰符大都应用于基本类型域，或不可变类的域（比如String），对于可变的类，虽然可以使用final修饰符，但是我们需要注意一点，final指定的该域的地址值不会变，而这个对象本身可变，则不受影响，只是表示这个对象变量不会指向其他的对象。 12345678//定义一个可变的实例域private final StringBuilder sb;//初始化sb = new StringBuilder();//更改sb.append("Hello Java!") 下节预告下节我们来了解Java中的静态（static） 公众号扫码或微信搜索Vi的技术博客，关注公众号，不定期送书活动各种福利~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础系列（六）：对象与类（上）]]></title>
    <url>%2F2018%2F07%2F08%2FJava%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%88%E5%85%AD%EF%BC%89%EF%BC%9A%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[概述类（class）是构造对象的模板。由类构造对象的过程称为创建类的实例。 封装从形式上看，封装是将数据和行为组合在一个包中，并对对象的使用者隐藏了数据的实现方式。对象中的数据称为实例域，而操纵数据的过程称之为方法。对于每个特定的类实例（对象）都有一组特定的实例域值。这些值的集合就是这个对象的当前状态。而实现封装的关键就是绝对不能让类中的方法直接访问其他类的实例域，仅仅可以通过对象的方法来与对象的数据进行交互。 在Java中，所有的类都来源于一个叫做Object的父类，我们将在后面的篇幅中详细讲解这个类。 对象与对象变量如果我们想要使用对象，就必须要先来构造一个对象，然后指定它的初始状态。然后，再对这个对象应用方法。在Java中，我们使用构造器来构造新的实例，构造器是一种特殊的方法，用来构造并初始化对象，构造器的名字应该与类的名字相同，如果想要构造一个对象，需要在构造器前面加上new操作符，比如： 1new Date() 这个表达式就是构造了一个对象，这个对象被初始化为当前的日期和时间。我们可以把这个对象作为参数，也可以立即调用这个对象的方法，比如： 12System.out.println(new Date());new Date().toString(); 但是，我们如果希望构造的对象可以多次使用，这是就需要将这个对象存到一个变量当中： 1Date birthday = new Date(); 这里需要注意，对象和对象变量是不同的： 1Date deadline; //deadline并没有指向任何一个对象 这里定义了一个对象变量deadline，它可以引用Date类型的变量，但是，变量deadline不是一个对象，也没有引用任何对象。 12Date deadline;String s = deadline.toString(); //这里会报一个编译错误 必须首先初始化变量，然后才能使用它，我们可以使用以下两种方式来初始化一个变量 12345678//1.使用new操作符Date deadline;deadline = new Date();//2.引用一个已经存在的对象Date deadline;Date birthday = new Date();deadline = birthday; 一定要认识到：一个对象变量并没有实际包含一个对象，而是仅仅引用一个对象。对象变量的值就是引用的对象在堆中的地址。如下： 1Date deadline = new Date(); 这里分为两个部分，表达式new Date()构造了一个Date类型的对象，它的值是它在堆中的地址值，然后将该值赋给了deadline。可以显式地将对象变量设置为null，表明这个对象变量目前没有引用任何对象，但是需要注意，如果将一个方法应用到一个值为null的对象上，那么就会产生运行时错误，抛出NullPointerException。 自定义类在Java中，最简单的类定义形式为： 12345678910class ClassName &#123; field1; field2; ... constructor1; constructor2; ... method1; method2;&#125; 如下程序是一个简单的小例子： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.time.LocalDate;public class EmployeeTest &#123; public static void main(String[] args) &#123; Employee[] staff = new Employee[3]; staff[0] = new Employee("Carl Cracker", 75000, 1987, 12, 15); staff[0] = new Employee("Carl Cracker", 85000, 1988, 4, 15); staff[0] = new Employee("Carl Cracker", 105000, 1989, 8, 15); for (Employee employee : staff) &#123; employee.raiseSalary(5); &#125; for (Employee employee : staff) &#123; System.out.println("name = " + employee.getName() + ", salary = " + employee.getSalary() + ", hireday = " + employee.getHireday()); &#125; &#125;&#125;class Employee &#123; //fields private String name; private double salary; private LocalDate hireday; //constructor public Employee(String n, double s, int year, int month, int day) &#123; name = n; salary = s; hireday = LocalDate.of(year, month, day); &#125; //methods public String getName() &#123; return name; &#125; public double getSalary() &#123; return salary; &#125; public LocalDate getHireday() &#123; return hireday; &#125; public void raiseSalary(double byPercent) &#123; double raise = salary * byPercent / 100; &#125;&#125; 注意，在这个示例程序中包括两个类：Employee类和带有public 访问修饰符的EmployeeTest类，源文件名是EmployeeTest.java，这是因为文件名必须与public类的名字相匹配。在一个源文件中，只能有一个公有类，但可以有任意数目的非公有类。接下来，在编译这段源代码的时候，编译器将在目录下创建两个类文件：EmployeeTest.class和Employee.class。将程序中包含main方法的类名提供给字节码解释器，以便启动这个程序： 1java EmployeeTest 字节码解释器开始运行EmployeeTest类的main方法中的代码，在这段代码中，先后构造了三个新Employee对象。 多个源文件的情况在刚刚的例子中，一个源文件中包含了两个类，但是在日常的开发当中，我们通常习惯将每一个类存放到一个源文件中，如果我们将每个类都分别放到一个源文件中，刚刚的程序将可以有两种编译源程序的方法。一种是使用通配符调用 Java编译器： 1javac Employee*.java 于是，所有与通配符匹配的源文件都将被编译成类文件，第二种方式如下： 1javac EmployeeTest.java 这里我们并没有显式的编译Employee.java。但是，当Java编译器发现EmployeeTest.java使用了Employee类时会查找名为Employee.class的文件，如果没有找到这个文件，就会自动的搜索Employee.java，然后，对它进行编译。更重要的是：如果Employee.java版本较已有的Employee.class文件版本新，Java编译器就会自动地重新编译这个文件。 下节预告下节我们来了解对象与类地奥秘~ 公众号扫码或微信搜索Vi的技术博客，关注公众号，不定期送书活动各种福利~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础系列（五）：数组]]></title>
    <url>%2F2018%2F07%2F08%2FJava%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9A%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[简介在Java中，有一种数据结构叫做数组，它用来存储同一类型的值的集合。通过一个整型下标可以访问数组中的每一个值。例如，如果a是一个整型数组，那么a[i]就是数组中下标为i的整数。 创建一个数组的方法首先，我们可以声明一个数组，声明一个数组有两种方法： 12int[] a;int a[]; 当然，一般情况下我们更喜欢使用第一种方式来声明一个数组，因为它将类型与变量名分开，优化了代码的可读性。刚刚我们只是声明了一个数组a，但是并没有将a初始化为一个真正的数组，我们应该使用new运算符创建数组： 1int[] a = new int[100]; 这里我们就创建了一个可以存储100个整型的数组，这里需要注意，数组的长度没有要求是一个常量，比如：new int[n]会创建一个长度为n的数组。 数组的下标从0开始，而不是1，比如我们要访问上文数组a中的元素的话，则下标范围需要0~99之间，如果使用了范围之外的下标，就会抛出一个数组越界异常（array index out of bounds）。我们如果想要知道当前数组的长度，可以使用array.length，比如： 1234//遍历数组的一种方式for (int i = 0;i &lt; a.length; i++) &#123; System.out.println(a[i])&#125; 当我们在创建一个数组的时候没有为这个数组初始化值，数字数组的所有元素会初始化为0，布尔数组的元素会初始化为false，对象数组的元素则被初始化为一个特殊值null，表示这些元素还没存放任何对象。一旦我们创建了一个数组，就不能改变它的大小。 数组的遍历可以使用上节中所讲的所有循环语句来进行遍历，其中最常用的是foreach，效率最高的是常规for循环。 数组初始化在Java中，提供了一种创建数组对象并同时赋予初始值的简化书写方式。如下所示： 1int[] smallPrimes = &#123;2, 3, 5, 7 ,11&#125;; 这里需要注意一点，如果在使用这种语句初始化一个数组的时候，不需要调用new。甚至我们可以使用这种方式初始化一个匿名的数组： 1new int[] &#123;17, 19, 23, 29, 31, 37&#125;; 这种表示法将创建一个新数组并利用括号中提供的值进行初始化，数组的大小就是初始值的个数。使用这种方式可以在不创建新变量的情况下重新初始化一个数组。例如： 1234smallPrices = new int[] &#123;17, 19, 23, 29, 31, 37&#125;;//简写如下：int[] anoymous = &#123;17, 19, 23, 29, 31, 37&#125;;smallPrices = anoymous; 在Java中，允许数组长度为0，但是这里需要注意一点，数组长度为0与null并不相同，不要将两者混淆。 数组拷贝在Java中，允许将一个数组变量拷贝给另一个数组变量。这时，两个变量将引用同一个数组，例如： 12int[] luckyNumbers = smallPrimes;luckyNumbers[5] = 12 //这时smallPrimes[5]也是12 如果希望将一个数组中的所有值拷贝到另外一个数组中去，可以使用Arrays类中的copyOf方法：1int[] copiedLuckyNumbers = Arrays.copyOf(luckyNumbers, luckyNumbers.length); 第2个参数是新数组的长度，如果新数组的长度大于原始数组的长度，根据原始数组的数据类型初始化为对应的初始值，如果新数组的长度小于原数组的长度，则会只拷贝最前面的数据元素。 命令行参数如果我们细心观察会发现，每一个Java程序都有一个带有String args[]参数的main方法，这个参数表示main方法将会接受一个字符串数组，也就是命令行参数。比如： 12345678910111213141516public class Message &#123; public static void main(String[] args) &#123; if (args.length == 0 || args[0].equals("-h")) &#123; System.out.println("Hello,"); &#125; else if (args[0].equals("-g"))&#123; System.out.println("GoodBye,"); &#125; for (int i = 1; i &lt; args.length; i++) &#123; System.out.println(" " + args[i]); &#125; System.out.println("!"); &#125;&#125; 如果我们在当前目录命令行分别输入java Message -g Vi-Young Space和java Message -h Vi-Young Space会分别输出以下结果： 123456789GoodBye, Vi-Young Space!Hello, Vi-Young Space! 数组排序要是想对数值型数组进行排序，我们可以使用Arrays类中的sort方法 123int[] a = new int[10000];...Arrays.sort(a); 这个方法使用了优化的快速排序算法。快速排序算法对于大多数数据集合来说都是效率比较高的。 Arrays-Api Tables Are Cool toString(T[] a) String 返回包含a中数据元素的字符串，这些数据元素被放在括号内，并用逗号分隔 copyOf(T[] a, int length) T[] 返回a类型相同的一个数组,参数length为拷贝的数组长度 copyOfRange(T[] a, int start,int end) T[] 返回与a类型相同的一个数组，数组从下标为start处开始拷贝，到end处（不包括end）截止 sort(T[] a) void 采用优化的快速排序算法对数组进行排序 binarySearch(T[] a, T v) int 采用二分查找法在a中寻找值v，如果查找成功，则返回相应的下标值，否则，返回一个负数值r。-r-1是为保持a有序v应插入的位置 binarySearch(T[] a, int start, int end, T v) int 采用二分查找法在a的start（包括）和end（不包括）之间寻找值v，如果查找成功，则返回相应的下标值，否则，返回一个负数值r。-r-1是为保持a有序v应插入的位置 fill(T a, T v) void 将数组的所有数据元素值设置为v equals(T a, T b) boolean 如果两个数组大小相同，且下标相同的元素都对应相等，返回true 下节预告类 公众号扫码或微信搜索Vi的技术博客，关注公众号，不定期送书活动各种福利~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 系列（五）：Number]]></title>
    <url>%2F2018%2F06%2F28%2FPython3-%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%94%EF%BC%89%EF%BC%9ANumber%2F</url>
    <content type="text"><![CDATA[前言在Python中，支持3种不同的数据类型： 整型（Int），通常被称为是整型或整数，是正或负整数，不带小数点。Python3 整型是没有限制大小的，可以当作 Long 类型使用，所以 Python3 没有 Python2 的 Long 类型。 浮点型（float），浮点型由整数部分与小数部分组成，浮点型也可以使用科学计数法表示（2.5e2 = 2.5 x 102 = 250） 复数（complex），复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型。 小数（Decimal），比起float拥有更高的精度。 分数（Fraction），由构造函数来实例化，ractions.Fraction(numerator, denominator)，其中 numerator为分子，denominator为分母。数字运算 Python 解释器可以作为一个简单的计算器，您可以在解释器里输入一个表达式，它将输出表达式的值。表达式的语法很直白： +, -, * 和 /, 和其它语言（如Pascal或C）里一样。例如： 12345678&gt;&gt;&gt; 2 + 24&gt;&gt;&gt; 50 - 5*620&gt;&gt;&gt; (50 - 5*6) / 45.0&gt;&gt;&gt; 8 / 5 # 总是返回一个浮点数1.6 这里，我们可以注意到Python中除法/总是返回的是一个浮点数，如果我们只想取到整数的结果，丢弃分数的部分，可以使用运算符//,计算余数的话可以使用%: 1234567&gt;&gt;&gt; 17 / 3 # 整数除法返回浮点型5.666666666666667&gt;&gt;&gt;&gt;&gt;&gt; 17 // 3 # 整数除法返回向下取整后的结果5&gt;&gt;&gt; 17 % 3 # 整数除法返回得到商之后，余数的结果2 这里需要注意一点，//得到的并不一定是整数类型的数，它与分母分子的数据类型有关 1234567&gt;&gt;&gt; 7//23&gt;&gt;&gt; 7.0//23.0&gt;&gt;&gt; 7//2.03.0&gt;&gt;&gt; Python中可以用**操作进行幂运算： 1234&gt;&gt;&gt; 5 ** 2 # 5 的平方25&gt;&gt;&gt; 2 ** 7 # 2的7次方128 等号( ‘=’ )用于给变量赋值。赋值之后，在下一个提示符之前不会有任何结果显示: 1234&gt;&gt;&gt; width = 20&gt;&gt;&gt; height = 5*9&gt;&gt;&gt; width * height900 变量在使用前必须 “定义”(赋值)，否则会出错: 12345&gt;&gt;&gt; # try to access an undefined variable... nTraceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;NameError: name 'n' is not defined 交互模式中，最近一个表达式的值赋给变量 _。这样我们就可以把它当作一个桌面计算器，很方便的用于连续计算，例如: 12345678&gt;&gt;&gt; tax = 12.5 / 100&gt;&gt;&gt; price = 100.50&gt;&gt;&gt; price * tax12.5625&gt;&gt;&gt; price + _113.0625&gt;&gt;&gt; round(_, 2)113.06 此变量对于用户是只读的。不要尝试给它赋值 —— 你只会创建一个独立的同名局部变量，它屏蔽了系统内置变量的魔术效果。 数学函数 函数 返回值 abs(x) 返回数字的绝对值，如abs(-10) 返回 10 ceil(x) 返回数字的上入整数，如math.ceil(4.1) 返回 5 exp(x) 返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045 fabs(x) 返回数字的绝对值，如math.fabs(-10) 返回10.0 floor(x) 返回数字的下舍整数，如math.floor(4.9)返回 4 log(x) 如math.log(math.e)返回1.0,math.log(100,10)返回2.0 log10(x) 返回以10为基数的x的对数，如math.log10(100)返回 2.0 max(x1, x2,...) 返回给定参数的最大值，参数可以为序列。 min(x1, x2,...) 返回给定参数的最小值，参数可以为序列。 modf(x) 返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。 pow(x, y) x**y 运算后的值。 round(x [,n]) 返回浮点数x的四舍五入值，如给出n值，则代表舍入到小数点后的位数。 sqrt(x) 返回数字x的平方根。 随机数函数随机数可以用于数学，游戏，安全等领域中，还经常被嵌入到算法中，用以提高算法效率，并提高程序的安全性。Python包含以下常用随机数函数： 函数 描述 choice(seq) 从序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。 randrange ([start,] stop [,step]) 从指定范围内，按指定基数递增的集合中获取一个随机数，基数缺省值为1 random() 随机生成下一个实数，它在[0,1)范围内。 seed([x]) 改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。 shuffle(lst) 将序列的所有元素随机排序 uniform(x, y) 随机生成下一个实数，它在[x,y]范围内。 randint(x,y) 随机生成下一个整数int类型，它在[x, y]范围之内 sample(sequence,length) 在某个序列中，随机的截取指定长度的片段，不改变原序列 三角函数Python包括以下三角函数： 函数 描述 acos(x) 返回x的反余弦弧度值。 asin(x) 返回x的反正弦弧度值。 atan(x) 返回x的反正切弧度值。 atan2(y, x) 返回给定的 X 及 Y 坐标值的反正切值。 cos(x) 返回x的弧度的余弦值。 hypot(x, y) 返回欧几里德范数 sqrt(x*x + y*y)。 sin(x) 返回的x弧度的正弦值。 tan(x) 返回x弧度的正切值。 degrees(x) 将弧度转换为角度,如degrees(math.pi/2) ， 返回90.0 radians(x) 将角度转换为弧度 数学常量 常量 描述 pi 数学常量 pi（圆周率，一般以π来表示） e 数学常量 e，e即自然常数（自然常数）。 关于round的一些看法“4舍6入5看齐,奇进偶不进”我觉得并不是因为浮点数在计算机表示的问题。计算机浮点数的表示是 ieee 定义的标准规则，如果 python 中存在，没道理其他语言中不存在。事实上是因为该取舍方法比过去的 “四舍五入” 方法在科学计算中更准确。而国家标准也已经规定使用 “4舍6入5看齐,奇进偶不进” 取代”四舍五入”. 从统计学的角度上来讲,如果大量数据无脑的采用四舍五入会造成统计结果偏大。而”奇进偶舍”可以将舍入误差降到最低。 奇进偶舍是一种比较精确比较科学的计数保留法，是一种数字修约规则。 其具体要求如下（以保留两位小数为例）： （1）要求保留位数的后一位如果是4或者4以下的数字，则舍去， 例如 5.214保留两位小数为5.21。 （2）如果保留位数的后一位如果是6或者6以上的数字，则进上去， 例如5.216保留两位小数为5.22。 （3）如果保留位数是保留整数部分或保留一位小数，则要根据保留位来决定奇进偶舍： 1234567891011121314151617&gt;&gt;&gt; round(5.215,2)#实际并没有进位5.21&gt;&gt;&gt; round(5.225,2)5.22&gt;&gt;&gt;&gt;&gt;&gt; round(1.5)#此处进位2&gt;&gt;&gt; round(1.5)==round(2.5)#偶数舍去True&gt;&gt;&gt; round(1.15,1)1.1&gt;&gt;&gt; round(1.25,1)1.2&gt;&gt;&gt; round(1.151,1)1.2&gt;&gt;&gt; round(1.251,1)1.3 (4) 如果保留位数的后一位如果是5，且该位数后有数字。则进上去，例如5.2152保留两位小数为5.22，5.2252保留两位小数为5.23，5.22500001保留两位小数为5.23。从统计学的角度，“奇进偶舍”比“四舍五入”要科学，在大量运算时，它使舍入后的结果误差的均值趋于零，而不是像四舍五入那样逢五就入，导致结果偏向大数，使得误差产生积累进而产生系统误差，“奇进偶舍”使测量结果受到舍入误差的影响降到最低。 下节预告Python中的字符串 公众号扫码或微信搜索Vi的技术博客，关注公众号，不定期送书活动各种福利~]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础专题（四）：控制流程]]></title>
    <url>%2F2018%2F06%2F28%2FJava%E5%9F%BA%E7%A1%80%E4%B8%93%E9%A2%98%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前言和其他程序设计语言一样，Java使用条件语句和循环结构确定控制流程，在介绍这些条件语句和循环结构之前，我们先来了解一下块作用域这个概念。 块作用域块（block，即复合语句）是指由一对大括号括起来的若干条简单的Java语句，块确定了变量的作用域。一个块可以嵌套在另一个块中。下面是在main方法块中嵌套另一个语句块的实例：12345678public static void main(String[] args) &#123; int n; ... &#123; int k; &#125; //变量k在此处无法使用&#125; 但是，不能在嵌套的两个块中声明同名的变量。比如：123456789public static void main(String[] args) &#123; int n; ... &#123; int k; int n; //错误，不能在这里定义n &#125; &#125; 条件语句在Java中，条件语句的格式为1if (condition) statement 这里的条件必须用括号括起来。在Java中，我们通常需要在条件为真的时候执行多条语句，在这种情况下，就需要使用到我们前面说到的块语句。条件语句格式变成如下：1234if (condition) &#123; statement1 statement2&#125; 有时，我们需要在条件为真的时候执行一组语句，当这个条件为假的时候，执行另一种语句，这是需要用到else。于是条件语句的更一般的写法变为:1234567if (condition) &#123; statement1 statement2&#125; else &#123; statement3 statement4&#125; 这里需要一点的是，else子句与最邻近的if构成一组，比如： 1if (x &lt;= 0) if (x == 0) sign = 0; else sign = -1 当然，这种写法在我们日常中很少见到，但是我们要知道这里的else是与第二个if配对的。写成如下就会显得很清晰： 1234567if (x &lt;= 0) &#123; if (x == 0) &#123; sign = 0; &#125; else &#123; sign = -1; &#125;&#125; 这里就体现了大括号和缩进的合理使用对于代码可读性的重要性。 while循环当条件为true的时候，while循环执行一条语句（或者一个语句块）。一般格式为： 1234while (condition) &#123; statement ...&#125; 当然，如果开始循环的时候条件就是false的话，该循环是一次也不会执行的。也正是因为while循环语句首先检测循环条件。因此，循环体中的代码有可能不被执行。如果希望循环体至少执行一次，应该把检测条件放到最后，这时我们的do…while语句就派上了用场，它的基本格式如下： 1do statement while (condition); for循环for循环语句是支持迭代的一种通用结构，利用每次迭代之后更新的计数器或者类似的变量来控制迭代次数。for语句的第1部分通常用于对计数器进行初始化，第2部分给出每次新一轮循环执行前要检测的循环条件，第3部分指示如何更新计数器。与C++一样，尽管Java允许在for循环的各个部分放置任何表达式，但是有一个不成文的约定俗成的规则：for语句的三个部分应该对同一个计数器变量进行初始化，检测和更新。这里需要注意一点，当你使用浮点数作为计数器时，很可能会出现一些奇奇怪怪的BUG，例如：1for (double x = 0; x != 10; x += 0.1) 这个循环永远也不会结束，由于舍入的误差，最终可能得不到精确值。例如，在上面的循环中，因为0.1无法用二进制精确的表示，所以，x将从9.9999999999998跳到10.0999999999998。 当在for语句的第1部分中声明了一个变量之后，这个变量的作用域就为for循环的整个循环体，如果在for语句中定义一个变量，这个变量就不能在循环体外使用。如果需要使用循环体中的变量数据，需要提前在循环外进行定义。 增强for循环Java有一种功能很强的循环结构，可以用来依次处理数组中的每一个元素而不必为指定下标值分心。这种增强的for循环的语句格式为：123for (variable : collection) &#123; statement&#125; 定义一个变量用于暂存集合中的每一个元素，并执行相应的语句（或语句块）。collection这一集合表达式必须是一个数组或者是一个实现了Iterable接口的类对象（比如ArrayList）。当然，实践中我们发现，增强for循环虽然简洁，但是无论是应用场景还是运行速率上来说，都是不如传统的for循环的。只是为我们程序员编码提供了一种更加简洁的方式~ 多重选择：switch语句在处理多个选项的时候，使用if/else就会略显笨拙，这时switch语句就发挥了他应有的作用，如下所示： 1234567891011switch (choice) &#123; case '1': ... break; case '2': ... break; default: ... break;&#125; switch语句将从与选项值相匹配的case标签处开始执行直到遇到break语句，或者执行到switch语句的结束处为止。如果没有相匹配的case标签，而有default子句，就执行这个子句。如果在case分支语句的末尾没有break语句，那么就会接着执行下一个case分支语句。这种情况称之为case穿透，一般来说，我们不希望看到这种情况的出现，所以，为了程序的安全起见，若不是非常必要的情况下，不要使用switch语句。 case标签可以是： 类型为char，byte，short或int的常量表达式 枚举常量 如果你的JDK版本是1.7以上，他还可以是字符串字面量 中断控制流程语句我们在使用的过程中，如果遇到需要中断一个流程的情况，通常会使用到以下两个关键字：break和continue，虽然goto是Java的保留字，但是我希望永远不要出现在Java中，无休止的使用goto会将一个程序弄得非常糟糕，无法阅读。 break 主要用在循环语句或者 switch 语句中，用来跳出整个语句块。break 跳出最里层的循环，并且继续执行该循环下面的语句。当然我们也可以使用标签的方式来跳出某个指定的循环。 123456read_data:while(...) &#123; for(...) &#123; break read_data; //这里就是直接跳出了while循环 &#125;&#125; continue 适用于任何循环控制结构中。作用是让程序立刻跳转到下一次循环的迭代。在 for 循环中，continue 语句使程序立即跳转到更新语句。在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句。当然，continue也有一种带标签的形式，将跳到与标签匹配的循环首部。用法和break一样，这里就不再举例说明。 公众号扫码或微信搜索Vi的技术博客，关注公众号，不定期送书活动各种福利~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 系列（四）：运算符]]></title>
    <url>%2F2018%2F06%2F28%2FPython3-%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[前言比如：4 +5 = 9 。 例子中，4 和 5 被称为操作数，”+” 称为运算符。Python语言包括以下九种运算符： 算术运算符 比较（关系）运算符 赋值运算符 逻辑运算符 位运算符 成员运算符 身份运算符 算术运算符Python具有以下六种算术运算符： 加（+），两个对象相加 减（-），得到负数或是一个数减去另一个数 乘（*），两个数相乘，或者将字符串重复若干次后返回 除（/），运算符左侧的操作数除以运算符右侧的操作数 取模（%），返回除法运算所得的余数 幂（**），返回的是运算符左侧操作数的右侧操作数次幂 取整除（//），返回除法运算的商的整数部分 以下是该运算符的一些实例： 12345678910111213141516171819202122232425262728293031323334353637383940# coding=utf-8# __author__ = 'Vi-Young'a = 7b = 6c = 5c = a + bprint("1 - c 的值为：", c)c = a - bprint("2 - c 的值为：", c)c = a * bprint("3 - c 的值为：", c)c = a / bprint("4 - c 的值为：", c)c = a % bprint("5 - c 的值为：", c)# 修改变量 a 、b 、ca = 4b = 3c = a ** bprint("6 - c 的值为：", c)a = 3b = 2c = a // bprint("7 - c 的值为：", c)a = 3.0b = 2.0c = a // bprint("7 - c 的值为：", c)``` 输出结果为： 1 - c 的值为： 132 - c 的值为： 13 - c 的值为： 424 - c 的值为： 1.16666666666666675 - c 的值为： 16 - c 的值为： 647 - c 的值为： 17 - c 的值为： 1.0123456789101112131415##### 比较运算符与其他语言类似，Python的比较运算符与Java，C并无太大区别，需要注意一点的是，所有比较运算符返回1表示真，返回0表示假。他们分别与特殊的变量True和False等价（这些变量首字母必须是大写！）Python具有以下六种比较运算符- 等于（=）比较运算符两侧对象是否相等- 不等于（!=）比较运算符两侧对象是否不相等- 大于（&gt;）返回运算符左侧操作数是否大于右侧操作数- 小于（&lt;）返回运算符左侧操作数是否小于右侧操作数- 大于等于（&gt;=）返回运算符左侧操作数是否大于等于右侧操作数- 小于等于（&lt;=）返回运算符左侧操作数是否小于等于于右侧操作数以下是该运算符的一些实例： coding=utf-8author = ‘Vi-Young’a = 21b = 10c = 0 if a != b: print(“2 - a 不等于 b”)zelse: print(“2 - a 等于 b”) if a &lt; b: print(“3 - a 小于 b”)else: print(“3 - a 大于等于 b”) if a &gt; b: print(“4 - a 大于 b”)else: print(“4 - a 小于等于 b”) 修改变量 a 和 b 的值a = 5;b = 20;if a &lt;= b: print(“5 - a 小于等于 b”)else: print(“5 - a 大于 b”) if b &gt;= a: print(“6 - b 大于等于 a”)else: print(“6 - b 小于 a”) 12输出结果： False1 - a 不等于 b2 - a 不等于 b3 - a 大于等于 b4 - a 大于 b5 - a 小于等于 b6 - b 大于等于 a123456789101112131415##### 赋值运算符Python中赋值运算符有以下八种：- 基础赋值运算符（=） 将运算符右侧操作数赋值给左侧变量- 加法赋值运算符（+=） 将运算符左侧变量加上右侧操作数后再赋值给左侧变量- 减法赋值运算符（-=） 将运算符左侧变量减去右侧操作数后再赋值给左侧变量- 乘法赋值运算符（*=） 将运算符左侧变量乘以右侧操作数后再赋值给左侧变量- 除法赋值运算符（/=） 将运算符左侧变量除以右侧操作数后再赋值给左侧变量- 取模赋值运算符（%=） 将运算符左侧变量取模右侧操作数后再赋值给左侧变量- 幂赋值运算符（**=） 将运算符左侧变量进行右侧操作数次幂后再赋值给左侧变量- 取整除赋值运算符（//+） 将运算符左侧变量对右侧操作数取整除后再赋值给左侧变量以下是该运算符的一些实例： coding=utf-8author = ‘Vi-Young’a = 15b = 10c = 0 c = a + bprint(“1 - c 的值为：”, c) c += aprint(“2 - c 的值为：”, c) c *= aprint(“3 - c 的值为：”, c) c /= aprint(“4 - c 的值为：”, c) c = 2c %= aprint(“5 - c 的值为：”, c) c **= aprint(“6 - c 的值为：”, c) c //= aprint(“7 - c 的值为：”, c) 12输出结果： 1 - c 的值为： 252 - c 的值为： 403 - c 的值为： 6004 - c 的值为： 40.05 - c 的值为： 26 - c 的值为： 327687 - c 的值为： 2184123456789101112131415##### 位运算符顾名思义，位运算符就是把数字转换成二进制之后，再按位进行相应的运算。Python中有六种位运算符：- 按位与运算符（&amp;），参与运算的操作数，对应位都为1时，结果为1，否则为0（ 同 1 则 1）- 按位或运算符（|），参与运算的操作数，对应位只要存在1，结果就是1，否则为0（有 1 则 1）- 按位异或运算符（^），参与运算的操作数，对应位不相同结果时为1，否则为0（不同为1）- 按位取反运算符（~），对数据的每位都进行取反，1变为0，0变为1（1变0，0变1）- 左移运算符（&lt;&lt;），运算数的二进制位全部左移若干位，高位舍弃，低位补0- 右移运算符（&gt;&gt;），运算数的二进制位全部右移若干位，低位丢弃，高位补0以下是该运算符的一些实例： #!/usr/bin/python3 a = 60 # 60 = 0011 1100b = 13 # 13 = 0000 1101c = 0 c = a &amp; b; # 12 = 0000 1100print (“1 - c 的值为：”, c) c = a | b; # 61 = 0011 1101print (“2 - c 的值为：”, c) c = a ^ b; # 49 = 0011 0001print (“3 - c 的值为：”, c) c = ~a; # -61 = 1100 0011print (“4 - c 的值为：”, c) c = a &lt;&lt; 2; # 240 = 1111 0000print (“5 - c 的值为：”, c) c = a &gt;&gt; 2; # 15 = 0000 1111print (“6 - c 的值为：”, c)12输出结果： 1 - c 的值为： 122 - c 的值为： 613 - c 的值为： 494 - c 的值为： -615 - c 的值为： 2406 - c 的值为： 1512345678910##### 逻辑运算符Python中逻辑运算符有以下三种：- 布尔“与”（and），例如：a and b，如果a为False，则返回False，否则返回b的计算值- 布尔“或”（or），例如：a or b，如果a为True，返回a的运算值，否则返回y的运算值- 布尔“非”（not），例如：not a,如果a为True，返回False，如果a为False，返回True以下是该运算符的一些实例： coding=utf-8author = ‘Vi-Young’!/usr/bin/python3a = 10b = 20 if a and b: print(“1 - 变量 a 和 b 都为 true”)else: print(“1 - 变量 a 和 b 有一个不为 true”) if a or b: print(“2 - 变量 a 和 b 都为 true，或其中一个变量为 true”)else: print(“2 - 变量 a 和 b 都不为 true”) 修改变量 a 的值a = 0if a and b: print(“3 - 变量 a 和 b 都为 true”)else: print(“3 - 变量 a 和 b 有一个不为 true”) if a or b: print(“4 - 变量 a 和 b 都为 true，或其中一个变量为 true”)else: print(“4 - 变量 a 和 b 都不为 true”) if not (a and b): print(“5 - 变量 a 和 b 都为 false，或其中一个变量为 false”)else: print(“5 - 变量 a 和 b 都为 true”)12输出结果： 1 - 变量 a 和 b 都为 true2 - 变量 a 和 b 都为 true，或其中一个变量为 true3 - 变量 a 和 b 有一个不为 true4 - 变量 a 和 b 都为 true，或其中一个变量为 true5 - 变量 a 和 b 都为 false，或其中一个变量为 false 123456789##### 成员运算符Python中的成员运算符包括以下两种：- in，如果在指定的序列中找到值返回True，否则返回False- not in，如果在指定的序列中没有找到值返回True，否则返回False下面是该运算符的一些实例： coding=utf-8author = ‘Vi-Young’!/usr/bin/python3a = 10b = 20testList = [1, 2, 3, 4, 5]; if a in testList: print(“1 - 变量 a 在给定的列表中 list 中”)else: print(“1 - 变量 a 不在给定的列表中 list 中”) if b not in testList: print(“2 - 变量 b 不在给定的列表中 list 中”)else: print(“2 - 变量 b 在给定的列表中 list 中”) 修改变量 a 的值a = 2if (a in testList): print(“3 - 变量 a 在给定的列表中 list 中”)else: print(“3 - 变量 a 不在给定的列表中 list 中”) 12输出结果： 1 - 变量 a 不在给定的列表中 list 中2 - 变量 b 不在给定的列表中 list 中3 - 变量 a 在给定的列表中 list 中 123456789##### 身份运算符Python的身份运算符包括以下两种：- is，is是判断两个标识符是不是引用自一个对象（后面会单独开一章说python中is和==的区别）- is not，is not是判断两个标识符是不是引用自不同对象下面是该运算符的一些实例： coding=utf-8author = ‘Vi-Young’!/usr/bin/python3a = 400 b = 400 if a is b: print(“1 - a 和 b 有相同的标识”)else: print(“1 - a 和 b 没有相同的标识”) if id(a) == id(b): print(“2 - a 和 b 有相同的标识”)else: print(“2 - a 和 b 没有相同的标识”) 修改变量 b 的值b = 30if a is b: print(“3 - a 和 b 有相同的标识”)else: print(“3 - a 和 b 没有相同的标识”) if a is not b: print(“4 - a 和 b 没有相同的标识”)else: print(“4 - a 和 b 有相同的标识”)12输出结果： 1 - a 和 b 有相同的标识2 - a 和 b 有相同的标识3 - a 和 b 没有相同的标识4 - a 和 b 没有相同的标识1234567891011121314151617181920##### 运算符优先级|运算符| 描述 | |:------------- |:-------------| |** |指数 (最高优先级) | |~，+，- | 按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@) | |*，/，%，//| 乘，除，取模和取整除| |+- | 加法减法| |‘&gt;&gt;’，&lt;&lt; |右移，左移运算符 | |&amp; | 位 'AND'| |或，异或| 位运算符| |&lt;=，&lt;，&gt;，&gt;= | 比较运算符| |&lt;&gt;，==，!=|等于运算符||=，%=，/=，//=，-=，+=，*=，**= | 赋值运算符| |is，is not|身份运算符 | |in，not in| 成员运算符||and，or，not|逻辑运算符| 下面是一些实例： a = 20b = 10c = 15d = 5e = 0 e = (a + b) c / d #( 30 15 ) / 5print (“(a + b) * c / d 运算结果为：”, e) e = ((a + b) c) / d # (30 15 ) / 5print (“((a + b) * c) / d 运算结果为：”, e) e = (a + b) (c / d); # (30) (15/5)print (“(a + b) * (c / d) 运算结果为：”, e) e = a + (b c) / d; # 20 + (150/5)print (“a + (b c) / d 运算结果为：”, e)12输出结果： (a + b) c / d 运算结果为： 90.0((a + b) c) / d 运算结果为： 90.0(a + b) (c / d) 运算结果为： 90.0a + (b c) / d 运算结果为： 50.0` 公众号扫码或微信搜索Vi的技术博客，关注公众号，不定期送书活动各种福利~]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 系列（三）：基本数据类型]]></title>
    <url>%2F2018%2F06%2F28%2FPython3-%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[前言：Python中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。 在Python中，变量就是变量，它没有类型，我们所说的”类型”是变量所指的内存中对象的类型。 Python 3 中有六个标准的数据类型： Numbers（数字） String（字符串） List（列表） Tuple（元组） Sets（集合） Dictionaries（字典） Python3 的六个标准数据类型中： 不可变数据（3个）：Number，String，Tuple 可变数据（3个）：List，Dictionary，Set Number（数字）Python3 支持int，float，bool，complex（复数）在Python 3里，只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。 像大多数语言一样，数值类型的赋值和计算都是很直观的。 type和isinstance内置的 type() 函数可以用来查询变量所指的对象类型。 123a, b, c, d = 20, 5.5, True, 4+3jprint(type(a), type(b), type(c), type(d)) 打印结果： 1&lt;class 'int'&gt; &lt;class 'float'&gt; &lt;class 'bool'&gt; &lt;class 'complex'&gt; 当然，你也可以选择使用instance来判断类型： 12a = 1print(isinstance(a, int)) 打印结果： 1True isinstance 和 type 的区别在于： 12345678910class A: passclass B(A): passprint(isinstance(A(), A))print((type(A()) == A))print(isinstance(B(), A))print((type(B()) == A)) 打印结果： 1234TrueTrueTrueFalse 由此可以看出这两者的区别在于： type()不会认为子类是一种父类类型 isinstance()会认为子类是一种父类类型 在 Python2 中是没有布尔型的，它用数字 0 表示 False，用 1 表示 True。到 Python3 中，把 True 和 False 定义成关键字了，但它们的值还是 1 和 0，它们可以和数字相加。 del函数当你指定一个值时，Number对象就会被创建： 12var1 = 1var2 = 10 如果我们不想使用该对象，可以使用del()删除一些对象的引用，del用法如下： 1del var1[, var2[,var3[...,varN]]]] 比如： 123456789var1 = 1;var2 = 10;var3 = [1, 2, 3, 4]del var1, var3[0]print(var2)print(var3)print(var1) 打印结果： 12345610[2, 3, 4]Traceback (most recent call last): File "C:/Users/18530/PycharmProjects/HelloWorld/helloworld.py", line 12, in &lt;module&gt; print(var1)NameError: name 'var1' is not defined 这里可以看到，var1变量被删除后，打印时会出错，而var3的第一个元素被删除后，只打印出了后三个元素。 数值运算直接上例子： 123456789101112131415var1 = 5 + 4 # 加法var2 = 4.3 - 2 # 减法var3 = 3 * 7 # 乘法var4 = 2 / 4 # 除法，得到一个浮点数var5 = 2 // 4 # 除法，得到一个整数var6 = 17 % 3 # 取余var7 = 2 ** 5 # 乘方print(var1)print(var2)print(var3)print(var4)print(var5)print(var6)print(var7) 打印结果： 123456792.3210.50232 注意： Python可以同时为多个变量赋值，如a, b = 1, 2。 一个变量可以通过赋值指向不同类型的对象。 数值的除法包含两个运算符：/ 返回一个浮点数，// 返回一个整数。 在混合计算时，Python会把整型转换成为浮点数。 数值类型实例： int float complex 10 0.0 3.14j 100 15.20 45.j -786 21.9 9.322e-36j 080 32.3e+18 .876j -0490 -90. -.6546+0J -0x260 -32.54e100 3e+26J 0x69 70.2E-12 4.53e-7j Python还支持复数，复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型 String（字符串）字符串在上次的基本语法中已经详细介绍过了，这里再补充几点： Python使用反斜杠转义特殊字符，如果你不想让反斜杠发生转移，可以在字符串前面添加一个r，表示原始字符 Python 没有单独的字符类型，一个字符就是长度为1的字符串。 字符串可以用+运算符连接在一起，用*运算符重复。 Python中的字符串有两种索引方式，从左往右以0开始，从右往左以-1开始。 Python中的字符串不能改变。 List（列表）List（列表） 是 Python 中使用最频繁的数据类型。 列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。 列表是写 [] 之间、用逗号分隔开的元素列表。 和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。 列表截取的语法格式如下： 1变量[头下标:尾下标] 索引值以 0 为开始值，-1 为从末尾的开始位置。 加号（+）是列表连接运算符，星号（*）是重复操作。如下实例： 1234567891011list1 = ['abcd', 786, 2.23, 'vi', 70.2]list2 = [123, 'vi']list3 = [list1, list2]print(list1) # 输出完整列表print(list1[0]) # 输出列表第一个元素print(list1[1:3]) # 从第二个开始输出到第三个元素print(list1[2:]) # 输出从第三个元素开始的所有元素print(list2 * 2) # 输出两次列表print(list1 + list2) # 连接列表print(list3) #输出列表元素为列表的列表 打印结果： 1234567['abcd', 786, 2.23, 'vi', 70.2]abcd[786, 2.23][2.23, 'vi', 70.2][123, 'vi', 123, 'vi']['abcd', 786, 2.23, 'vi', 70.2, 123, 'vi'][['abcd', 786, 2.23, 'vi', 70.2], [123, 'vi']] 与字符串不同，列表中的元素可以改变： 123456a = [1, 2, 3, 4, 5, 6]a[0] = 9a[2:5] = [13, 14, 15]print(a)a[2:5] = []print(a) 打印结果： 12[9, 2, 13, 14, 15, 6][9, 2, 6] 注意: List写在方括号之间，元素用逗号隔开。 和字符串一样，list可以被索引和切片。 List可以使用+操作符进行拼接。 List中的元素是可以改变的。 Tuple（元组）元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号 () 里，元素之间用逗号隔开。 元组中的元素类型也可以不相同： 12345678910111213list1 = [1, 2, 3]tuple1 = ('abcd', 786, 2.23, 'runoob', 70.2)tuple2 = (123, 'runoob')tuple3 = [list1, tuple1, tuple2]print(tuple1) # 输出完整元组print(tuple1[0]) # 输出元组的第一个元素print(tuple1[1:3]) # 输出从第二个元素开始到第三个元素print(tuple1[2:]) # 输出从第三个元素开始的所有元素print(tuple2 * 2) # 输出两次元组print(tuple1 + tuple2) # 连接元组print(tuple3) # 输出元组中元素为元组和列表的元组 输出结果： 1234567('abcd', 786, 2.23, 'runoob', 70.2)abcd(786, 2.23)(2.23, 'runoob', 70.2)(123, 'runoob', 123, 'runoob')('abcd', 786, 2.23, 'runoob', 70.2, 123, 'runoob')[[1, 2, 3], ('abcd', 786, 2.23, 'runoob', 70.2), (123, 'runoob')] 元组与字符串类似，可以被索引且下标索引从0开始，-1 为从末尾开始的位置。也可以进行截取（看上面，这里不再赘述）。 其实，可以把字符串看作一种特殊的元组。 1234tup = (1, 2, 3, 4, 5, 6)print(tup[0])print(tup[1:5])tup[0] = 11 # 修改元组元素的操作是非法的 打印结果： 1234561Traceback (most recent call last):(2, 3, 4, 5) File "C:/Users/18530/PycharmProjects/HelloWorld/helloworld.py", line 7, in &lt;module&gt; tup[0] = 11TypeError: 'tuple' object does not support item assignment 如上所示，如果试图修改tuple中的元素系统就会出错，虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。 构造包含 0 个或 1 个元素的元组比较特殊，所以有一些额外的语法规则： 12tup1 = () # 空元组tup2 = (20,) # 一个元素，需要在元素后添加逗号 注意： 与字符串一样，元组的元素不能修改。 元组也可以被索引和切片，方法一样。 注意构造包含0或1个元素的元组的特殊语法规则。 元组也可以使用+操作符进行拼接。 Set（集合）集合（set）是一个无序不重复元素的序列。 基本功能是进行成员关系测试和删除重复元素。 可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。 Example： 123456789101112131415161718192021222324student = &#123;'Tom', 'Jim', 'Mary', 'Tom', 'Jack', 'Rose'&#125;print(student) # 输出集合，重复的元素被自动去掉# 成员测试if ('Rose' in student): print('Rose 在集合中')else: print('Rose 不在集合中')# set可以进行集合运算a = set('abracadabra')b = set('alacazam')print(a)print(b)print(a - b) # a和b的差集print(a | b) # a和b的并集print(a &amp; b) # a和b的交集print(a ^ b) # a和b中不同时存在的元素 打印结果： 12345678&#123;'Tom', 'Mary', 'Rose', 'Jack', 'Jim'&#125;Rose 在集合中&#123;'d', 'a', 'c', 'r', 'b'&#125;&#123;'a', 'c', 'z', 'l', 'm'&#125;&#123;'d', 'r', 'b'&#125;&#123;'d', 'a', 'c', 'z', 'r', 'l', 'm', 'b'&#125;&#123;'a', 'c'&#125;&#123;'d', 'l', 'b', 'z', 'm', 'r'&#125; Dictionary（字典）字典（dictionary）是Python中另一个非常有用的内置数据类型。 列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。 字典是一种映射类型，字典用”{ }”标识，它是一个无序的键(key) : 值(value)对集合。 键(key)必须使用不可变类型。 在同一个字典中，键(key)必须是唯一的。 123456789101112dict1 = &#123;&#125;dict1['one'] = "Young"dict1[2] = "Vi"dict2 = &#123;'name': 'Vi_Young', 'code': 200, 'site': 'vi-young.com'&#125;print(dict1)print(dict1['one']) # 输出键为 'one' 的值print(dict1[2]) # 输出键为 2 的值print(dict2) # 输出完整的字典print(dict2.keys()) # 输出所有键print(dict2.values()) # 输出所有值 打印结果： 123456&#123;'one': 'Young', 2: 'Vi'&#125;YoungVi&#123;'name': 'Vi_Young', 'code': 200, 'site': 'vi-young.com'&#125;dict_keys(['name', 'code', 'site'])dict_values(['Vi_Young', 200, 'vi-young.com']) 构建函数dict()可以直接从键值对序列中构建字典如下： 1234567dict1 = dict([('Google', 1), ('Taobao', 2)])dict2 = &#123;x: x ** 2 for x in (2, 4, 6)&#125;dict3 = dict(Google=1, Taobao=2)print(dict1)print(dict2)print(dict3) 打印结果： 123&#123;'Google': 1, 'Taobao': 2&#125;&#123;2: 4, 4: 16, 6: 36&#125;&#123;'Google': 1, 'Taobao': 2&#125; 另外，字典类型也有一些内置的函数，例如clear()、keys()、values()等。 注意： 字典是一种映射类型，它的元素是键值对。 字典的关键字必须为不可变类型，且不能重复。 创建空字典使用 { }。 Python数据类型转换有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。 以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。 函数 描述 int(x [,base]) 将x转换为一个整数 float(x) 将x转换到一个浮点数 complex(real [,imag]) 创建一个复数 str(x) 将对象 x 转换为字符串 repr(x) 将对象 x 转换为表达式字符串 eval(str) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s) 将序列 s 转换为一个元组 list(s) 将序列 s 转换为一个列表 set(s) 转换为可变集合 dict(d) 创建一个字典。d 必须是一个序列 (key,value)元组。 frozenset(s) 转换为不可变集合 chr(x) 将一个整数转换为一个字符 ord(x) 将一个字符转换为它的整数值 hex(x) 将一个整数转换为一个十六进制字符串 oct(x) 将一个整数转换为一个八进制字符串 下节预告：运算符 公众号扫码或微信搜索Vi的技术博客，关注公众号，不定期送书活动各种福利~]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 系列（二）：语法]]></title>
    <url>%2F2018%2F06%2F27%2FPython3-%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[编码Python 3 源码文件在默认情况下以UTF-8编码，所有的字符串都是unicode字符串，当然，如果加上# coding=utf-8是最稳妥的选择，我们也可以给源码文件指定不同的编码：1# _*_ coding: cp-1252 -*- ps: cp-1252对应适合语言为保加利亚语、白罗斯语、马其顿语、俄语、塞尔维亚语。 标识符 第一个字符必须是字母或下划线_ 其他部分由字母，数字和下划线组成 严格区分大小写 首位：(a~z ，A~Z ，_ ) + 其他位：(a~z ，A~Z ，0-9 ，_ ) 保留字123456# coding=utf-8# __author__ = 'Vi-Young'import keywordprint(keyword.kwlist) 输出： 1['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'] 注释 单行注释 以#开头 12#第一个注释print("I Love Python!") #我爱python 多行注释 多个#号 使用’’’ 或 “”” 12345678910# 注释第一行# 注释第二行'''第一行注释第二行注释'''"""第一行注释第二行注释""" 行与缩进python最具特色的就是使用缩进来表示代码块，不需要使用大括号 {} 。缩进的空格数是可变的（这里一般要求缩进为四个空格，美观且规范），但是同一个代码块的语句必须包含相同的缩进空格数，否则就会抛出IndentationError这个错误 多行语句当我们遇到语句过长的情况时，可以使用反斜杠来实现多行语句 123number = a + \ b + \ c 当然，如果语句包含在[],{}或()时，不需要使用反斜杠 12number = ['a','b','c' 'd'] 数字类型python中数字由四种类型：整数，长整数，浮点数和复数 整数，如 1 长整数 是比较大的整数 浮点数 如 1.23，3E-2 复数 如 1 + 2j, 1.1 + 2.2j 字符串 python中单引号和双引号使用完全相同。 使用三引号(‘’’或”””)可以指定一个多行字符串。 转义符 ‘\’ 反斜杠可以用来转义，使用r可以让反斜杠不发生转义。。 如 r”this is a line with \n” 则\n会显示，并不是换行。 按字面意义级联字符串，如”this “ “is “ “string”会被自动转换为this is string。 字符串可以用 + 运算符连接在一起，用 * 运算符重复。 Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。 Python中的字符串不能改变。 Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。 字符串的截取的语法格式如下：变量[头下标:尾下标] 1234word = '词'sentence = "句"paragraph = """段，可以由多行组成""" Example: 1234567891011121314151617# coding=utf-8# __author__ = 'Vi-Young'str = 'Vi_Young'print(str) # 输出字符串print(str[0:-1]) # 输出第一个到倒数第二个的所有字符print(str[0]) # 输出字符串第一个字符print(str[2:5]) # 输出从第三个开始到第五个的字符print(str[2:]) # 输出从第三个开始的后的所有字符print(str * 2) # 输出字符串两次print(str + '你好') # 连接字符串print('------------------------------')print('hello\nrunoob') # 使用反斜杠(\)+n转义特殊字符print(r'hello\nrunoob') # 在字符串前面添加一个 r，表示原始字符串，不会发生转义 输出： 同一行显示多条语句如果想要在同一行中使用多条语句，可以使用分号将语句间隔开。 123#!/usr/bin/python3import sys; x = 'vi_young'; sys.stdout.write(x + '\n') 输出： 多个语句构成代码组缩进相同的一组语句构成一个代码块，我们称之为代码组。一般体现在控制流程的语句中。 123456if boolean: todoelif boolean: todoelse: todo import与from…import 在 python 用 import 或者 from…import 来导入相应的模块。 将整个模块(somemodule)导入，格式为： import somemodule 从某个模块中导入某个函数,格式为： from somemodule import somefunction 从某个模块中导入多个函数,格式为： from somemodule import firstfunc, secondfunc, thirdfunc 将某个模块中的全部函数导入，格式为： from somemodule import * 导入sys123456import sysprint('================Python import mode==========================');print ('命令行参数为:')for i in sys.argv: print (i)print ('\n python 路径为',sys.path) 导入sys模块的argv,path成员 1234from sys import argv,path # 导入特定的成员 print('================python from import===================================')print('path:',path) # 因为已经导入path成员，所以此处引用时不需要加sys.path 参考资料Python3 基础语法|菜鸟教程 Python3 基础语法|W3Cschool 下节预告基本数据类型~ 公众号扫码或微信搜索Vi的技术博客，关注公众号，不定期送书活动各种福利~]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 2.0 系列（四）：开发者工具]]></title>
    <url>%2F2018%2F06%2F27%2FSpring-Boot-2-0-%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[前言Spring Boot包括一组额外的工具，这些工具可以使应用程序开发体验变得更加愉快。spring-boot-devtools模块可以包含在任何项目中，以提供额外的开发时特性。如果要想支持devtools，要将模块依赖项添加到构建中，如以下Maven和Gradle清单所示: Maven1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt; Gradle 123dependencies &#123; compile("org.springframework.boot:spring-boot-devtools")&#125; 在运行完全打包的应用程序时，会自动禁用开发人员工具。如果您的应用程序是从java -jar启动的，或者是从一个特殊的类加载器开始的，那么它就被认为是一个“生产应用程序”。将Maven中的依赖项的optional设置为true或使用compileOnly在Gradle中，这样可以防止devtools被传递到其他使用的项目的模块中。 重新打包的archives默认不包含devtools。如果我们想使用某个远程devtools功能，我们需要禁用excludeDevtools 的build属性以包含它。Maven和Gradle插件都支持这个属性。 属性默认值Spring Boot支持的几个库使用缓存来提高性能。例如，模板引擎缓存已编译的模板，以避免重复解析模板文件。此外，Spring MVC可以在服务静态资源时向响应添加HTTP缓存头。 虽然缓存在生产中非常有用，但在开发过程中它可能会产生反作用，防止我们看到我们在应用程序中所做的更改。出于这个原因，spring-boot-devtools默认禁用缓存选项。 缓存选项通常由application.properties 文件配置。例如，Thymeleaf提供了spring.thymeleaf.cache属性。spring-boot-devtools模块不需要手动设置这些属性，而是自动应用合理的开发时配置。 有关devtools应用的属性的完整列表（默认配置）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@Order(Ordered.LOWEST_PRECEDENCE)public class DevToolsPropertyDefaultsPostProcessor implements EnvironmentPostProcessor &#123; private static final Map&lt;String, Object&gt; PROPERTIES; static &#123; Map&lt;String, Object&gt; devToolsProperties = new HashMap&lt;&gt;(); devToolsProperties.put("spring.thymeleaf.cache", "false"); devToolsProperties.put("spring.freemarker.cache", "false"); devToolsProperties.put("spring.groovy.template.cache", "false"); devToolsProperties.put("spring.mustache.cache", "false"); devToolsProperties.put("server.servlet.session.persistent", "true"); devToolsProperties.put("spring.h2.console.enabled", "true"); devToolsProperties.put("spring.resources.cache.period", "0"); devToolsProperties.put("spring.resources.chain.cache", "false"); devToolsProperties.put("spring.template.provider.cache", "false"); devToolsProperties.put("spring.mvc.log-resolved-exception", "true"); devToolsProperties.put("server.servlet.jsp.init-parameters.development", "true"); devToolsProperties.put("spring.reactor.stacktrace-mode.enabled", "true"); PROPERTIES = Collections.unmodifiableMap(devToolsProperties); &#125; @Override public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) &#123; if (isLocalApplication(environment) &amp;&amp; canAddProperties(environment)) &#123; PropertySource&lt;?&gt; propertySource = new MapPropertySource("refresh", PROPERTIES); environment.getPropertySources().addLast(propertySource); &#125; &#125; private boolean isLocalApplication(ConfigurableEnvironment environment) &#123; return environment.getPropertySources().get("remoteUrl") == null; &#125; private boolean canAddProperties(Environment environment) &#123; return isRestarterInitialized() || isRemoteRestartEnabled(environment); &#125; private boolean isRestarterInitialized() &#123; try &#123; Restarter restarter = Restarter.getInstance(); return (restarter != null &amp;&amp; restarter.getInitialUrls() != null); &#125; catch (Exception ex) &#123; return false; &#125; &#125; private boolean isRemoteRestartEnabled(Environment environment) &#123; return environment.containsProperty("spring.devtools.remote.secret"); &#125;&#125; 自动重启使用spring-boot-devtools的应用程序在类路径上的文件发生更改时自动重新启动。在IDE中工作时，这可能是一个有用的特性，因为它为代码更改提供了一个非常快速的反馈循环。默认情况下，指向文件夹的类路径中的任何条目都将受到监视，以查看是否有更改。注意，某些资源(如静态资源和视图模板)不需要重新启动应用程序。 由于DevTools监控类路径资源，触发重新启动的惟一方法是更新类路径。使类路径更新的方式取决于您使用的IDE。在Eclipse中，保存修改后的文件会更新类路径并触发重新启动。在IntelliJ IDEA中，构建项目(Build -&gt; Build project)也有着同样的效果。 只要启用了fork，您还可以通过使用受支持的构建插件(Maven和Gradle)启动应用程序，因为DevTools需要一个独立的应用程序类加载程序来正常运行。默认情况下，Gradle和Maven在类路径上检测DevTools时是这样做的。 自动重新启动在使用LiveReload时非常有效。如果您使用JRebel，自动重启被禁用，以支持动态类重载。其他devtools特性(如LiveReload和property overrides)仍然可以使用。 DevTools依赖于应用程序上下文的shutdown hook在重新启动时关闭它。如果禁用了shutdown hook(SpringApplication.setRegisterShutdownHook(false))，那么它就不能正常工作。 当决定类路径上的条目是否应该在更改时触发重新启动时，DevTools会自动忽略名为spring-boot、spring-boot-devtools 、spring-boot-autoconfigure、spring-boot-actuator和spring-boot-starter的项目。 DevTools需要自定义ApplicationContext使用的ResourceLoader。如果您的应用程序已经提供了一个，那么它将被包装。不支持在ApplicationContext上直接覆盖getResource方法。 热加载和热部署 Spring Boot提供的热部署技术使用两个类加载器。不改变的类(例如，来自第三方jar的类)被加载到一个基类加载器中。正在积极开发的类被加载到restart classloader中。当重新启动应用程序时，会丢弃restart classloader，并创建一个新的。这种方法意味着应用程序重新启动通常比“冷启动”快得多，因为基类加载程序已经可用并填充。 如果发现热部署对应用程序来说不够快，或者遇到了类加载问题，可以考虑热加载技术，如零周转期的JRebel。这些工作通过重写类，使它们更适合热加载。 PS：后面会出一期单章说明热加载和热部署的区别，以及在IntelliJ IDEA中的使用方式。 日志记录变化默认情况下，每次应用程序重新启动时，都会记录显示变化的报告。报告显示了应用程序自动配置的更改，如添加或删除bean和设置配置属性。 要禁用报告的日志记录，设置以下属性: 1spring.devtools.restart.log-condition-evaluation-delta=false 不包括的资源某些资源在更改时不一定需要触发重新启动。例如，可以就地编辑Thymeleaf模板。默认情况下，在/META-INF/maven、/META-INF/resources、/resources、/static、/public或/template中更改资源不会触发重新启动，但会触发实时重新加载。如果想自定义把这些排除，可以使用spring.devtools.restart.exclude属性。例如，仅排除/静态和/public，我们可以设置以下属性: 1spring.devtools.restart.exclude=static/**,public/** 如果您想保留这些默认值并添加额外的排除，可以使用spring.devtools.restart.additional- rejection属性。 监听更多的路径当我们对不在类路径上的文件进行更改时，我们可能希望应用程序重新启动或重新加载。为此，使用spring.devtools.restart.additional-paths属性配置其他路径以监视更改。我们可以使用前面描述的spring.devtools.restart.exclude属性来控制附加路径下的更改是触发完全重新启动还是实时重新加载。 禁用重启如果不想使用重启功能，可以使用spring.devtools.restart.enabled属性禁用它。在大多数情况下，我们可以在application.properties设置此属性(这样做仍然初始化重启类加载器，但它不注意文件的更改)。如果需要完全禁用重新启动支持(例如，因为它不能使用特定的库)，您需要在调用SpringApplication.run(…)之前将spring.devtools.restart.enabled System属性设置为false，如下面的示例所示: 1234public static void main(String[] args) &#123; System.setProperty("spring.devtools.restart.enabled", "false"); SpringApplication.run(MyApp.class, args);&#125; 使用触发器如果我们使用的IDE不断地编译已更改的文件，但是我们可能更希望只在特定的时间触发重新启动。为此，我们可以使用“trigger file”，这是一个特殊的文件，当我们希望实际触发重新启动检查时，必须对其进行修改。修改文件只会触发检查，只有在Devtools检测到它必须做一些事情时才会重新启动。触发器文件可以手动更新或使用IDE插件更新。 要使用触发器文件，请将spring.devtools.restart.trigger-file属性设置为触发器文件的路径。 自定义类加载器重启如前所述，在Restart vs Reload部分中，使用两个classloaders实现了Restart功能。对于大多数应用程序来说，这种方法运行良好。但是，它有时会导致类加载问题。默认情况下，IDE中的任何打开的项目都装载“重启”类加载器，任何常规的.jar文件都装载“基”类加载器。如果您正在处理一个多模块项目，并且不是每个模块都被导入到您的IDE中，那么您可能需要自定义一些东西。为此，您可以创建一个META-INF/spring-devtools.properties文件。 spring-devtools.properties文件可以包含以restart.exclude和restart.include为前缀的属性。include元素是应该被拉到“重启”类加载器中的项，而exclude元素则是应该被推入“基”类加载器的项。属性的值是应用于类路径的regex模式，如下面的示例所示: 12restart.exclude.companycommonlibs=/mycorp-common-[\\w-]+\.jarrestart.include.projectcommon=/mycorp-myproj-[\\w-]+\.jar 所有属性键必须是唯一的。它被认为是只要一个属性从restart.include或restart.exclude开始。 所有META-INF/spring-devtools.properties加载自类路径。我们可以在项目内部或项目所使用的库中打包文件。 已知限制通过使用标准的ObjectInputStream反序列化的对象，重新启动功能不能很好地工作。如果需要反序列化数据，可能需要结合使用Spring的ConfigurableObjectInputStream和Thread.currentThread().getcontextclassloader()。不幸的是，一些第三方库在不考虑上下文类加载器的情况下反序列化。如果发现这样的问题，我们需要向原始作者请求修复。 LiveReloadspring-boot-devtools模块包含一个嵌入式LiveReload服务器，当资源发生更改时，该服务器可用于触发浏览器刷新。LiveReload可以从livereload.com免费获得Chrome、Firefox和Safari浏览器扩展。 如果不希望在应用程序运行时启动LiveReload服务器，可以将spring.devtools.livereload.enabled属性设置为false。 一次只能运行一个LiveReload服务器。在启动应用程序之前，请确保没有其他LiveReload服务器正在运行。如果我们从IDE启动多个应用程序，只有第一个具有LiveReload支持。 全局设置您可以通过添加名为.spring-boot-devtools.properties的文件来配置全局devtools设置到$HOME文件夹(注意文件名以“.”开头)。任何添加到这个文件的属性都适用于使用devtools的计算机上的所有Spring Boot应用程序。例如，要配置restart始终使用触发器文件，需要添加以下属性: 123~/.spring-boot-devtools.properties. spring.devtools.reload.trigger-file=.reloadtrigger 远程应用Spring Boot developer工具不仅限于本地开发。在远程运行应用程序时，还可以使用几个特性。远程支持是可选的。要启用它，需要确保devtools包含在重新打包的归档文件中，如下所示: 1234567891011&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;excludeDevtools&gt;false&lt;/excludeDevtools&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 然后需要设置一个spring.devtools.remote.secret属性，如下面的示例所示: 1spring.devtools.remote.secret=mysecret 在远程应用程序上启用spring-boot-devtools存在安全风险。我们不应该在生产部署中启用支持。 远程devtools支持分为两部分:接受连接的服务器端端点和在IDE中运行的客户端应用程序。在设置好spring.devtools.remote.secret属性后，服务器组件将自动启用。必须手动启动客户端组件。 运行远程客户端应用程序远程客户端应用程序设计为在IDE中运行。我们需要运行org.springframe.boot.devtools.Remotespringapplication，其类路径与连接到的远程项目相同。应用程序的唯一必需参数是它连接的远程URL。 例如，如果我们正在使用Eclipse或STS，并且我们已经将一个名为my-app的项目部署到Cloud Foundry，那么您将执行以下操作: 从Run菜单中选择”Run Configuration…”。 创建一个新的Java应用程序“launch configuration”。 浏览my-app项目。 使用org.springframe.boot.devtools.remotespringapplication作为主类。 添加https://myapp.cfapps.io到程序参数(或任何远程URL)。 正在运行的远程客户端可能类似以下清单: 12345678910111213 . ____ _ __ _ _ /\\ / ___'_ __ _ _(_)_ __ __ _ ___ _ \ \ \ \( ( )\___ | '_ | '_| | '_ \/ _` | | _ \___ _ __ ___| |_ ___ \ \ \ \ \\/ ___)| |_)| | | | | || (_| []::::::[] / -_) ' \/ _ \ _/ -_) ) ) ) ) ' |____| .__|_| |_|_| |_\__, | |_|_\___|_|_|_\___/\__\___|/ / / / =========|_|==============|___/===================================/_/_/_/ :: Spring Boot Remote :: 2.0.3.RELEASE2015-06-10 18:25:06.632 INFO 14938 --- [ main] o.s.b.devtools.RemoteSpringApplication : Starting RemoteSpringApplication on pwmbp with PID 14938 (/Users/pwebb/projects/spring-boot/code/spring-boot-devtools/target/classes started by pwebb in /Users/pwebb/projects/spring-boot/code/spring-boot-samples/spring-boot-sample-devtools)2015-06-10 18:25:06.671 INFO 14938 --- [ main] s.c.a.AnnotationConfigApplicationContext : Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2a17b7b6: startup date [Wed Jun 10 18:25:06 PDT 2015]; root of context hierarchy2015-06-10 18:25:07.043 WARN 14938 --- [ main] o.s.b.d.r.c.RemoteClientConfiguration : The connection to http://localhost:8080 is insecure. You should use a URL starting with 'https://'.2015-06-10 18:25:07.074 INFO 14938 --- [ main] o.s.b.d.a.OptionalLiveReloadServer : LiveReload server is running on port 357292015-06-10 18:25:07.130 INFO 14938 --- [ main] o.s.b.devtools.RemoteSpringApplication : Started RemoteSpringApplication in 0.74 seconds (JVM running for 1.105) 因为远程客户端使用与实际应用程序相同的类路径，所以可以直接读取应用程序属性。这就是spring.devtools.remote.secret属性的读取方式，并将其传递给服务器进行身份验证。 通常建议使用https:// 作为连接协议，这样就可以加密通信，无法截获密码。 如果需要使用代理访问远程应用程序，请配置spring.devtools.remote.proxy.host和spring.devtools.remote.proxy.port属性。 远程更新远程客户端以与本地重启相同的方式监视应用程序类路径的更改。将任何更新的资源推到远程应用程序，并(如果需要)触发重新启动。如果您对使用本地没有的云服务的特性进行迭代，这将非常有用。通常，远程更新和重新启动要比完整的重新构建和部署周期快得多。 只有在远程客户端运行时才对文件进行监视。如果在启动远程客户端之前更改文件，则不会将其推到远程服务器。 公众号扫码或微信搜索Vi的技术博客，关注公众号，不定期送书活动各种福利~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 系列（一）：HelloWorld]]></title>
    <url>%2F2018%2F06%2F21%2FPython3-%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AHelloWorld%2F</url>
    <content type="text"><![CDATA[前言：本系列教程面向有一定编程基础的人，熟悉IDE的操作，有面向对象的基础更佳。 简介:Python是著名的“龟叔”Guido van Rossum在1989年圣诞节期间，为了打发无聊的圣诞节而编写的一个编程语言。龟叔给Python的定位是“优雅”、“明确”、“简单”，所以Python程序看上去总是简单易懂，初学者学Python，不但入门容易，而且将来深入下去，可以编写那些非常非常复杂的程序。总的来说，Python的哲学就是极简既极美。 应用场景： 网络应用（网站，后台服务） 小工具（爬虫） 缺点： 运行速度非常慢，因为Python是解释型语言，就是你的代码在运行的时候会一行一行的翻译成机器码，与C相比，这个效率要慢许多。（不过无伤大雅，用户基本无感） 代码不能加密，发布你的Python的程序的时候，实际上就是在公布你的源码。 安装： 下载地址 下载完成之后，双击打开，这里需要注意一点： 打开命令行窗口，输入python，结果如下所示： Pycharm下编写第一个HelloWorld Pycharm下载 破解 修改hosts文件 将 0.0.0.0 account.jetbrains.com 添加到hosts文件最后，注意hosts文件无后缀，如果遇到无法修改或权限问题，可以采用覆盖的方法去替换hosts文件 修改后请检查hosts文件是否修改，激活码无法激活的原因99.99%是因为hosts没有修改正确 Windows系统hosts文件路径为：c:\windows\system32\drivers\etc 复制激活码 打开PyCharm选择Activation code激活，然后复制下面的激活码点击激活。 1EB101IWSWD-eyJsaWNlbnNlSWQiOiJFQjEwMUlXU1dEIiwibGljZW5zZWVOYW1lIjoibGFuIHl1IiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IkZvciBlZHVjYXRpb25hbCB1c2Ugb25seSIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiSUkiLCJwYWlkVXBUbyI6IjIwMTgtMTAtMTQifSx7ImNvZGUiOiJSUzAiLCJwYWlkVXBUbyI6IjIwMTgtMTAtMTQifSx7ImNvZGUiOiJXUyIsInBhaWRVcFRvIjoiMjAxOC0xMC0xNCJ9LHsiY29kZSI6IlJEIiwicGFpZFVwVG8iOiIyMDE4LTEwLTE0In0seyJjb2RlIjoiUkMiLCJwYWlkVXBUbyI6IjIwMTgtMTAtMTQifSx7ImNvZGUiOiJEQyIsInBhaWRVcFRvIjoiMjAxOC0xMC0xNCJ9LHsiY29kZSI6IkRCIiwicGFpZFVwVG8iOiIyMDE4LTEwLTE0In0seyJjb2RlIjoiUk0iLCJwYWlkVXBUbyI6IjIwMTgtMTAtMTQifSx7ImNvZGUiOiJETSIsInBhaWRVcFRvIjoiMjAxOC0xMC0xNCJ9LHsiY29kZSI6IkFDIiwicGFpZFVwVG8iOiIyMDE4LTEwLTE0In0seyJjb2RlIjoiRFBOIiwicGFpZFVwVG8iOiIyMDE4LTEwLTE0In0seyJjb2RlIjoiUFMiLCJwYWlkVXBUbyI6IjIwMTgtMTAtMTQifSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjAxOC0xMC0xNCJ9LHsiY29kZSI6IlBDIiwicGFpZFVwVG8iOiIyMDE4LTEwLTE0In0seyJjb2RlIjoiUlNVIiwicGFpZFVwVG8iOiIyMDE4LTEwLTE0In1dLCJoYXNoIjoiNjk0NDAzMi8wIiwiZ3JhY2VQZXJpb2REYXlzIjowLCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-Gbb7jeR8JWOVxdUFaXfJzVU/O7c7xHQyaidCnhYLp7v32zdeXiHUU7vlrrm5y9ZX0lmQk3plCCsW+phrC9gGAPd6WDKhkal10qVNg0larCR2tQ3u8jfv1t2JAvWrMOJfFG9kKsJuw1P4TozZ/E7Qvj1cupf/rldhoOmaXMyABxNN1af1RV3bVhe4FFZe0p7xlIJF/ctZkFK62HYmh8V3AyhUNTzrvK2k+t/tlDJz2LnW7nYttBLHld8LabPlEEjpTHswhzlthzhVqALIgvF0uNbIJ5Uwpb7NqR4U/2ob0Z+FIcRpFUIAHEAw+RLGwkCge5DyZKfx+RoRJ/In4q/UpA==-MIIEPjCCAiagAwIBAgIBBTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE1MTEwMjA4MjE0OFoXDTE4MTEwMTA4MjE0OFowETEPMA0GA1UEAwwGcHJvZDN5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQC9WZuYgQedSuOc5TOUSrRigMw4/+wuC5EtZBfvdl4HT/8vzMW/oUlIP4YCvA0XKyBaCJ2iX+ZCDKoPfiYXiaSiH+HxAPV6J79vvouxKrWg2XV6ShFtPLP+0gPdGq3x9R3+kJbmAm8w+FOdlWqAfJrLvpzMGNeDU14YGXiZ9bVzmIQbwrBA+c/F4tlK/DV07dsNExihqFoibnqDiVNTGombaU2dDup2gwKdL81ua8EIcGNExHe82kjF4zwfadHk3bQVvbfdAwxcDy4xBjs3L4raPLU3yenSzr/OEur1+jfOxnQSmEcMXKXgrAQ9U55gwjcOFKrgOxEdek/Sk1VfOjvS+nuM4eyEruFMfaZHzoQiuw4IqgGc45ohFH0UUyjYcuFxxDSU9lMCv8qdHKm+wnPRb0l9l5vXsCBDuhAGYD6ss+Ga+aDY6f/qXZuUCEUOH3QUNbbCUlviSz6+GiRnt1kA9N2Qachl+2yBfaqUqr8h7Z2gsx5LcIf5kYNsqJ0GavXTVyWh7PYiKX4bs354ZQLUwwa/cG++2+wNWP+HtBhVxMRNTdVhSm38AknZlD+PTAsWGu9GyLmhti2EnVwGybSD2Dxmhxk3IPCkhKAK+pl0eWYGZWG3tJ9mZ7SowcXLWDFAk0lRJnKGFMTggrWjV8GYpw5bq23VmIqqDLgkNzuoog== 开始编写 打开Pycharm，点击 Create new project 新建一个HelloWorld的项目 目录结构如下（关于venv虚拟环境会在后面单独讲解） 新建文件 文件内容 启动项目，展示成果 HelloWorld至此就大功告成了~ 下节预告:下节我们来一起学习Python的基础语法~ 公众号扫码或微信搜索Vi的技术博客，关注公众号，不定期送书活动各种福利~]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础专题（三）：字符串]]></title>
    <url>%2F2018%2F06%2F18%2FJava%E5%9F%BA%E7%A1%80%E4%B8%93%E9%A2%98%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[前言从概念上来讲，Java字符串就是Unicode字符序列。例如，”Java\u2122” 由5个Unicode字符J，a，v，a，和 ™。Java没有内置的字符串类型，而是在标准Java类库中提供了一个预定义类，叫做String。每个用双引号括起来的字符串都是String类的一个实例。 子串String类的substring方法可以从一个较大的字符串提取出一个子串。例如：12String greeting = "Hello"String s = greeting.substring(0,3) // s = "Hel" substring方法的第二个参数是不想复制的第一个位置。这里要复制位置为0，1和2（从0到2，包括0和2）的字符。在substring中从0开始计数，直到3为止，但不包括3。substring有一个优点：容易计算字串的长度。即substring（a,b）的长度为b-a。例如，子串“Hel”的长度为3-0=3 拼接与绝大多数的程序设计语言一样，Java语言允许使用 + 号连接（拼接）两个字符串。 123String expletive = "Expletive"String PG13 = "deleted"String message = expletive + PG13 // message = "Expletivedeleted" 当将一个字符串与一个非字符串的值进行拼接时，后者被转换成字符串。 12int age = 13;String rating = "PG" + age; //rating为 PG13 如果需要将多个字符串连接在一起，并用定界符分离，可以使用静态join方法 12String size = String.join(" / ", "S", "M", "L", "XL"); //size = "S / M / L / XL" 不可变字符串由于不能修改Java字符串中的字符，所以在Java文档中将String类对象称为不可变字符串，如同数字3永远是数字3一样，字符串“Hello”永远包含字符 H，e，l，l 和 o 的代码单元序列，而不能修改戏中的任何一个字符。当然，可以修改字符串变量，让它引用另一个字符串。 不可变字符串的优点是：编译器可以让字符串共享，即各种字符串存储在公共的存储池中，字符串变量值相存储池中相应的位置，如果复制一个字符串变量，原始字符串与复制的字符串共享相同的字符。 Java的设计者认为共享所带来的高效率远远胜于提取，拼接字符串所带来的低效率，因为我们很少需要修改字符串，更多的，我们是对字符串进行比较。 检测字符串是否相等可以使用equals方法判断两个字符串是否相等，对于表达式：1s.equals(t) 如果字符串 s 与字符串 t 相等，则返回true；否则，返回false。需要注意，s和t可以是字符串变量，也可以是字符串字面量。如果要想检测两个字符串是否相等，而不区分大小写，可以使用equalsIgnoreCase方法。 1"Hello".equalsIgnoreCase("hello") // true 一定不要使用==运算符检测两个字符串是否相等！！！这个运算符只能确定两个字符串是否放在同一个位置上，当然，如果字符串放置在同一个位置上，他们必然相等。但是，完全有可能将内容相同的多个字符串的拷贝放在不同的位置上。 123String greeting = "hello";if (greeting == "hello") // trueif (greeting.substring(0,3) == "hel") // false 因为只有字符串常量是共享的，而 + 或substring产生的结果并不是共享的。所以千万不要用 == 运算符测试字符串的相等性！ 空串与null串空串 “” 是长度为0的字符串。可以调用以下代码检查一个字符串是否为空：1if (str.length() == 0) 或1if (str.equals("")) 空串是一个Java对象，有自己的串长度（0）和内容（空）。不过，String变量还可以存放一个特殊的值，名为null，这表示目前没有任何对象与该变量关联 常用String API char charAt (int index)返回给定位置的代码单元。除非对底层的代码单元感兴趣，否则不需要调用这个方法。 int compareTo(String other)按照字典顺序，如果字符串位于other之前，返回一个负数；如果字符串位于other之后，返回一个正数；如果两个字符串相等，返回0 boolean equals(Object other)如果字符串与other相等，返回true boolean equalsIgnoreCase(String other)如果字符串与other相等（忽略大小写），返回true boolean startWith(String prefix) boolean endWith(String suffix)如果字符串以prefix（suffix）开头（结尾），则返回true int indexOf(String str) int indexOf(String str, int fromIndex) int indexOf(int cp) int indexOf(int cp, int fromIndex)返回与字符串str或代码点cp匹配的第一个子串的开始位置。这个位置从索引0或fromIndex开始计算。如果原始串中不存在str，返回-1 int lastIndexOf(String str) int lastIndexOf(String str, int fromIndex) int lastIndexOf(int cp) int lastIndexOf(int cp, int fromIndex)返回与字符串str或代码点cp匹配的最后一个子串的位置。这个位置从原始串尾端或fromIndex开始计算 int length()返回字符串的长度 String replace(CharSequence oldString, CharSequence newString)返回一个新字符串，这个字符串用newString代替原始字符串中的所有oldString。可以用String或StringBuilder对象作为CharSequence参数 String substring(int beginIndex) String substring(int beginIndex, int endIndex)返回一个新字符串。这个字符串包含原始字符串中从beginIndex到串尾或endIndex - 1的所有代码单元 String toLowerCase() String toUpperCase()返回一个新字符串，这个字符串将原始字符串中的大写字母改为小写，或者将原始字符串中的所有小写字母改成了大写字母。 String trim()返回一个新字符串，这个字符串将删除了原始字符串头部和尾部的空格。 String join(CharSequence delimiter, CharSequence…elements)返回一个新字符串，用给定的定界符连接所有元素。 参考资料Core Java Volume Ⅰ-Fundamentals 下期预告控制流程：块作用域，条件语句，循环，等等~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 2.0 系列（三）：流程详解（下）]]></title>
    <url>%2F2018%2F06%2F11%2FSpring-Boot-2-0-%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[自动配置Spring Boot自动配置尝试根据添加的jar依赖项自动配置Spring应用程序。例如，如果HSQLDB在我们的类路径上，并且我们没有手动配置任何数据库连接bean，那么Spring Boot将自动配置内存中的数据库。我们如果需要选择加入到自动配置可以通过将@EnableAutoConfiguration或@SpringBootApplication注释添加到我们的@Configuration类中。 我们应该只添加一个@SpringBootApplication或@EnableAutoConfiguration注释。我们通常建议只将一个或另一个添加到 @Configuration 主类中。 自定义自动配置自动配置具有良好的非侵入性。在任何时候，我们都可以开始定义自己的配置，以替换自动配置的特定部分。例如，如果我们添加自己的数据源bean，默认的嵌入式数据库支持就会退居幕后,而采用我们所配置的数据源bean。如果我们需要了解当前正在应用的自动配置，以及为什么要使用这些配置，可以使用--debug开关启动应用程序。这样做可以为核心日志记录器的选择提供调试日志，并将条件报告记录到控制台。 禁用特定类的自动配置如果我们发现我们不希望的特定自动配置类被应用，我们可以使用@EnableAutoConfiguration的排除属性来禁用它们，如下面的示例所示: 12345678import org.springframework.boot.autoconfigure.*;import org.springframework.boot.autoconfigure.jdbc.*;import org.springframework.context.annotation.*;@Configuration@EnableAutoConfiguration(exclude=&#123;DataSourceAutoConfiguration.class&#125;)public class MyConfiguration &#123;&#125; 如果类不在类路径上，则可以使用注释的 excludeName 属性并指定完全限定的名称。最后，我们还可以通过使用spring.autoconfigure.exclude排除属性来控制自动配置类的列表。 我们可以在注释级别和通过使用属性定义排除。 Spring bean和依赖项注入我们可以自由地使用任何标准Spring框架技术来定义bean及其注入的依赖项。为了简单起见，我们经常发现使用@ComponentScan(查找bean)和使用@Autowired(进行构造函数注入)非常有效。如果我们按照上面的建议构造代码(将应用程序类定位到根包中)，我们可以添加@ComponentScan，而不需要任何参数。所有应用程序组件(@Component， @Service， @Repository， @Controller等)都自动注册为Spring bean。下面的示例显示了一个@Service Bean： 12345678910111213141516import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class DatabaseAccountService implements AccountService &#123; private final RiskAssessor riskAssessor; @Autowired public DatabaseAccountService(RiskAssessor riskAssessor) &#123; this.riskAssessor = riskAssessor; &#125; // ...&#125; 如果一个bean有一个构造函数，可以省略@Autowired，如下面的示例所示: 123456789101112@Servicepublic class DatabaseAccountService implements AccountService &#123; private final RiskAssessor riskAssessor; public DatabaseAccountService(RiskAssessor riskAssessor) &#123; this.riskAssessor = riskAssessor; &#125; // ...&#125; 注意：如何使用构造函数注入让riskAssessor字段被标记为final，表明它不能随后更改。 使用@SpringBootApplication注解许多Spring Boot开发人员喜欢他们的应用程序使用自动配置、组件扫描并能够在“application class”上定义额外的配置。可以使用一个@SpringBootApplication注释来启用这三个特性，即:@EnableAutoConfiguration:启用Spring Boot的自动配置机制@ComponentScan:在应用程序所在的包上启用@Component扫描@Configuration:允许在上下文中注册额外的bean或导入额外的配置类@SpringBootApplication注释相当于使用@Configuration、@EnableAutoConfiguration和@ComponentScan的默认属性，如下面的示例所示: 1234567891011import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication // same as @Configuration @EnableAutoConfiguration @ComponentScanpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; @SpringBootApplication还提供别名来定制@EnableAutoConfiguration和@ComponentScan的属性。 这些特性中没有一个是强制性的，我们可以选择使用它支持的任何特性来替换这个单一注释。例如，我们可能不想在应用程序中使用组件扫描: 12345678910111213141516import org.springframework.boot.SpringApplication;import org.springframework.context.annotation.ComponentScanimport org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Import;@Configuration@EnableAutoConfiguration@Import(&#123; MyConfig.class, MyAnotherConfig.class &#125;)public class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 在本例中，应用程序与任何其他Spring Boot应用程序一样，只是不会自动检测到@component - anno类，并且显式地导入用户定义的bean(根据@Import)。 运行应用将应用程序打包为jar并使用嵌入式HTTP服务器的最大好处之一是，可以像运行其他应用程序一样运行应用程序。调试SpringBoot应用程序也很容易。我们不需要任何特殊的IDE插件或扩展。 本节只讨论基于jar的打包。如果我们选择将应用程序打包为war文件，我们应该参考服务器和IDE文档。 通过IDE启动我们可以将IDE中的SpringBoot应用程序作为一个简单的Java应用程序运行。但是，我们首先需要导入项目。导入步骤取决于我们的IDE和构建系统。大多数ide都可以直接导入Maven项目。如果我们不能直接将项目导入IDE，那么我们可以使用build插件生成IDE元数据。Maven包含Eclipse和IDEA的插件。Gradle提供各种ide的插件。 如果我们不小心运行了两次web应用程序，我们会看到一个“已经使用的端口”错误。STS用户可以使用Relaunch按钮而不是Run按钮来确保关闭任何现有实例。 作为打包的应用程序运行如果我们使用Spring Boot Maven或Gradle插件来创建可执行jar，我们可以使用java -jar来运行应用程序，如下例所示: 1$ java -jar target/myapplication-0.0.1-SNAPSHOT.jar 还可以运行支持远程调试的打包应用程序。这样做可以将调试器附加到打包的应用程序中，如下例所示: 12$ java -Xdebug -Xrunjdwp:server=y,transport=dt_socket,address=8000,suspend=n \ -jar target/myapplication-0.0.1-SNAPSHOT.jar 使用Maven插件Spring Boot Maven插件包含一个可以用来快速编译和运行应用程序的运行目标。应用程序迅速运行，就像它们在IDE中一样。下面的示例显示了运行Spring引导应用程序的典型Maven命令: 1$ mvn spring-boot:run 我们可能还想使用MAVEN_OPTS操作系统环境变量，如下面的示例所示: 1$ export MAVEN_OPTS=-Xmx1024m 使用Gradle插件Spring Boot Gradle插件还包含一个bootRun任务，该任务可用于迅速运行应用程序。每当应用org.springframework时，都会添加bootRun任务。引导和java插件，如下例所示: 1$ gradle bootRun 我们可能还想使用JAVA_OPTS操作系统环境变量，如下例所示: 1$ export JAVA_OPTS=-Xmx1024m ####下节预告： 详细介绍基于Spring Boot的热加载~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础专题（二）：运算符]]></title>
    <url>%2F2018%2F06%2F04%2FJava%E5%9F%BA%E7%A1%80%E4%B8%93%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[前言计算机的最基本用途之一就是执行数学运算，作为一门计算机语言，Java也提供了一套丰富的运算符来操纵变量。我们可以把运算符分成以下几组： 算术运算符 关系运算符 位运算符 逻辑运算符 赋值运算符 其他运算符 算术运算符算术运算符的运算结果为整型值或者浮点值 算术运算符如下表所示： 设 a = 1 , b = 2 运算符 描述 例子 + 将运算符两侧数值相加 a + b = 3 - 将运算符左侧数值减去右侧数值 a - b = -1 * 将运算符两侧数值相乘 a * b = 2 / 将运算符左侧数值除以右侧数值 b / a = 2 % 运算符左侧除以右侧的余数 b % a = 0 ++ 自增，当前数值 +1 b++， b = 3 – 自减，当前数值 -1 b–， b = 1 注意：自增和自减有两种形态：”前缀“和”后缀“，当单独使用的时候，两者并无区别，都是使当前操作的数值 +1 或 -1 ，但是当在表达式中使用的时候，二者就不太一样了，前缀形式会先完成 + 1；而后缀形式则会采用变量原来的值。 1234int m = 7;int n = 7;int a = 2 * ++m; // a = 16, m = 8int b = 2 * n++ // b = 14, n = 7 关系运算符关系运算符的结果为布尔值（ true / false）设 a = 1，b = 2 运算符 描述 例子 == 运算符两侧数值是否相等，如果相等结果为true a == b 为 false != 运算符两侧数值是否不相等，如果不相等结果为true a != b 为 true &gt; 运算符左侧的数值大于右侧，结果为true b &gt; a 为true &lt; 运算符左侧的数值小于右侧，结果为true a &lt; b 为true &gt;= 运算符左侧的数值大于等于右侧，结果为true b &gt;= a 为 true &lt;= 运算符左侧的数值小于等于右侧，结果为true a &lt;= b 为true 位运算符Java定义了位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。 位运算符作用在所有的位上，并且按位运算。假设a = 60，b = 13;它们的二进制格式表示将如下： 1234567a = 0011 1100b = 0000 1101a &amp; b = 0000 1100a | b = 0011 1101a ^ b = 0011 0001~a = 1100 0011 运算规则如下： 操作符 描述 例子 &amp; 同1为1 ，否则为0 a &amp; b = 0000 1100 丨 同0为0 ，否则为1 a 丨b = 0011 1101 ^ 相同为0，否则为1 a ^ b = 0011 0001 ~ 按位取反 ~a 即 1100 0011 &lt;&lt; 按位左移运算符。左操作数按位左移右操作数指定的位数。 a &lt;&lt; 2 即 1111 0000 >&gt; 按位右移运算符。左操作数按位右移右操作数指定的位数。 a &gt;&gt; 2 即 1111 >>&gt; 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。 a &gt;&gt;&gt;2 即 0000 1111 逻辑运算符a 为 true，b 为 false 操作符 描述 例子 &amp;&amp; 逻辑与运算符。当且仅当两个操作数都为真，条件才为真。 a &amp;&amp; b 为 false 丨丨 逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。 a 丨丨 b 为真 ! 逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。 ！（a &amp;&amp; b）为真。 注意：&amp;&amp; 和 || 具有短路的特性，也就是当第一个条件可以判断最终结果的时候，就不会去判断第二个条件。 赋值运算符 操作符 描述 例子 = 基础的赋值运算符，将右边的值赋给左边 c = a + b 就是将 a + b 的值赋给 c +(-，*，/，%，&lt;&lt;, &gt;&gt; ,&amp; ,^, )= 运算符左侧数值和右侧数值进行对应操作后赋给左侧 例如c += a 等价于 c = c + a 条件运算符（？：）条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。 12345678int a , b; a = 10; // 如果 a 等于 1 成立，则设置 b 为 20，否则为 30 b = (a == 1) ? 20 : 30; System.out.println( "Value of b is : " + b ); // 如果 a 等于 10 成立，则设置 b 为 20，否则为 30 b = (a == 10) ? 20 : 30; System.out.println( "Value of b is : " + b ); 123运算结果如下：Value of b is : 30Value of b is : 20 instanceof 运算符该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。 instanceof运算符使用格式如下： 123Vehicle a = new Car();boolean result = a instanceof Car;System.out.println( result); 结果如下：1true Java运算符优先级最高优先级的在该表上方，最低优先级的在该表底部 类别 操作符 关联性 后缀 （）[].(点操作符) 左到右 一元 ++ - ！~ 右到左 乘性 * / % 左到右 加性 + - 左到右 移位 >> >>> &lt;&lt; 左到右 关系 > >= = &lt; &lt;= 左到右 相等 == ~= 左到右 按位与 &amp; 左到右 按位异或 ^ 左到右 按位或 \丨 左到右 逻辑与 &amp;&amp; 左到右 逻辑或 丨丨 左到右 条件 ？： 从右到左 赋值 =，+=，-=，等等 从右到左 逗号 ， 左到右 参考资料Java运算符|菜鸟驿站 Core Java Volume Ⅰ-Fundamentals 下期预告下一期我们来聊一下关于字符串的前世今生~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 2.0 系列（二）：流程详解（上）]]></title>
    <url>%2F2018%2F06%2F01%2FSpringBoot-2-0-%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面本节将详细介绍如何使用Spring Boot。它涵盖了诸如项目管理及自动构建工具、自动配置以及如何运行应用程序等主题。我们还介绍了一些Spring Boot最佳实践。Spring Boot没有什么特别之处(它只是另一个我们可以使用的库)，但是有一些约定俗成的建议（“习惯优于配置”），如果遵循这些建议，将使我们的开发过程变得更容易一些。 项目管理及自动构建工具强烈建议您选择一个支持依赖项管理的构建系统，我们可以使用该系统得到发布到Maven中心仓库的组件。这里建议选择Maven或Gradle。虽然Spring Boot可以与其他构建系统(例如Ant)一起工作，但是它们并没有得到很好的支持。 1. 依赖关系管理Spring Boot的每一个版本都提供了它所支持的一个被整理的依赖项列表。实际上，我们不需要为构建配置中的任何依赖项提供版本，因为Spring Boot会为我们管理这些依赖项，当我们升级Spring Boot的时候，这些依赖项也会以一致的方式升级。 当然如果需要，我们仍然可以指定一个版本并覆盖Spring Boot的默认项。 Spring引导的每个版本都与Spring框架的一个基本版本相关联。我们强烈建议您不要指定它的版本。 2. MavenMaven用户可以从spring-boot-starter-parent项目继承来获得合理的默认值。parent项目提供以下特性: Java 1.8作为默认的编译器级别。 UTF - 8编码。 一个继承自spring-boot-dependencies pom的依赖管理部分，管理通用依赖项的版本。这个依赖项管理可以在自己的pom中使用这些依赖项时省略&lt; version&gt;标记。 合理的插件配置(exec插件，Git commit ID和shade)。 合理的资源过滤（例如：application.properties和application.yml）。包含特定于概要文件的文件（例如：application-dev.properties和application-dev.yml） 2.1 继承 Parent POM如果需要将项目配置为从spring-boot-starter-parent继承，请将 parent 设置为: 123456&lt;!-- Inherit defaults from Spring Boot --&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt;&lt;/parent&gt; 我们应该仅在此依赖项上指定Spring Boot版本号。如果我们导入其他starter，我们可以放心地省略版本号。 通过这种设置，我们还可以通过在自己的项目中覆盖属性来覆盖各个依赖项。例如，要升级到另一个Spring-Data release系列，我们可以在我们的pom.xml中添加以下内容: 123&lt;properties&gt; &lt;spring-data-releasetrain.version&gt;Fowler-SR2&lt;/spring-data-releasetrain.version&gt;&lt;/properties&gt; 2.2 不继承Parent POM不是每个人都喜欢从spring-boot-starter那里继承。我们可能需要使用您自己的企业标准parent，或者我们可能希望显式声明所有的Maven配置。如果我们不想使用spring-boot-starter-parent，我们仍然可以通过使用scope=import dependency来保持依赖关系管理(而不是插件管理)的好处，如下所示: 123456789101112&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;!-- Import dependency management from Spring Boot --&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 前面的示例设置不允许我们通过使用属性来覆盖各个依赖项，如上所述。要实现相同的结果，我们需要在spring-boot-dependencies条目之前在我们的项目的依赖项管理中添加一个条目。例如，要升级到另一个Spring Data release，我们可以在我们的pom.xml中添加以下元素: 12345678910111213141516171819&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- Override Spring Data release train provided by Spring Boot --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-releasetrain&lt;/artifactId&gt; &lt;version&gt;Fowler-SR2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 在前面的示例中，我们指定了一个BOM，但是任何依赖类型都可以以相同的方式重写。 3. 使用Spring Boot Maven PluginSpring Boot包含一个Maven插件，可以将项目打包为可执行jar。如果我们想使用这个插件，请将这个插件添加到&lt; plugins&gt;部分，如下例所示: 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 3. Gradlespringboot与gradle的结合篇幅较长，将放在后面单独来讲，敬请期待~ 4. Startersstarters是一组依赖描述符，我们可以在应用程序中包括这些描述符。我们可以为所有Spring和相关技术提供一站式服务，而无需通过示例代码和复制粘贴的依赖描述符来进行搜索。例如，如果我们希望开始使用Spring和JPA进行数据库访问，在项目中包含Spring -boot-starter-data- JPA依赖项就好。starters包含许多依赖项，我们需要这些依赖项来快速启动和运行项目，并且具有一组一致的、受支持的托管传递依赖项。 代码构建Spring Boot不需要任何特定的代码布局来工作。然而，有一些最佳实践对于我们来说显然是很有帮助的。 1. 使用默认包当一个类不包含包声明时，它被认为是在“默认包”中。一般不建议使用“默认包”，应该避免使用。它会给使用@ComponentScan、@EntityScan或@SpringBootApplication注解的Spring引导应用程序带来特别的问题，因为每个jar的每个类都被读取。 我们建议您遵循Java推荐的包命名约定，并使用一个反向的域名(例如，com.example.project)。 2. 定位 main application class我们通常建议您将main class置于其他类之上的root packge中。@SpringBootApplication注释通常放在主类上，它隐式地为某些项定义了基本的“搜索包”。例如，如果我们正在编写一个JPA应用程序，则使用@ SpringBootApplication带注释的类的包来搜索@Entity项。使用根包还允许组件扫描只应用于项目。 如果我们不想使用@SpringBootApplication，那么它导入的@EnableAutoConfiguration和@ComponentScan注释定义了这种行为，因此我们也可以使用它。 下面的清单展示了一个典型的布局: com +- example +- myapplication +- Application.java | +- customer | +- Customer.java | +- CustomerController.java | +- CustomerService.java | +- CustomerRepository.java | +- order +- Order.java +- OrderController.java +- OrderService.java +- OrderRepository.java Application.java文件将声明主方法和基本的@SpringBootApplication，如下所示: 12345678910111213package com.example.myapplication;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 配置类Spring Boot支持基于java的配置。虽然可以将SpringApplication与XML源一起使用，但是我们通常建议您的配置源是一个@Configuration类。通常，定义主方法的类作为主要的@Configuration是一个很好的选择。 许多Spring配置示例已经在Internet上发布，它们使用XML配置。如果可能的话，始终尝试使用等效的基于java的配置。搜索Enable*注释可能是一个很好的起点。 1. 导入额外的配置类不需要将所有的@Configuration放在一个类中。可以使用@Import注释来导入其他配置类，或者我们可以使用@ComponentScan自动提取所有Spring组件，包括@Configuration类。 2. 导入XML配置如果必须使用基于XML的配置，建议从一个@Configuration类开始。然后可以使用@ImportResource注释来加载XML配置文件。 下节预告： Auto-configuration Spring bean和依赖项注入 使用@SpringBootApplication注释……敬请期待 ~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础专题（一）：基本数据类型]]></title>
    <url>%2F2018%2F05%2F30%2FJava%E5%9F%BA%E7%A1%80%E4%B8%93%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[前言今天我们来聊一下Java这门语言的数据类型，众所周知，Java是一种强类型语言。在Java中，一共有8种基本类型，其中4种整形，2种浮点类型，1种用于表示Unicode编码的字符单元的字符类型char和1种用于表示真值的boolean类型。 整型整形用于表示没有小数部分的数值，允许为负。 类型 存储大小 取值范围 int 4字节 -2,147,483,648 ~ 2,147,483,647 short 2字节 -32,768 ~ 32,767 long 8字节 -9,223,372,036,854,775,808 ~ 9223,372,036,854,775,807 byte 1字节 -128 ~ 127 在Java中，整形的范围与运行Java代码的机器无关。这解决了软件从一个平台移植到另外一个平台，或者在同一个平台的不同操作系统之间进行移植给程序员带来的麻烦。 长整形（Long类型）数值后有一个后缀 L 或 l（这里建议不要使用小写的 l 来标识，因为在某些字体的格式下，1和 l 几乎没有任何区别，给月阅读的人带来很大的困扰）。 十六进制数值前缀为 0x 或 0X，这里需要说一点，八进制的前缀是0，比如010，这样的写法比较容易让人混淆，所以我们一般不要使用八进制来表示数据。 二进制数值的前缀为 0b 或 0B，例如0b1001所代表的十进制数据就是9。 从Java7开始，可以在数字字面量加下划线，比如1_000_000，这些下划线的作用仅仅是使代码的易读性更高，编译器在编译的时候会去除这些下划线。 浮点类型浮点类型用于表示有小数部分的数值，在Java中有两种浮点类型。 类型 存储大小 取值范围 float 4字节 大约 ± 3.402,823,47E+38F(有效位为6-7位) double 8字节 大约 ± 1.79769313486231570E+308（有效位15位） double表示这种类型的数值精度是float类型的两倍（故有人称double为双精度数值），事实上我们在使用的过程中，绝大多数情况都会选用double，因为float的精度通常无法满足我们的要求。 float类型的数值有一个后缀 f 或 F，没有后缀的浮点值就是double类型的。 可以使用十六进制来表示浮点数值，例如 0.125（2的负三次方）可以表示为 0x1.0p-3。在十六进制中，使用p表示指数，而不是e。 三个特殊的浮点数值： 1. 正无穷大（Double.POSITIVE_INFINITY） 2. 负无穷大（Double.NEGATIVE_INFINITY） 3. NAN（Double.NaN） char类型一个或两个char类型的数值可以用来表示一个Unicode字符，在代码中，char类型的字面量值需要用单引号括起来，char类型的值可以表示为以 \u 开头的16进制数值，用于表示一些标点和特殊符号所用。 一些较为特殊的字符的转移序列如下： 转义序列 名称 Unicode值 \b 退格 \u000 \t 制表 \u0009 \n 换行 \u000a \r 回车 \u000d \“ 双引号 \u0022 \‘ 单引号 \u0027 \\ 反斜杠 \u005c Unicode转义序列会在解析代码之前得到处理（大坑慎入！） 1// download uri d:\user\a，这里会报语法错误，因为 \u 后面没有跟着4个十六进制数。 布尔类型布尔类型有两个值：false和true，用来判定逻辑条件，整型值和布尔值之间不能互相转换，这一点与C或C++不同，需要留意一下。 参考文献 《Core Java Volume Ⅰ-Fundamentals》 – Cay S.Horstmann 下集预告下一期我们来见识一下Java中各种各样运算符的奥秘，三天一更，我们不见不散~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 2.0 系列（一）：快速开始]]></title>
    <url>%2F2018%2F05%2F28%2FSpring-Boot-2-0-%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[写在前面 SpringBoot版本：2.0.2 RELEASE 开发工具：IDEA 2017.2 相关资料：SpringBoot官方文档 1. 介绍SpringBootSpring Boot可以使我们轻松地创建独立的、生产级的基于Spring的应用程序，由于整合了一些对Spring和第三方库的配置，我们可以快速开始一个应用程序。大多数Spring Boot应用程序都需要很少的Spring配置。 我们可以使用Spring Boot来创建Java应用程序，这些应用程序可以通过使用 java -jar 或更传统的war部署来启动。Spring Boot还提供了一个运行“spring脚本”的命令行工具。 Spring Boot 为我们都做了什么: 为所有Spring开发人员提供一种快速而广泛的入门体验。 由于整合了一些对Spring和第三方库的配置解决了深受XML配置困扰的Spring开发人员的痛点 提供一系列非功能特性，这些特性在大型项目中是常见的(例如嵌入式服务器、安全、度量、健康检查和外部化配置)。 2.系统环境需求 Java 8 或 9 Spring 5.0.6 RELEASE 或 以上 构建工具 Maven 3.2 + Gradle 4 Spring Boot支持以下servlet容器: Tomcat 8.5 Jetty 9.4 Undertow 1.4 3. 构建项目的方式1.基于Maven的构建 pom.xml 内容如下： 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;myproject&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- Inherit defaults from Spring Boot --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;!-- Add typical dependencies for a web application --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- Package as an executable jar --&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2.基于Gradle的构建 bulid.gradle 内容如下： 123456789101112131415161718plugins &#123; id 'org.springframework.boot' version '2.0.2.RELEASE' id 'java'&#125;jar &#123; baseName = 'myproject' version = '0.0.1-SNAPSHOT'&#125;repositories &#123; jcenter()&#125;dependencies &#123; compile("org.springframework.boot:spring-boot-starter-web") testCompile("org.springframework.boot:spring-boot-starter-test")&#125; 4.开发Spring Boot 的Hello World 项目(使用maven构建工具) 第一步：创建pom文件 123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;myproject&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;!-- Additional lines to be added here... --&gt;&lt;/project&gt; 第二步：添加依赖 Spring Boot提供了许多“starter”，可以让您将jar添加到classpath 中。上文已经在POM的父部分使用了spring-boot-starter-parent。spring-boot-starter-parent是一个特殊的“starter”，它提供有用的Maven默认值。它还提供了一个依赖管理部分，这样我们就就可以为关联的依赖项省略版本标记。其他”starter”提供了在开发特定类型的应用程序时可能需要的依赖项。由于我们正在开发一个web应用程序，所以我们添加了一个spring-boot-starter-web依赖项。在此之前，我们可以通过运行以下命令查看当前所拥有的内容。 123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 第三步：编写代码 要完成我们的应用程序，我们需要创建一个Java文件，Java文件包含以下代码: 123456789101112131415161718import org.springframework.boot.*;import org.springframework.boot.autoconfigure.*;import org.springframework.web.bind.annotation.*;@RestController@EnableAutoConfigurationpublic class Example &#123; @RequestMapping("/") String home() &#123; return "Hello World!"; &#125; public static void main(String[] args) throws Exception &#123; SpringApplication.run(Example.class, args); &#125;&#125; 注：在我们的示例类上的第一个注释是@RestController。这被称为构造型注释。它为阅读代码的人们提供了一些提示，并且为Spring提供了一个特定的角色。在本例中，我们的类是一个web @Controller，所以Spring在处理传入web请求时考虑它。@RequestMapping注释提供路由信息。它告诉Spring，任何带有/ path的HTTP请求都应该映射到home方法。@RestController注释告诉Spring将生成的字符串直接呈现给调用者。 第二个类级别注释是@EnableAutoConfiguration。这个注释告诉Spring Boot基于您添加的jar依赖项“猜测”您想如何配置Spring，。因为Spring-boot-starter-web添加了Tomcat和Spring MVC，所以自动配置假设您正在开发一个web应用程序，并相应地设置Spring。 我们的应用程序的最后一部分是主方法。这只是遵循应用程序入口点的Java约定的标准方法。通过调用run，我们的main方法委托给Spring Boot的SpringApplication类。SpringApplication引导我们的应用程序启动Spring，而Spring又启动了自动配置的Tomcat web服务器。我们需要通过例子。类作为运行方法的参数，以告诉SpringApplication是主Spring组件。args数组也被传递，以公开任何命令行参数。 第四步：运行程序： 运行main方法，或者在根目录运行 mvn spring-boot: run命令。 12345678910111213$ mvn spring-boot:run . ____ _ __ _ _ /\\ / ___'_ __ _ _(_)_ __ __ _ \ \ \ \( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \ \\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.0.2.RELEASE)....... . . ........ . . . (log output here)....... . . ......... Started Example in 2.222 seconds (JVM running for 6.514) 打开浏览器，输入localhost:8080，你可以看到 1Hello World! 第五步：创建可执行的jar 将下列代码添加到pom.xml文件中： 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 保存文件，并在命令行输入maven package，可以看到： 123456789101112131415$ mvn package[INFO] Scanning for projects...[INFO][INFO] ------------------------------------------------------------------------[INFO] Building myproject 0.0.1-SNAPSHOT[INFO] ------------------------------------------------------------------------[INFO] .... ..[INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ myproject ---[INFO] Building jar: /Users/developer/example/spring-boot-example/target/myproject-0.0.1-SNAPSHOT.jar[INFO][INFO] --- spring-boot-maven-plugin:2.0.2.RELEASE:repackage (default) @ myproject ---[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------ 这时你会发现target目录下多了一个名为myprojectname-0.0.1-SNAPSHOT.jar的文件，文件大概10MB，如果你想查看文件的详细内容，可以使用 1$ jar tvf target/myproject-0.0.1-SNAPSHOT.jar 如果你想运行，可以使用 java -jar，如下： 12345678910111213$ java -jar target/myproject-0.0.1-SNAPSHOT.jar . ____ _ __ _ _ /\\ / ___'_ __ _ _(_)_ __ __ _ \ \ \ \( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \ \\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.0.2.RELEASE)....... . . ........ . . . (log output here)....... . . ......... Started Example in 2.536 seconds (JVM running for 2.864) 若知后事如何，且听下回分解~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《用户体验要素》读后笔记[完]（三）]]></title>
    <url>%2F2018%2F05%2F05%2F%E3%80%8A%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%A6%81%E7%B4%A0%E3%80%8B%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[结构层在定义好用户需求并排序好优先级别之后，我们对于最终差您将会包括什么特性已经有了清楚的图像，然而这些需求并没有说明如何将这些分散的片段组成一个整体，这就是范围层的上面一层：为网站建立一个概念结构。 结构层适当的将我们的关注点从抽象的决策与范围问题，转移到更能影响最后的用户体验的具体因素，传统的软件开发行业，涉及”为用户设计结构化体验”的方法被称为交互设计。在内容建设方面，主要是通过信息架构来构建用户体验。这两个都强调一个重点：确定各个将要呈现给用户的元素的“模式”和“顺序”。与其针对机器的最佳工作方式来设计系统，还不如设计一个对用户而言最好的系统，用户对于“交互组件将怎么样工作”的观点成为概念模型。概念模型是用于在交互设计的开发过程中保持使用方式的一致性的，交互设计会处理每一个级别的错误，以确保更高比例的用户能有积极的体验。 信息架构 信息架构所研究的是人们如何认知信息的过程，对于产品而言，信息架构关注的是呈现给用户的信息是否合理并具有意义 信息架构要求创建分类体系，创建分类体系的方法有从上向下和从下向上，但是这两种方法都有一定的局限性，唯一可避免两者缺点的方法是在两种方法中找到一个平衡点 一个高效结构的优点就是具备“容纳成长和适应变动”的能力 信息架构的基本单位是节点 节点的结构包括层级结构（树状、辐射）、矩阵结构、自然结构、线性结构 节点在信息架构是依据组织原则来安置的 我们的困难不是创建一个结构，而是在创建一个能与“我们的目标”和“用户的需求”相对应、正确的结构 成功的用户体验，就是能事先预知用户的期望并将其带入到设计当中去 “使用客户的语言”并且“保持一致性”是非常重要的，我们把用来强调一致性的工具称为受控词典 元数据的意思，简单地说就是“关于信息的信息”，即以一个结构化的方式来描述内容的信息。 框架层在充满概念的结构层中开始形成大量的需求，这些需求都是来自我们的战略目标的需求。在框架层，我们要更进一步的提炼这些结构，确定很详细的界面外观，导航和信息设计，这能让晦涩的结构变得实在。对于功能性产品，我们通过界面设计来确定框架，对于信息型产品，要解决的问题是导航设计，但是这两者都应解决信息设计这一方面。 提供给用户做某些事的能力，这属于界面设计。 提供给用户去某个地方的能力，这是导航设计。 传达想法给用户，那就是信息设计。 传统的习惯并非一定要死守，当某种方式有着不错的收益时，应该谨慎的试着违背一些习惯。 有效的使用比喻，即减少用户在理解你的产品时对猜测的要求。 界面设计的全部事情就是选择正确的界面元素 设计复杂系统的界面所面临的最大挑战之一，是弄清楚用户不需要哪些东西，并减少他们的可发现性。 导航设计必须完成以下三个目标： ① 提供用户一种在网页间跳转的方法 ② 元素与所包含内容之间的关系 ③ 内容与当前用户浏览页面之间的关系 多重导航系统： 全局导航，局部导航，辅助导航，上下文导航，友好导航，远程导航，网络地图，索引表 将信息设计和导航设计结合到一起，有一个重要的作用：支持指示标识。 页面布局是将信息设计、界面设计和导航设计放置到一起，形成一个统一的，有内在凝聚力的架构，这个架构的具体文档的展示方式为线框图。 线框图是整合在框架层的全部三种要素的方法：通过安排和选择界面元素来整合界面设计；通过识别和定义核心导航系统来整合导航设计；通过放置和排列信息组成部分的优先级来整合信息设计。 表现层在这五个模型的顶端，我们把注意力转移到产品用户会首先注意到的地方：感知设计，这里，内容、功能和美学汇集到一起来缠身一个最终设计，完成其他四个层面的所有目标，并同时满足用户的感官感受。 表现层中几乎所有的产品都会涉及到视觉设计，在视觉设计中，我们用于吸引用户注意的一个主要工具就是对比。 在你的设计中保持一致性是另一个重要的组成部分，它能使你的设计有效地传达信息，而不会导致用户迷惑或焦虑。“一致性”在视觉设计的许多不同方面都会起到作用。 内部和外部的一致性： ① 内部一致性的问题。这是说，在产品的两个不同的地方反映了不同的设计方法。 ② 外部一致性的问题。这是说，这个产品没有在同一个企业的其他产品中，反映出被使用的，相同的设计方法。 配色方案与排版对于品牌形象的建立，以及对于公众的影响显得尤为重要。 在视觉设计领域中对线框图最直接的模拟是视觉模型或设计合成品。 承载这些设计决策的权威性文档是风格指南。这个汇总文档确定了视觉设计的每个方面，从最大到最小的范围内的所有元素]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>UE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《用户体验要素》读后笔记（二）]]></title>
    <url>%2F2018%2F05%2F04%2F%E3%80%8A%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%A6%81%E7%B4%A0%E3%80%8B%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[战略层成功的用户体验，其基础是一个被明确表达的“战略”，知道企业与用户双方对产品的期许和目标，有助于促进用户体验各方面战略的确定和制定。 明确两个问题：我们要通过这个产品得到什么？ 我们的客户要通过这个产品得到什么？ ① 产品目标 ② 用户需求 产品目标： ① 商业目标（商业驱动因素） ② 品牌识别 ③ 成功标识 用户需求： ① 用户细分 1. 人口统计学 2. 消费心理档案 ② 可用性和用户研究 1. 市场调研方法 2. 现场调研 3. 任务分析 4. 用户测试 5. 卡片排序法 6. 用户模型 这是就需要一篇战略文档，而战略文档的关键在于简洁明了并切中要点，战略是设计用户体验设计流程中的起点。 范围层带着“我们想要什么”、“我们的用户想要什么”的明确认识，我们才能弄清楚如何去满足这些战略的目标，当你把用户需求和产品目标转变成产品应该提供给用户什么样的内容和功能时，战略就变成了范围。 用文档定义产品需求的必要性： ① 这样你才知道你在建设什么 ② 这样你才知道你不需要建设什么 范围层被功能型产品和信息型产品分为了功能规格和内容需求，定义需求的详略层度往往取决于该项目的具体范围。 功能规格说明： 文档不能解决问题，但定义可以，我们需要的不是文档有厚或有多详细，而是要足够清楚和准确。 乐观：描述这个系统将要做什么事情去“防止”不好的情况发生 具体：尽可能详细的解释清楚情况 在文档中要尽量避免主观的语气 内容需求： 应该提供每一个特性规模的文档预估：文本的字数，图片的像素大小，下载的文件字节、PDF或音频文件等独立元素的大小等。 内容特性的更新频率来自于产品的战略目标，必须确定一个频率，它是介于你的用户期望值和有效值之间 确定需求优先级： 有些特性可能会因为技术上的局限无法实现，有些则是因为资源与时间上的不足 很少有功能时独立存在的 如果你的战略计划或愿景文档在战略目标的范围内制定了一个清晰的优先级别顺序，那么这些优先级别应该是决定是否采纳人们所建议的相关特性的首要因素]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>UE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《用户体验要素》 读后笔记（一）]]></title>
    <url>%2F2018%2F05%2F04%2F%E3%80%8A%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%A6%81%E7%B4%A0%E3%80%8B%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[最近有幸拜读了Jesse James Garrett所著的用户体验要素这本书，感触颇多，感觉对于UE这门课程有了一个较为系统的认识，知道了用户体验为什么是如此的重要，以及用户体验的五个元素。 在产品开发过程中,人们更多的关注what to do, 设计师经常忽略的另一个因素是how to do, 而这一因素恰恰是决定产品成败的关键因素。 “外形服从于功能” 这种观点对于产品的内部运作(用户不可见的部分)是完全适用的, 但是, 对于产品直接面向用户的那些部分—按钮, 布局, 文字, 也包括外观, 正确的产品形态绝对不是由”功能”所决定的, 而是应该由”用户自身的心理感受和行为“来决定的 提供优质的用户体验, 是一个重要的可持续的竞争优势 —— 不仅仅对网站是这样, 对所有类型的产品和服务都是如此 创建吸引人的,高效的用户体验的方法称为”以用户为中心的设计”. 以用户为中心的设计思想非常简单,: 在开发产品的每一个步骤中, 都要把用户列入考虑范围，下面我们来认识一下这些要素。 五个要素用户体验开发时的五个要素(5s) 表现层(surface) 一系列的网页, 由图片和文字组成 框架层(skeleton) 按钮, 控件, 照片和文本区域的位置, 优化设计布局, 以达到这些元素的最大效果和效率 结构层(structure) 框架是结构的具体表达方式 范围层(scope) 结构层确定网站各种特性和功能最合适的组合方式, 而这些特性和功能就构成了网站的范围层 战略层(strategy) 网站的范围基本上是由网站战略层决定的 双重性自下而上的建设，并且让每一个层面的工作在下一个层面可以结束之前完成，网站具有基本的双重性，描述功能型的平台类产品和描述信息的媒介类产品。 功能性产品, 主要关注的任务, 所有的操作都被纳入一个过程, 去思考人们如何完成这个过程, 这里的网站实际上是用户用于完成任务的一种工具 信息性产品, 主要的关注点是信息, 创建一个富信息的用户体验, 就是提供给用户一个可以寻找, 理解且有意义的组合 区别和联系1.战略层所关注的内容都是一样的, 来自企业外部的用户需求和来自自己对网站的期望目标。 2.由范围层进入战略层, 在功能型产品一侧转化为功能规格: 对产品的&quot;功能组合&quot;的详细描述. 而在信息型产品一侧, 范围则是以内容需求的形式出现: 对各种内容元素的要求的详细描述。 3.在功能性产品一侧, 结构层将从范围转化为交互设计, 在这里我们可以定义系统如何响应用户的请求,另一侧是信息架构: 合理的安排内容元素以促进人类理解信息 4.在框架层, 必不可少的是信息设计, 功能性产品偏向于界面设计, 而信息类产品, 则偏向于导航设计. 5.最后, 在表现层, 关注点都在于最终产品创建用户体验]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>UE</tag>
      </tags>
  </entry>
</search>
