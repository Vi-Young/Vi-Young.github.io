<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python3 系列（三）：基本数据类型]]></title>
    <url>%2F2018%2F06%2F28%2FPython3-%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[前言：Python中的变量不需要声明。每个变量在使用前都必须赋值，变量赋值以后该变量才会被创建。 在Python中，变量就是变量，它没有类型，我们所说的”类型”是变量所指的内存中对象的类型。 Python 3 中有六个标准的数据类型： Numbers（数字） String（字符串） List（列表） Tuple（元组） Sets（集合） Dictionaries（字典） Python3 的六个标准数据类型中： 不可变数据（3个）：Number，String，Tuple 可变数据（3个）：List，Dictionary，Set Number（数字）Python3 支持int，float，bool，complex（复数）在Python 3里，只有一种整数类型 int，表示为长整型，没有 python2 中的 Long。 像大多数语言一样，数值类型的赋值和计算都是很直观的。 type和isinstance内置的 type() 函数可以用来查询变量所指的对象类型。 123a, b, c, d = 20, 5.5, True, 4+3jprint(type(a), type(b), type(c), type(d)) 打印结果： 1&lt;class 'int'&gt; &lt;class 'float'&gt; &lt;class 'bool'&gt; &lt;class 'complex'&gt; 当然，你也可以选择使用instance来判断类型： 12a = 1print(isinstance(a, int)) 打印结果： 1True isinstance 和 type 的区别在于： 12345678910class A: passclass B(A): passprint(isinstance(A(), A))print((type(A()) == A))print(isinstance(B(), A))print((type(B()) == A)) 打印结果： 1234TrueTrueTrueFalse 由此可以看出这两者的区别在于： type()不会认为子类是一种父类类型 isinstance()会认为子类是一种父类类型 在 Python2 中是没有布尔型的，它用数字 0 表示 False，用 1 表示 True。到 Python3 中，把 True 和 False 定义成关键字了，但它们的值还是 1 和 0，它们可以和数字相加。 del函数当你指定一个值时，Number对象就会被创建： 12var1 = 1var2 = 10 如果我们不想使用该对象，可以使用del()删除一些对象的引用，del用法如下： 1del var1[, var2[,var3[...,varN]]]] 比如： 123456789var1 = 1;var2 = 10;var3 = [1, 2, 3, 4]del var1, var3[0]print(var2)print(var3)print(var1) 打印结果： 12345610[2, 3, 4]Traceback (most recent call last): File "C:/Users/18530/PycharmProjects/HelloWorld/helloworld.py", line 12, in &lt;module&gt; print(var1)NameError: name 'var1' is not defined 这里可以看到，var1变量被删除后，打印时会出错，而var3的第一个元素被删除后，只打印出了后三个元素。 数值运算直接上例子： 123456789101112131415var1 = 5 + 4 # 加法var2 = 4.3 - 2 # 减法var3 = 3 * 7 # 乘法var4 = 2 / 4 # 除法，得到一个浮点数var5 = 2 // 4 # 除法，得到一个整数var6 = 17 % 3 # 取余var7 = 2 ** 5 # 乘方print(var1)print(var2)print(var3)print(var4)print(var5)print(var6)print(var7) 打印结果： 123456792.3210.50232 注意： Python可以同时为多个变量赋值，如a, b = 1, 2。 一个变量可以通过赋值指向不同类型的对象。 数值的除法包含两个运算符：/ 返回一个浮点数，// 返回一个整数。 在混合计算时，Python会把整型转换成为浮点数。 数值类型实例： int float complex 10 0.0 3.14j 100 15.20 45.j -786 21.9 9.322e-36j 080 32.3e+18 .876j -0490 -90. -.6546+0J -0x260 -32.54e100 3e+26J 0x69 70.2E-12 4.53e-7j Python还支持复数，复数由实数部分和虚数部分构成，可以用a + bj,或者complex(a,b)表示， 复数的实部a和虚部b都是浮点型 String（字符串）字符串在上次的基本语法中已经详细介绍过了，这里再补充几点： Python使用反斜杠转义特殊字符，如果你不想让反斜杠发生转移，可以在字符串前面添加一个r，表示原始字符 Python 没有单独的字符类型，一个字符就是长度为1的字符串。 字符串可以用+运算符连接在一起，用*运算符重复。 Python中的字符串有两种索引方式，从左往右以0开始，从右往左以-1开始。 Python中的字符串不能改变。 List（列表）List（列表） 是 Python 中使用最频繁的数据类型。 列表可以完成大多数集合类的数据结构实现。列表中元素的类型可以不相同，它支持数字，字符串甚至可以包含列表（所谓嵌套）。 列表是写 [] 之间、用逗号分隔开的元素列表。 和字符串一样，列表同样可以被索引和截取，列表被截取后返回一个包含所需元素的新列表。 列表截取的语法格式如下： 1变量[头下标:尾下标] 索引值以 0 为开始值，-1 为从末尾的开始位置。 加号（+）是列表连接运算符，星号（*）是重复操作。如下实例： 1234567891011list1 = ['abcd', 786, 2.23, 'vi', 70.2]list2 = [123, 'vi']list3 = [list1, list2]print(list1) # 输出完整列表print(list1[0]) # 输出列表第一个元素print(list1[1:3]) # 从第二个开始输出到第三个元素print(list1[2:]) # 输出从第三个元素开始的所有元素print(list2 * 2) # 输出两次列表print(list1 + list2) # 连接列表print(list3) #输出列表元素为列表的列表 打印结果： 1234567['abcd', 786, 2.23, 'vi', 70.2]abcd[786, 2.23][2.23, 'vi', 70.2][123, 'vi', 123, 'vi']['abcd', 786, 2.23, 'vi', 70.2, 123, 'vi'][['abcd', 786, 2.23, 'vi', 70.2], [123, 'vi']] 与字符串不同，列表中的元素可以改变： 123456a = [1, 2, 3, 4, 5, 6]a[0] = 9a[2:5] = [13, 14, 15]print(a)a[2:5] = []print(a) 打印结果： 12[9, 2, 13, 14, 15, 6][9, 2, 6] 注意: List写在方括号之间，元素用逗号隔开。 和字符串一样，list可以被索引和切片。 List可以使用+操作符进行拼接。 List中的元素是可以改变的。 Tuple（元组）元组（tuple）与列表类似，不同之处在于元组的元素不能修改。元组写在小括号 () 里，元素之间用逗号隔开。 元组中的元素类型也可以不相同： 12345678910111213list1 = [1, 2, 3]tuple1 = ('abcd', 786, 2.23, 'runoob', 70.2)tuple2 = (123, 'runoob')tuple3 = [list1, tuple1, tuple2]print(tuple1) # 输出完整元组print(tuple1[0]) # 输出元组的第一个元素print(tuple1[1:3]) # 输出从第二个元素开始到第三个元素print(tuple1[2:]) # 输出从第三个元素开始的所有元素print(tuple2 * 2) # 输出两次元组print(tuple1 + tuple2) # 连接元组print(tuple3) # 输出元组中元素为元组和列表的元组 输出结果： 1234567('abcd', 786, 2.23, 'runoob', 70.2)abcd(786, 2.23)(2.23, 'runoob', 70.2)(123, 'runoob', 123, 'runoob')('abcd', 786, 2.23, 'runoob', 70.2, 123, 'runoob')[[1, 2, 3], ('abcd', 786, 2.23, 'runoob', 70.2), (123, 'runoob')] 元组与字符串类似，可以被索引且下标索引从0开始，-1 为从末尾开始的位置。也可以进行截取（看上面，这里不再赘述）。 其实，可以把字符串看作一种特殊的元组。 1234tup = (1, 2, 3, 4, 5, 6)print(tup[0])print(tup[1:5])tup[0] = 11 # 修改元组元素的操作是非法的 打印结果： 1234561Traceback (most recent call last):(2, 3, 4, 5) File "C:/Users/18530/PycharmProjects/HelloWorld/helloworld.py", line 7, in &lt;module&gt; tup[0] = 11TypeError: 'tuple' object does not support item assignment 如上所示，如果试图修改tuple中的元素系统就会出错，虽然tuple的元素不可改变，但它可以包含可变的对象，比如list列表。 构造包含 0 个或 1 个元素的元组比较特殊，所以有一些额外的语法规则： 12tup1 = () # 空元组tup2 = (20,) # 一个元素，需要在元素后添加逗号 注意： 与字符串一样，元组的元素不能修改。 元组也可以被索引和切片，方法一样。 注意构造包含0或1个元素的元组的特殊语法规则。 元组也可以使用+操作符进行拼接。 Set（集合）集合（set）是一个无序不重复元素的序列。 基本功能是进行成员关系测试和删除重复元素。 可以使用大括号 { } 或者 set() 函数创建集合，注意：创建一个空集合必须用 set() 而不是 { }，因为 { } 是用来创建一个空字典。 Example： 123456789101112131415161718192021222324student = &#123;'Tom', 'Jim', 'Mary', 'Tom', 'Jack', 'Rose'&#125;print(student) # 输出集合，重复的元素被自动去掉# 成员测试if ('Rose' in student): print('Rose 在集合中')else: print('Rose 不在集合中')# set可以进行集合运算a = set('abracadabra')b = set('alacazam')print(a)print(b)print(a - b) # a和b的差集print(a | b) # a和b的并集print(a &amp; b) # a和b的交集print(a ^ b) # a和b中不同时存在的元素 打印结果： 12345678&#123;'Tom', 'Mary', 'Rose', 'Jack', 'Jim'&#125;Rose 在集合中&#123;'d', 'a', 'c', 'r', 'b'&#125;&#123;'a', 'c', 'z', 'l', 'm'&#125;&#123;'d', 'r', 'b'&#125;&#123;'d', 'a', 'c', 'z', 'r', 'l', 'm', 'b'&#125;&#123;'a', 'c'&#125;&#123;'d', 'l', 'b', 'z', 'm', 'r'&#125; Dictionary（字典）字典（dictionary）是Python中另一个非常有用的内置数据类型。 列表是有序的对象集合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。 字典是一种映射类型，字典用”{ }”标识，它是一个无序的键(key) : 值(value)对集合。 键(key)必须使用不可变类型。 在同一个字典中，键(key)必须是唯一的。 123456789101112dict1 = &#123;&#125;dict1['one'] = "Young"dict1[2] = "Vi"dict2 = &#123;'name': 'Vi_Young', 'code': 200, 'site': 'vi-young.com'&#125;print(dict1)print(dict1['one']) # 输出键为 'one' 的值print(dict1[2]) # 输出键为 2 的值print(dict2) # 输出完整的字典print(dict2.keys()) # 输出所有键print(dict2.values()) # 输出所有值 打印结果： 123456&#123;'one': 'Young', 2: 'Vi'&#125;YoungVi&#123;'name': 'Vi_Young', 'code': 200, 'site': 'vi-young.com'&#125;dict_keys(['name', 'code', 'site'])dict_values(['Vi_Young', 200, 'vi-young.com']) 构建函数dict()可以直接从键值对序列中构建字典如下： 1234567dict1 = dict([('Google', 1), ('Taobao', 2)])dict2 = &#123;x: x ** 2 for x in (2, 4, 6)&#125;dict3 = dict(Google=1, Taobao=2)print(dict1)print(dict2)print(dict3) 打印结果： 123&#123;'Google': 1, 'Taobao': 2&#125;&#123;2: 4, 4: 16, 6: 36&#125;&#123;'Google': 1, 'Taobao': 2&#125; 另外，字典类型也有一些内置的函数，例如clear()、keys()、values()等。 注意： 字典是一种映射类型，它的元素是键值对。 字典的关键字必须为不可变类型，且不能重复。 创建空字典使用 { }。 Python数据类型转换有时候，我们需要对数据内置的类型进行转换，数据类型的转换，你只需要将数据类型作为函数名即可。 以下几个内置的函数可以执行数据类型之间的转换。这些函数返回一个新的对象，表示转换的值。 函数 描述 int(x [,base]) 将x转换为一个整数 float(x) 将x转换到一个浮点数 complex(real [,imag]) 创建一个复数 str(x) 将对象 x 转换为字符串 repr(x) 将对象 x 转换为表达式字符串 eval(str) 用来计算在字符串中的有效Python表达式,并返回一个对象 tuple(s) 将序列 s 转换为一个元组 list(s) 将序列 s 转换为一个列表 set(s) 转换为可变集合 dict(d) 创建一个字典。d 必须是一个序列 (key,value)元组。 frozenset(s) 转换为不可变集合 chr(x) 将一个整数转换为一个字符 ord(x) 将一个字符转换为它的整数值 hex(x) 将一个整数转换为一个十六进制字符串 oct(x) 将一个整数转换为一个八进制字符串 下节预告：运算符 公众号扫码或微信搜索Vi的技术博客，关注公众号，不定期送书活动各种福利~]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 系列（二）：语法]]></title>
    <url>%2F2018%2F06%2F27%2FPython3-%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[编码Python 3 源码文件在默认情况下以UTF-8编码，所有的字符串都是unicode字符串，当然，如果加上# coding=utf-8是最稳妥的选择，我们也可以给源码文件指定不同的编码：1# _*_ coding: cp-1252 -*- ps: cp-1252对应适合语言为保加利亚语、白罗斯语、马其顿语、俄语、塞尔维亚语。 标识符 第一个字符必须是字母或下划线_ 其他部分由字母，数字和下划线组成 严格区分大小写 首位：(a~z ，A~Z ，_ ) + 其他位：(a~z ，A~Z ，0-9 ，_ ) 保留字123456# coding=utf-8# __author__ = 'Vi-Young'import keywordprint(keyword.kwlist) 输出： 1['False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'] 注释 单行注释 以#开头 12#第一个注释print("I Love Python!") #我爱python 多行注释 多个#号 使用’’’ 或 “”” 12345678910# 注释第一行# 注释第二行'''第一行注释第二行注释'''"""第一行注释第二行注释""" 行与缩进python最具特色的就是使用缩进来表示代码块，不需要使用大括号 {} 。缩进的空格数是可变的（这里一般要求缩进为四个空格，美观且规范），但是同一个代码块的语句必须包含相同的缩进空格数，否则就会抛出IndentationError这个错误 多行语句当我们遇到语句过长的情况时，可以使用反斜杠来实现多行语句 123number = a + \ b + \ c 当然，如果语句包含在[],{}或()时，不需要使用反斜杠 12number = ['a','b','c' 'd'] 数字类型python中数字由四种类型：整数，长整数，浮点数和复数 整数，如 1 长整数 是比较大的整数 浮点数 如 1.23，3E-2 复数 如 1 + 2j, 1.1 + 2.2j 字符串 python中单引号和双引号使用完全相同。 使用三引号(‘’’或”””)可以指定一个多行字符串。 转义符 ‘\’ 反斜杠可以用来转义，使用r可以让反斜杠不发生转义。。 如 r”this is a line with \n” 则\n会显示，并不是换行。 按字面意义级联字符串，如”this “ “is “ “string”会被自动转换为this is string。 字符串可以用 + 运算符连接在一起，用 * 运算符重复。 Python 中的字符串有两种索引方式，从左往右以 0 开始，从右往左以 -1 开始。 Python中的字符串不能改变。 Python 没有单独的字符类型，一个字符就是长度为 1 的字符串。 字符串的截取的语法格式如下：变量[头下标:尾下标] 1234word = '词'sentence = "句"paragraph = """段，可以由多行组成""" Example: 1234567891011121314151617# coding=utf-8# __author__ = 'Vi-Young'str = 'Vi_Young'print(str) # 输出字符串print(str[0:-1]) # 输出第一个到倒数第二个的所有字符print(str[0]) # 输出字符串第一个字符print(str[2:5]) # 输出从第三个开始到第五个的字符print(str[2:]) # 输出从第三个开始的后的所有字符print(str * 2) # 输出字符串两次print(str + '你好') # 连接字符串print('------------------------------')print('hello\nrunoob') # 使用反斜杠(\)+n转义特殊字符print(r'hello\nrunoob') # 在字符串前面添加一个 r，表示原始字符串，不会发生转义 输出： 同一行显示多条语句如果想要在同一行中使用多条语句，可以使用分号将语句间隔开。 123#!/usr/bin/python3import sys; x = 'vi_young'; sys.stdout.write(x + '\n') 输出： 多个语句构成代码组缩进相同的一组语句构成一个代码块，我们称之为代码组。一般体现在控制流程的语句中。 123456if boolean: todoelif boolean: todoelse: todo import与from…import 在 python 用 import 或者 from…import 来导入相应的模块。 将整个模块(somemodule)导入，格式为： import somemodule 从某个模块中导入某个函数,格式为： from somemodule import somefunction 从某个模块中导入多个函数,格式为： from somemodule import firstfunc, secondfunc, thirdfunc 将某个模块中的全部函数导入，格式为： from somemodule import * 导入sys123456import sysprint('================Python import mode==========================');print ('命令行参数为:')for i in sys.argv: print (i)print ('\n python 路径为',sys.path) 导入sys模块的argv,path成员 1234from sys import argv,path # 导入特定的成员 print('================python from import===================================')print('path:',path) # 因为已经导入path成员，所以此处引用时不需要加sys.path 参考资料Python3 基础语法|菜鸟教程 Python3 基础语法|W3Cschool 下节预告基本数据类型~ 公众号扫码或微信搜索Vi的技术博客，关注公众号，不定期送书活动各种福利~]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 2.0 系列（四）：开发者工具]]></title>
    <url>%2F2018%2F06%2F27%2FSpring-Boot-2-0-%E7%B3%BB%E5%88%97%EF%BC%88%E5%9B%9B%EF%BC%89%EF%BC%9A%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[前言Spring Boot包括一组额外的工具，这些工具可以使应用程序开发体验变得更加愉快。spring-boot-devtools模块可以包含在任何项目中，以提供额外的开发时特性。如果要想支持devtools，要将模块依赖项添加到构建中，如以下Maven和Gradle清单所示: Maven1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt; Gradle 123dependencies &#123; compile("org.springframework.boot:spring-boot-devtools")&#125; 在运行完全打包的应用程序时，会自动禁用开发人员工具。如果您的应用程序是从java -jar启动的，或者是从一个特殊的类加载器开始的，那么它就被认为是一个“生产应用程序”。将Maven中的依赖项的optional设置为true或使用compileOnly在Gradle中，这样可以防止devtools被传递到其他使用的项目的模块中。 重新打包的archives默认不包含devtools。如果我们想使用某个远程devtools功能，我们需要禁用excludeDevtools 的build属性以包含它。Maven和Gradle插件都支持这个属性。 属性默认值Spring Boot支持的几个库使用缓存来提高性能。例如，模板引擎缓存已编译的模板，以避免重复解析模板文件。此外，Spring MVC可以在服务静态资源时向响应添加HTTP缓存头。 虽然缓存在生产中非常有用，但在开发过程中它可能会产生反作用，防止我们看到我们在应用程序中所做的更改。出于这个原因，spring-boot-devtools默认禁用缓存选项。 缓存选项通常由application.properties 文件配置。例如，Thymeleaf提供了spring.thymeleaf.cache属性。spring-boot-devtools模块不需要手动设置这些属性，而是自动应用合理的开发时配置。 有关devtools应用的属性的完整列表（默认配置）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@Order(Ordered.LOWEST_PRECEDENCE)public class DevToolsPropertyDefaultsPostProcessor implements EnvironmentPostProcessor &#123; private static final Map&lt;String, Object&gt; PROPERTIES; static &#123; Map&lt;String, Object&gt; devToolsProperties = new HashMap&lt;&gt;(); devToolsProperties.put("spring.thymeleaf.cache", "false"); devToolsProperties.put("spring.freemarker.cache", "false"); devToolsProperties.put("spring.groovy.template.cache", "false"); devToolsProperties.put("spring.mustache.cache", "false"); devToolsProperties.put("server.servlet.session.persistent", "true"); devToolsProperties.put("spring.h2.console.enabled", "true"); devToolsProperties.put("spring.resources.cache.period", "0"); devToolsProperties.put("spring.resources.chain.cache", "false"); devToolsProperties.put("spring.template.provider.cache", "false"); devToolsProperties.put("spring.mvc.log-resolved-exception", "true"); devToolsProperties.put("server.servlet.jsp.init-parameters.development", "true"); devToolsProperties.put("spring.reactor.stacktrace-mode.enabled", "true"); PROPERTIES = Collections.unmodifiableMap(devToolsProperties); &#125; @Override public void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) &#123; if (isLocalApplication(environment) &amp;&amp; canAddProperties(environment)) &#123; PropertySource&lt;?&gt; propertySource = new MapPropertySource("refresh", PROPERTIES); environment.getPropertySources().addLast(propertySource); &#125; &#125; private boolean isLocalApplication(ConfigurableEnvironment environment) &#123; return environment.getPropertySources().get("remoteUrl") == null; &#125; private boolean canAddProperties(Environment environment) &#123; return isRestarterInitialized() || isRemoteRestartEnabled(environment); &#125; private boolean isRestarterInitialized() &#123; try &#123; Restarter restarter = Restarter.getInstance(); return (restarter != null &amp;&amp; restarter.getInitialUrls() != null); &#125; catch (Exception ex) &#123; return false; &#125; &#125; private boolean isRemoteRestartEnabled(Environment environment) &#123; return environment.containsProperty("spring.devtools.remote.secret"); &#125;&#125; 自动重启使用spring-boot-devtools的应用程序在类路径上的文件发生更改时自动重新启动。在IDE中工作时，这可能是一个有用的特性，因为它为代码更改提供了一个非常快速的反馈循环。默认情况下，指向文件夹的类路径中的任何条目都将受到监视，以查看是否有更改。注意，某些资源(如静态资源和视图模板)不需要重新启动应用程序。 由于DevTools监控类路径资源，触发重新启动的惟一方法是更新类路径。使类路径更新的方式取决于您使用的IDE。在Eclipse中，保存修改后的文件会更新类路径并触发重新启动。在IntelliJ IDEA中，构建项目(Build -&gt; Build project)也有着同样的效果。 只要启用了fork，您还可以通过使用受支持的构建插件(Maven和Gradle)启动应用程序，因为DevTools需要一个独立的应用程序类加载程序来正常运行。默认情况下，Gradle和Maven在类路径上检测DevTools时是这样做的。 自动重新启动在使用LiveReload时非常有效。如果您使用JRebel，自动重启被禁用，以支持动态类重载。其他devtools特性(如LiveReload和property overrides)仍然可以使用。 DevTools依赖于应用程序上下文的shutdown hook在重新启动时关闭它。如果禁用了shutdown hook(SpringApplication.setRegisterShutdownHook(false))，那么它就不能正常工作。 当决定类路径上的条目是否应该在更改时触发重新启动时，DevTools会自动忽略名为spring-boot、spring-boot-devtools 、spring-boot-autoconfigure、spring-boot-actuator和spring-boot-starter的项目。 DevTools需要自定义ApplicationContext使用的ResourceLoader。如果您的应用程序已经提供了一个，那么它将被包装。不支持在ApplicationContext上直接覆盖getResource方法。 热加载和热部署 Spring Boot提供的热部署技术使用两个类加载器。不改变的类(例如，来自第三方jar的类)被加载到一个基类加载器中。正在积极开发的类被加载到restart classloader中。当重新启动应用程序时，会丢弃restart classloader，并创建一个新的。这种方法意味着应用程序重新启动通常比“冷启动”快得多，因为基类加载程序已经可用并填充。 如果发现热部署对应用程序来说不够快，或者遇到了类加载问题，可以考虑热加载技术，如零周转期的JRebel。这些工作通过重写类，使它们更适合热加载。 PS：后面会出一期单章说明热加载和热部署的区别，以及在IntelliJ IDEA中的使用方式。 日志记录变化默认情况下，每次应用程序重新启动时，都会记录显示变化的报告。报告显示了应用程序自动配置的更改，如添加或删除bean和设置配置属性。 要禁用报告的日志记录，设置以下属性: 1spring.devtools.restart.log-condition-evaluation-delta=false 不包括的资源某些资源在更改时不一定需要触发重新启动。例如，可以就地编辑Thymeleaf模板。默认情况下，在/META-INF/maven、/META-INF/resources、/resources、/static、/public或/template中更改资源不会触发重新启动，但会触发实时重新加载。如果想自定义把这些排除，可以使用spring.devtools.restart.exclude属性。例如，仅排除/静态和/public，我们可以设置以下属性: 1spring.devtools.restart.exclude=static/**,public/** 如果您想保留这些默认值并添加额外的排除，可以使用spring.devtools.restart.additional- rejection属性。 监听更多的路径当我们对不在类路径上的文件进行更改时，我们可能希望应用程序重新启动或重新加载。为此，使用spring.devtools.restart.additional-paths属性配置其他路径以监视更改。我们可以使用前面描述的spring.devtools.restart.exclude属性来控制附加路径下的更改是触发完全重新启动还是实时重新加载。 禁用重启如果不想使用重启功能，可以使用spring.devtools.restart.enabled属性禁用它。在大多数情况下，我们可以在application.properties设置此属性(这样做仍然初始化重启类加载器，但它不注意文件的更改)。如果需要完全禁用重新启动支持(例如，因为它不能使用特定的库)，您需要在调用SpringApplication.run(…)之前将spring.devtools.restart.enabled System属性设置为false，如下面的示例所示: 1234public static void main(String[] args) &#123; System.setProperty("spring.devtools.restart.enabled", "false"); SpringApplication.run(MyApp.class, args);&#125; 使用触发器如果我们使用的IDE不断地编译已更改的文件，但是我们可能更希望只在特定的时间触发重新启动。为此，我们可以使用“trigger file”，这是一个特殊的文件，当我们希望实际触发重新启动检查时，必须对其进行修改。修改文件只会触发检查，只有在Devtools检测到它必须做一些事情时才会重新启动。触发器文件可以手动更新或使用IDE插件更新。 要使用触发器文件，请将spring.devtools.restart.trigger-file属性设置为触发器文件的路径。 自定义类加载器重启如前所述，在Restart vs Reload部分中，使用两个classloaders实现了Restart功能。对于大多数应用程序来说，这种方法运行良好。但是，它有时会导致类加载问题。默认情况下，IDE中的任何打开的项目都装载“重启”类加载器，任何常规的.jar文件都装载“基”类加载器。如果您正在处理一个多模块项目，并且不是每个模块都被导入到您的IDE中，那么您可能需要自定义一些东西。为此，您可以创建一个META-INF/spring-devtools.properties文件。 spring-devtools.properties文件可以包含以restart.exclude和restart.include为前缀的属性。include元素是应该被拉到“重启”类加载器中的项，而exclude元素则是应该被推入“基”类加载器的项。属性的值是应用于类路径的regex模式，如下面的示例所示: 12restart.exclude.companycommonlibs=/mycorp-common-[\\w-]+\.jarrestart.include.projectcommon=/mycorp-myproj-[\\w-]+\.jar 所有属性键必须是唯一的。它被认为是只要一个属性从restart.include或restart.exclude开始。 所有META-INF/spring-devtools.properties加载自类路径。我们可以在项目内部或项目所使用的库中打包文件。 已知限制通过使用标准的ObjectInputStream反序列化的对象，重新启动功能不能很好地工作。如果需要反序列化数据，可能需要结合使用Spring的ConfigurableObjectInputStream和Thread.currentThread().getcontextclassloader()。不幸的是，一些第三方库在不考虑上下文类加载器的情况下反序列化。如果发现这样的问题，我们需要向原始作者请求修复。 LiveReloadspring-boot-devtools模块包含一个嵌入式LiveReload服务器，当资源发生更改时，该服务器可用于触发浏览器刷新。LiveReload可以从livereload.com免费获得Chrome、Firefox和Safari浏览器扩展。 如果不希望在应用程序运行时启动LiveReload服务器，可以将spring.devtools.livereload.enabled属性设置为false。 一次只能运行一个LiveReload服务器。在启动应用程序之前，请确保没有其他LiveReload服务器正在运行。如果我们从IDE启动多个应用程序，只有第一个具有LiveReload支持。 全局设置您可以通过添加名为.spring-boot-devtools.properties的文件来配置全局devtools设置到$HOME文件夹(注意文件名以“.”开头)。任何添加到这个文件的属性都适用于使用devtools的计算机上的所有Spring Boot应用程序。例如，要配置restart始终使用触发器文件，需要添加以下属性: 123~/.spring-boot-devtools.properties. spring.devtools.reload.trigger-file=.reloadtrigger 远程应用Spring Boot developer工具不仅限于本地开发。在远程运行应用程序时，还可以使用几个特性。远程支持是可选的。要启用它，需要确保devtools包含在重新打包的归档文件中，如下所示: 1234567891011&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;excludeDevtools&gt;false&lt;/excludeDevtools&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 然后需要设置一个spring.devtools.remote.secret属性，如下面的示例所示: 1spring.devtools.remote.secret=mysecret 在远程应用程序上启用spring-boot-devtools存在安全风险。我们不应该在生产部署中启用支持。 远程devtools支持分为两部分:接受连接的服务器端端点和在IDE中运行的客户端应用程序。在设置好spring.devtools.remote.secret属性后，服务器组件将自动启用。必须手动启动客户端组件。 运行远程客户端应用程序远程客户端应用程序设计为在IDE中运行。我们需要运行org.springframe.boot.devtools.Remotespringapplication，其类路径与连接到的远程项目相同。应用程序的唯一必需参数是它连接的远程URL。 例如，如果我们正在使用Eclipse或STS，并且我们已经将一个名为my-app的项目部署到Cloud Foundry，那么您将执行以下操作: 从Run菜单中选择”Run Configuration…”。 创建一个新的Java应用程序“launch configuration”。 浏览my-app项目。 使用org.springframe.boot.devtools.remotespringapplication作为主类。 添加https://myapp.cfapps.io到程序参数(或任何远程URL)。 正在运行的远程客户端可能类似以下清单: 12345678910111213 . ____ _ __ _ _ /\\ / ___'_ __ _ _(_)_ __ __ _ ___ _ \ \ \ \( ( )\___ | '_ | '_| | '_ \/ _` | | _ \___ _ __ ___| |_ ___ \ \ \ \ \\/ ___)| |_)| | | | | || (_| []::::::[] / -_) ' \/ _ \ _/ -_) ) ) ) ) ' |____| .__|_| |_|_| |_\__, | |_|_\___|_|_|_\___/\__\___|/ / / / =========|_|==============|___/===================================/_/_/_/ :: Spring Boot Remote :: 2.0.3.RELEASE2015-06-10 18:25:06.632 INFO 14938 --- [ main] o.s.b.devtools.RemoteSpringApplication : Starting RemoteSpringApplication on pwmbp with PID 14938 (/Users/pwebb/projects/spring-boot/code/spring-boot-devtools/target/classes started by pwebb in /Users/pwebb/projects/spring-boot/code/spring-boot-samples/spring-boot-sample-devtools)2015-06-10 18:25:06.671 INFO 14938 --- [ main] s.c.a.AnnotationConfigApplicationContext : Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@2a17b7b6: startup date [Wed Jun 10 18:25:06 PDT 2015]; root of context hierarchy2015-06-10 18:25:07.043 WARN 14938 --- [ main] o.s.b.d.r.c.RemoteClientConfiguration : The connection to http://localhost:8080 is insecure. You should use a URL starting with 'https://'.2015-06-10 18:25:07.074 INFO 14938 --- [ main] o.s.b.d.a.OptionalLiveReloadServer : LiveReload server is running on port 357292015-06-10 18:25:07.130 INFO 14938 --- [ main] o.s.b.devtools.RemoteSpringApplication : Started RemoteSpringApplication in 0.74 seconds (JVM running for 1.105) 因为远程客户端使用与实际应用程序相同的类路径，所以可以直接读取应用程序属性。这就是spring.devtools.remote.secret属性的读取方式，并将其传递给服务器进行身份验证。 通常建议使用https:// 作为连接协议，这样就可以加密通信，无法截获密码。 如果需要使用代理访问远程应用程序，请配置spring.devtools.remote.proxy.host和spring.devtools.remote.proxy.port属性。 远程更新远程客户端以与本地重启相同的方式监视应用程序类路径的更改。将任何更新的资源推到远程应用程序，并(如果需要)触发重新启动。如果您对使用本地没有的云服务的特性进行迭代，这将非常有用。通常，远程更新和重新启动要比完整的重新构建和部署周期快得多。 只有在远程客户端运行时才对文件进行监视。如果在启动远程客户端之前更改文件，则不会将其推到远程服务器。 公众号扫码或微信搜索Vi的技术博客，关注公众号，不定期送书活动各种福利~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 系列（一）：HelloWorld]]></title>
    <url>%2F2018%2F06%2F21%2FPython3-%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AHelloWorld%2F</url>
    <content type="text"><![CDATA[前言：本系列教程面向有一定编程基础的人，熟悉IDE的操作，有面向对象的基础更佳。 简介:Python是著名的“龟叔”Guido van Rossum在1989年圣诞节期间，为了打发无聊的圣诞节而编写的一个编程语言。龟叔给Python的定位是“优雅”、“明确”、“简单”，所以Python程序看上去总是简单易懂，初学者学Python，不但入门容易，而且将来深入下去，可以编写那些非常非常复杂的程序。总的来说，Python的哲学就是极简既极美。 应用场景： 网络应用（网站，后台服务） 小工具（爬虫） 缺点： 运行速度非常慢，因为Python是解释型语言，就是你的代码在运行的时候会一行一行的翻译成机器码，与C相比，这个效率要慢许多。（不过无伤大雅，用户基本无感） 代码不能加密，发布你的Python的程序的时候，实际上就是在公布你的源码。 安装： 下载地址 下载完成之后，双击打开，这里需要注意一点： 打开命令行窗口，输入python，结果如下所示： Pycharm下编写第一个HelloWorld Pycharm下载 破解 修改hosts文件 将 0.0.0.0 account.jetbrains.com 添加到hosts文件最后，注意hosts文件无后缀，如果遇到无法修改或权限问题，可以采用覆盖的方法去替换hosts文件 修改后请检查hosts文件是否修改，激活码无法激活的原因99.99%是因为hosts没有修改正确 Windows系统hosts文件路径为：c:\windows\system32\drivers\etc 复制激活码 打开PyCharm选择Activation code激活，然后复制下面的激活码点击激活。 1EB101IWSWD-eyJsaWNlbnNlSWQiOiJFQjEwMUlXU1dEIiwibGljZW5zZWVOYW1lIjoibGFuIHl1IiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IkZvciBlZHVjYXRpb25hbCB1c2Ugb25seSIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiSUkiLCJwYWlkVXBUbyI6IjIwMTgtMTAtMTQifSx7ImNvZGUiOiJSUzAiLCJwYWlkVXBUbyI6IjIwMTgtMTAtMTQifSx7ImNvZGUiOiJXUyIsInBhaWRVcFRvIjoiMjAxOC0xMC0xNCJ9LHsiY29kZSI6IlJEIiwicGFpZFVwVG8iOiIyMDE4LTEwLTE0In0seyJjb2RlIjoiUkMiLCJwYWlkVXBUbyI6IjIwMTgtMTAtMTQifSx7ImNvZGUiOiJEQyIsInBhaWRVcFRvIjoiMjAxOC0xMC0xNCJ9LHsiY29kZSI6IkRCIiwicGFpZFVwVG8iOiIyMDE4LTEwLTE0In0seyJjb2RlIjoiUk0iLCJwYWlkVXBUbyI6IjIwMTgtMTAtMTQifSx7ImNvZGUiOiJETSIsInBhaWRVcFRvIjoiMjAxOC0xMC0xNCJ9LHsiY29kZSI6IkFDIiwicGFpZFVwVG8iOiIyMDE4LTEwLTE0In0seyJjb2RlIjoiRFBOIiwicGFpZFVwVG8iOiIyMDE4LTEwLTE0In0seyJjb2RlIjoiUFMiLCJwYWlkVXBUbyI6IjIwMTgtMTAtMTQifSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjAxOC0xMC0xNCJ9LHsiY29kZSI6IlBDIiwicGFpZFVwVG8iOiIyMDE4LTEwLTE0In0seyJjb2RlIjoiUlNVIiwicGFpZFVwVG8iOiIyMDE4LTEwLTE0In1dLCJoYXNoIjoiNjk0NDAzMi8wIiwiZ3JhY2VQZXJpb2REYXlzIjowLCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-Gbb7jeR8JWOVxdUFaXfJzVU/O7c7xHQyaidCnhYLp7v32zdeXiHUU7vlrrm5y9ZX0lmQk3plCCsW+phrC9gGAPd6WDKhkal10qVNg0larCR2tQ3u8jfv1t2JAvWrMOJfFG9kKsJuw1P4TozZ/E7Qvj1cupf/rldhoOmaXMyABxNN1af1RV3bVhe4FFZe0p7xlIJF/ctZkFK62HYmh8V3AyhUNTzrvK2k+t/tlDJz2LnW7nYttBLHld8LabPlEEjpTHswhzlthzhVqALIgvF0uNbIJ5Uwpb7NqR4U/2ob0Z+FIcRpFUIAHEAw+RLGwkCge5DyZKfx+RoRJ/In4q/UpA==-MIIEPjCCAiagAwIBAgIBBTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE1MTEwMjA4MjE0OFoXDTE4MTEwMTA4MjE0OFowETEPMA0GA1UEAwwGcHJvZDN5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQC9WZuYgQedSuOc5TOUSrRigMw4/+wuC5EtZBfvdl4HT/8vzMW/oUlIP4YCvA0XKyBaCJ2iX+ZCDKoPfiYXiaSiH+HxAPV6J79vvouxKrWg2XV6ShFtPLP+0gPdGq3x9R3+kJbmAm8w+FOdlWqAfJrLvpzMGNeDU14YGXiZ9bVzmIQbwrBA+c/F4tlK/DV07dsNExihqFoibnqDiVNTGombaU2dDup2gwKdL81ua8EIcGNExHe82kjF4zwfadHk3bQVvbfdAwxcDy4xBjs3L4raPLU3yenSzr/OEur1+jfOxnQSmEcMXKXgrAQ9U55gwjcOFKrgOxEdek/Sk1VfOjvS+nuM4eyEruFMfaZHzoQiuw4IqgGc45ohFH0UUyjYcuFxxDSU9lMCv8qdHKm+wnPRb0l9l5vXsCBDuhAGYD6ss+Ga+aDY6f/qXZuUCEUOH3QUNbbCUlviSz6+GiRnt1kA9N2Qachl+2yBfaqUqr8h7Z2gsx5LcIf5kYNsqJ0GavXTVyWh7PYiKX4bs354ZQLUwwa/cG++2+wNWP+HtBhVxMRNTdVhSm38AknZlD+PTAsWGu9GyLmhti2EnVwGybSD2Dxmhxk3IPCkhKAK+pl0eWYGZWG3tJ9mZ7SowcXLWDFAk0lRJnKGFMTggrWjV8GYpw5bq23VmIqqDLgkNzuoog== 开始编写 打开Pycharm，点击 Create new project 新建一个HelloWorld的项目 目录结构如下（关于venv虚拟环境会在后面单独讲解） 新建文件 文件内容 启动项目，展示成果 HelloWorld至此就大功告成了~ 下节预告:下节我们来一起学习Python的基础语法~ 公众号扫码或微信搜索Vi的技术博客，关注公众号，不定期送书活动各种福利~]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础专题（三）：字符串]]></title>
    <url>%2F2018%2F06%2F18%2FJava%E5%9F%BA%E7%A1%80%E4%B8%93%E9%A2%98%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[前言从概念上来讲，Java字符串就是Unicode字符序列。例如，”Java\u2122” 由5个Unicode字符J，a，v，a，和 ™。Java没有内置的字符串类型，而是在标准Java类库中提供了一个预定义类，叫做String。每个用双引号括起来的字符串都是String类的一个实例。 子串String类的substring方法可以从一个较大的字符串提取出一个子串。例如：12String greeting = "Hello"String s = greeting.substring(0,3) // s = "Hel" substring方法的第二个参数是不想复制的第一个位置。这里要复制位置为0，1和2（从0到2，包括0和2）的字符。在substring中从0开始计数，直到3为止，但不包括3。substring有一个优点：容易计算字串的长度。即substring（a,b）的长度为b-a。例如，子串“Hel”的长度为3-0=3 拼接与绝大多数的程序设计语言一样，Java语言允许使用 + 号连接（拼接）两个字符串。 123String expletive = "Expletive"String PG13 = "deleted"String message = expletive + PG13 // message = "Expletivedeleted" 当将一个字符串与一个非字符串的值进行拼接时，后者被转换成字符串。 12int age = 13;String rating = "PG" + age; //rating为 PG13 如果需要将多个字符串连接在一起，并用定界符分离，可以使用静态join方法 12String size = String.join(" / ", "S", "M", "L", "XL"); //size = "S / M / L / XL" 不可变字符串由于不能修改Java字符串中的字符，所以在Java文档中将String类对象称为不可变字符串，如同数字3永远是数字3一样，字符串“Hello”永远包含字符 H，e，l，l 和 o 的代码单元序列，而不能修改戏中的任何一个字符。当然，可以修改字符串变量，让它引用另一个字符串。 不可变字符串的优点是：编译器可以让字符串共享，即各种字符串存储在公共的存储池中，字符串变量值相存储池中相应的位置，如果复制一个字符串变量，原始字符串与复制的字符串共享相同的字符。 Java的设计者认为共享所带来的高效率远远胜于提取，拼接字符串所带来的低效率，因为我们很少需要修改字符串，更多的，我们是对字符串进行比较。 检测字符串是否相等可以使用equals方法判断两个字符串是否相等，对于表达式：1s.equals(t) 如果字符串 s 与字符串 t 相等，则返回true；否则，返回false。需要注意，s和t可以是字符串变量，也可以是字符串字面量。如果要想检测两个字符串是否相等，而不区分大小写，可以使用equalsIgnoreCase方法。 1"Hello".equalsIgnoreCase("hello") // true 一定不要使用==运算符检测两个字符串是否相等！！！这个运算符只能确定两个字符串是否放在同一个位置上，当然，如果字符串放置在同一个位置上，他们必然相等。但是，完全有可能将内容相同的多个字符串的拷贝放在不同的位置上。 123String greeting = "hello";if (greeting == "hello") // trueif (greeting.substring(0,3) == "hel") // false 因为只有字符串常量是共享的，而 + 或substring产生的结果并不是共享的。所以千万不要用 == 运算符测试字符串的相等性！ 空串与null串空串 “” 是长度为0的字符串。可以调用以下代码检查一个字符串是否为空：1if (str.length() == 0) 或1if (str.equals("")) 空串是一个Java对象，有自己的串长度（0）和内容（空）。不过，String变量还可以存放一个特殊的值，名为null，这表示目前没有任何对象与该变量关联 常用String API char charAt (int index)返回给定位置的代码单元。除非对底层的代码单元感兴趣，否则不需要调用这个方法。 int compareTo(String other)按照字典顺序，如果字符串位于other之前，返回一个负数；如果字符串位于other之后，返回一个正数；如果两个字符串相等，返回0 boolean equals(Object other)如果字符串与other相等，返回true boolean equalsIgnoreCase(String other)如果字符串与other相等（忽略大小写），返回true boolean startWith(String prefix) boolean endWith(String suffix)如果字符串以prefix（suffix）开头（结尾），则返回true int indexOf(String str) int indexOf(String str, int fromIndex) int indexOf(int cp) int indexOf(int cp, int fromIndex)返回与字符串str或代码点cp匹配的第一个子串的开始位置。这个位置从索引0或fromIndex开始计算。如果原始串中不存在str，返回-1 int lastIndexOf(String str) int lastIndexOf(String str, int fromIndex) int lastIndexOf(int cp) int lastIndexOf(int cp, int fromIndex)返回与字符串str或代码点cp匹配的最后一个子串的位置。这个位置从原始串尾端或fromIndex开始计算 int length()返回字符串的长度 String replace(CharSequence oldString, CharSequence newString)返回一个新字符串，这个字符串用newString代替原始字符串中的所有oldString。可以用String或StringBuilder对象作为CharSequence参数 String substring(int beginIndex) String substring(int beginIndex, int endIndex)返回一个新字符串。这个字符串包含原始字符串中从beginIndex到串尾或endIndex - 1的所有代码单元 String toLowerCase() String toUpperCase()返回一个新字符串，这个字符串将原始字符串中的大写字母改为小写，或者将原始字符串中的所有小写字母改成了大写字母。 String trim()返回一个新字符串，这个字符串将删除了原始字符串头部和尾部的空格。 String join(CharSequence delimiter, CharSequence…elements)返回一个新字符串，用给定的定界符连接所有元素。 参考资料Core Java Volume Ⅰ-Fundamentals 下期预告控制流程：块作用域，条件语句，循环，等等~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 2.0 系列（三）：流程详解（下）]]></title>
    <url>%2F2018%2F06%2F11%2FSpring-Boot-2-0-%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[自动配置Spring Boot自动配置尝试根据添加的jar依赖项自动配置Spring应用程序。例如，如果HSQLDB在我们的类路径上，并且我们没有手动配置任何数据库连接bean，那么Spring Boot将自动配置内存中的数据库。我们如果需要选择加入到自动配置可以通过将@EnableAutoConfiguration或@SpringBootApplication注释添加到我们的@Configuration类中。 我们应该只添加一个@SpringBootApplication或@EnableAutoConfiguration注释。我们通常建议只将一个或另一个添加到 @Configuration 主类中。 自定义自动配置自动配置具有良好的非侵入性。在任何时候，我们都可以开始定义自己的配置，以替换自动配置的特定部分。例如，如果我们添加自己的数据源bean，默认的嵌入式数据库支持就会退居幕后,而采用我们所配置的数据源bean。如果我们需要了解当前正在应用的自动配置，以及为什么要使用这些配置，可以使用--debug开关启动应用程序。这样做可以为核心日志记录器的选择提供调试日志，并将条件报告记录到控制台。 禁用特定类的自动配置如果我们发现我们不希望的特定自动配置类被应用，我们可以使用@EnableAutoConfiguration的排除属性来禁用它们，如下面的示例所示: 12345678import org.springframework.boot.autoconfigure.*;import org.springframework.boot.autoconfigure.jdbc.*;import org.springframework.context.annotation.*;@Configuration@EnableAutoConfiguration(exclude=&#123;DataSourceAutoConfiguration.class&#125;)public class MyConfiguration &#123;&#125; 如果类不在类路径上，则可以使用注释的 excludeName 属性并指定完全限定的名称。最后，我们还可以通过使用spring.autoconfigure.exclude排除属性来控制自动配置类的列表。 我们可以在注释级别和通过使用属性定义排除。 Spring bean和依赖项注入我们可以自由地使用任何标准Spring框架技术来定义bean及其注入的依赖项。为了简单起见，我们经常发现使用@ComponentScan(查找bean)和使用@Autowired(进行构造函数注入)非常有效。如果我们按照上面的建议构造代码(将应用程序类定位到根包中)，我们可以添加@ComponentScan，而不需要任何参数。所有应用程序组件(@Component， @Service， @Repository， @Controller等)都自动注册为Spring bean。下面的示例显示了一个@Service Bean： 12345678910111213141516import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class DatabaseAccountService implements AccountService &#123; private final RiskAssessor riskAssessor; @Autowired public DatabaseAccountService(RiskAssessor riskAssessor) &#123; this.riskAssessor = riskAssessor; &#125; // ...&#125; 如果一个bean有一个构造函数，可以省略@Autowired，如下面的示例所示: 123456789101112@Servicepublic class DatabaseAccountService implements AccountService &#123; private final RiskAssessor riskAssessor; public DatabaseAccountService(RiskAssessor riskAssessor) &#123; this.riskAssessor = riskAssessor; &#125; // ...&#125; 注意：如何使用构造函数注入让riskAssessor字段被标记为final，表明它不能随后更改。 使用@SpringBootApplication注解许多Spring Boot开发人员喜欢他们的应用程序使用自动配置、组件扫描并能够在“application class”上定义额外的配置。可以使用一个@SpringBootApplication注释来启用这三个特性，即:@EnableAutoConfiguration:启用Spring Boot的自动配置机制@ComponentScan:在应用程序所在的包上启用@Component扫描@Configuration:允许在上下文中注册额外的bean或导入额外的配置类@SpringBootApplication注释相当于使用@Configuration、@EnableAutoConfiguration和@ComponentScan的默认属性，如下面的示例所示: 1234567891011import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication // same as @Configuration @EnableAutoConfiguration @ComponentScanpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; @SpringBootApplication还提供别名来定制@EnableAutoConfiguration和@ComponentScan的属性。 这些特性中没有一个是强制性的，我们可以选择使用它支持的任何特性来替换这个单一注释。例如，我们可能不想在应用程序中使用组件扫描: 12345678910111213141516import org.springframework.boot.SpringApplication;import org.springframework.context.annotation.ComponentScanimport org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Import;@Configuration@EnableAutoConfiguration@Import(&#123; MyConfig.class, MyAnotherConfig.class &#125;)public class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 在本例中，应用程序与任何其他Spring Boot应用程序一样，只是不会自动检测到@component - anno类，并且显式地导入用户定义的bean(根据@Import)。 运行应用将应用程序打包为jar并使用嵌入式HTTP服务器的最大好处之一是，可以像运行其他应用程序一样运行应用程序。调试SpringBoot应用程序也很容易。我们不需要任何特殊的IDE插件或扩展。 本节只讨论基于jar的打包。如果我们选择将应用程序打包为war文件，我们应该参考服务器和IDE文档。 通过IDE启动我们可以将IDE中的SpringBoot应用程序作为一个简单的Java应用程序运行。但是，我们首先需要导入项目。导入步骤取决于我们的IDE和构建系统。大多数ide都可以直接导入Maven项目。如果我们不能直接将项目导入IDE，那么我们可以使用build插件生成IDE元数据。Maven包含Eclipse和IDEA的插件。Gradle提供各种ide的插件。 如果我们不小心运行了两次web应用程序，我们会看到一个“已经使用的端口”错误。STS用户可以使用Relaunch按钮而不是Run按钮来确保关闭任何现有实例。 作为打包的应用程序运行如果我们使用Spring Boot Maven或Gradle插件来创建可执行jar，我们可以使用java -jar来运行应用程序，如下例所示: 1$ java -jar target/myapplication-0.0.1-SNAPSHOT.jar 还可以运行支持远程调试的打包应用程序。这样做可以将调试器附加到打包的应用程序中，如下例所示: 12$ java -Xdebug -Xrunjdwp:server=y,transport=dt_socket,address=8000,suspend=n \ -jar target/myapplication-0.0.1-SNAPSHOT.jar 使用Maven插件Spring Boot Maven插件包含一个可以用来快速编译和运行应用程序的运行目标。应用程序迅速运行，就像它们在IDE中一样。下面的示例显示了运行Spring引导应用程序的典型Maven命令: 1$ mvn spring-boot:run 我们可能还想使用MAVEN_OPTS操作系统环境变量，如下面的示例所示: 1$ export MAVEN_OPTS=-Xmx1024m 使用Gradle插件Spring Boot Gradle插件还包含一个bootRun任务，该任务可用于迅速运行应用程序。每当应用org.springframework时，都会添加bootRun任务。引导和java插件，如下例所示: 1$ gradle bootRun 我们可能还想使用JAVA_OPTS操作系统环境变量，如下例所示: 1$ export JAVA_OPTS=-Xmx1024m ####下节预告： 详细介绍基于Spring Boot的热加载~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础专题（二）：运算符]]></title>
    <url>%2F2018%2F06%2F04%2FJava%E5%9F%BA%E7%A1%80%E4%B8%93%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[前言计算机的最基本用途之一就是执行数学运算，作为一门计算机语言，Java也提供了一套丰富的运算符来操纵变量。我们可以把运算符分成以下几组： 算术运算符 关系运算符 位运算符 逻辑运算符 赋值运算符 其他运算符 算术运算符算术运算符的运算结果为整型值或者浮点值 算术运算符如下表所示： 设 a = 1 , b = 2 运算符 描述 例子 + 将运算符两侧数值相加 a + b = 3 - 将运算符左侧数值减去右侧数值 a - b = -1 * 将运算符两侧数值相乘 a * b = 2 / 将运算符左侧数值除以右侧数值 b / a = 2 % 运算符左侧除以右侧的余数 b % a = 0 ++ 自增，当前数值 +1 b++， b = 3 – 自减，当前数值 -1 b–， b = 1 注意：自增和自减有两种形态：”前缀“和”后缀“，当单独使用的时候，两者并无区别，都是使当前操作的数值 +1 或 -1 ，但是当在表达式中使用的时候，二者就不太一样了，前缀形式会先完成 + 1；而后缀形式则会采用变量原来的值。 1234int m = 7;int n = 7;int a = 2 * ++m; // a = 16, m = 8int b = 2 * n++ // b = 14, n = 7 关系运算符关系运算符的结果为布尔值（ true / false）设 a = 1，b = 2 运算符 描述 例子 == 运算符两侧数值是否相等，如果相等结果为true a == b 为 false != 运算符两侧数值是否不相等，如果不相等结果为true a != b 为 true &gt; 运算符左侧的数值大于右侧，结果为true b &gt; a 为true &lt; 运算符左侧的数值小于右侧，结果为true a &lt; b 为true &gt;= 运算符左侧的数值大于等于右侧，结果为true b &gt;= a 为 true &lt;= 运算符左侧的数值小于等于右侧，结果为true a &lt;= b 为true 位运算符Java定义了位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。 位运算符作用在所有的位上，并且按位运算。假设a = 60，b = 13;它们的二进制格式表示将如下： 1234567a = 0011 1100b = 0000 1101a &amp; b = 0000 1100a | b = 0011 1101a ^ b = 0011 0001~a = 1100 0011 运算规则如下： 操作符 描述 例子 &amp; 同1为1 ，否则为0 a &amp; b = 0000 1100 丨 同0为0 ，否则为1 a 丨b = 0011 1101 ^ 相同为0，否则为1 a ^ b = 0011 0001 ~ 按位取反 ~a 即 1100 0011 &lt;&lt; 按位左移运算符。左操作数按位左移右操作数指定的位数。 a &lt;&lt; 2 即 1111 0000 >&gt; 按位右移运算符。左操作数按位右移右操作数指定的位数。 a &gt;&gt; 2 即 1111 >>&gt; 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。 a &gt;&gt;&gt;2 即 0000 1111 逻辑运算符a 为 true，b 为 false 操作符 描述 例子 &amp;&amp; 逻辑与运算符。当且仅当两个操作数都为真，条件才为真。 a &amp;&amp; b 为 false 丨丨 逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。 a 丨丨 b 为真 ! 逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。 ！（a &amp;&amp; b）为真。 注意：&amp;&amp; 和 || 具有短路的特性，也就是当第一个条件可以判断最终结果的时候，就不会去判断第二个条件。 赋值运算符 操作符 描述 例子 = 基础的赋值运算符，将右边的值赋给左边 c = a + b 就是将 a + b 的值赋给 c +(-，*，/，%，&lt;&lt;, &gt;&gt; ,&amp; ,^, )= 运算符左侧数值和右侧数值进行对应操作后赋给左侧 例如c += a 等价于 c = c + a 条件运算符（？：）条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。 12345678int a , b; a = 10; // 如果 a 等于 1 成立，则设置 b 为 20，否则为 30 b = (a == 1) ? 20 : 30; System.out.println( "Value of b is : " + b ); // 如果 a 等于 10 成立，则设置 b 为 20，否则为 30 b = (a == 10) ? 20 : 30; System.out.println( "Value of b is : " + b ); 123运算结果如下：Value of b is : 30Value of b is : 20 instanceof 运算符该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。 instanceof运算符使用格式如下： 123Vehicle a = new Car();boolean result = a instanceof Car;System.out.println( result); 结果如下：1true Java运算符优先级最高优先级的在该表上方，最低优先级的在该表底部 类别 操作符 关联性 后缀 （）[].(点操作符) 左到右 一元 ++ - ！~ 右到左 乘性 * / % 左到右 加性 + - 左到右 移位 >> >>> &lt;&lt; 左到右 关系 > >= = &lt; &lt;= 左到右 相等 == ~= 左到右 按位与 &amp; 左到右 按位异或 ^ 左到右 按位或 \丨 左到右 逻辑与 &amp;&amp; 左到右 逻辑或 丨丨 左到右 条件 ？： 从右到左 赋值 =，+=，-=，等等 从右到左 逗号 ， 左到右 参考资料Java运算符|菜鸟驿站 Core Java Volume Ⅰ-Fundamentals 下期预告下一期我们来聊一下关于字符串的前世今生~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 2.0 系列（二）：流程详解（上）]]></title>
    <url>%2F2018%2F06%2F01%2FSpringBoot-2-0-%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面本节将详细介绍如何使用Spring Boot。它涵盖了诸如项目管理及自动构建工具、自动配置以及如何运行应用程序等主题。我们还介绍了一些Spring Boot最佳实践。Spring Boot没有什么特别之处(它只是另一个我们可以使用的库)，但是有一些约定俗成的建议（“习惯优于配置”），如果遵循这些建议，将使我们的开发过程变得更容易一些。 项目管理及自动构建工具强烈建议您选择一个支持依赖项管理的构建系统，我们可以使用该系统得到发布到Maven中心仓库的组件。这里建议选择Maven或Gradle。虽然Spring Boot可以与其他构建系统(例如Ant)一起工作，但是它们并没有得到很好的支持。 1. 依赖关系管理Spring Boot的每一个版本都提供了它所支持的一个被整理的依赖项列表。实际上，我们不需要为构建配置中的任何依赖项提供版本，因为Spring Boot会为我们管理这些依赖项，当我们升级Spring Boot的时候，这些依赖项也会以一致的方式升级。 当然如果需要，我们仍然可以指定一个版本并覆盖Spring Boot的默认项。 Spring引导的每个版本都与Spring框架的一个基本版本相关联。我们强烈建议您不要指定它的版本。 2. MavenMaven用户可以从spring-boot-starter-parent项目继承来获得合理的默认值。parent项目提供以下特性: Java 1.8作为默认的编译器级别。 UTF - 8编码。 一个继承自spring-boot-dependencies pom的依赖管理部分，管理通用依赖项的版本。这个依赖项管理可以在自己的pom中使用这些依赖项时省略&lt; version&gt;标记。 合理的插件配置(exec插件，Git commit ID和shade)。 合理的资源过滤（例如：application.properties和application.yml）。包含特定于概要文件的文件（例如：application-dev.properties和application-dev.yml） 2.1 继承 Parent POM如果需要将项目配置为从spring-boot-starter-parent继承，请将 parent 设置为: 123456&lt;!-- Inherit defaults from Spring Boot --&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt;&lt;/parent&gt; 我们应该仅在此依赖项上指定Spring Boot版本号。如果我们导入其他starter，我们可以放心地省略版本号。 通过这种设置，我们还可以通过在自己的项目中覆盖属性来覆盖各个依赖项。例如，要升级到另一个Spring-Data release系列，我们可以在我们的pom.xml中添加以下内容: 123&lt;properties&gt; &lt;spring-data-releasetrain.version&gt;Fowler-SR2&lt;/spring-data-releasetrain.version&gt;&lt;/properties&gt; 2.2 不继承Parent POM不是每个人都喜欢从spring-boot-starter那里继承。我们可能需要使用您自己的企业标准parent，或者我们可能希望显式声明所有的Maven配置。如果我们不想使用spring-boot-starter-parent，我们仍然可以通过使用scope=import dependency来保持依赖关系管理(而不是插件管理)的好处，如下所示: 123456789101112&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;!-- Import dependency management from Spring Boot --&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 前面的示例设置不允许我们通过使用属性来覆盖各个依赖项，如上所述。要实现相同的结果，我们需要在spring-boot-dependencies条目之前在我们的项目的依赖项管理中添加一个条目。例如，要升级到另一个Spring Data release，我们可以在我们的pom.xml中添加以下元素: 12345678910111213141516171819&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- Override Spring Data release train provided by Spring Boot --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-releasetrain&lt;/artifactId&gt; &lt;version&gt;Fowler-SR2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 在前面的示例中，我们指定了一个BOM，但是任何依赖类型都可以以相同的方式重写。 3. 使用Spring Boot Maven PluginSpring Boot包含一个Maven插件，可以将项目打包为可执行jar。如果我们想使用这个插件，请将这个插件添加到&lt; plugins&gt;部分，如下例所示: 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 3. Gradlespringboot与gradle的结合篇幅较长，将放在后面单独来讲，敬请期待~ 4. Startersstarters是一组依赖描述符，我们可以在应用程序中包括这些描述符。我们可以为所有Spring和相关技术提供一站式服务，而无需通过示例代码和复制粘贴的依赖描述符来进行搜索。例如，如果我们希望开始使用Spring和JPA进行数据库访问，在项目中包含Spring -boot-starter-data- JPA依赖项就好。starters包含许多依赖项，我们需要这些依赖项来快速启动和运行项目，并且具有一组一致的、受支持的托管传递依赖项。 代码构建Spring Boot不需要任何特定的代码布局来工作。然而，有一些最佳实践对于我们来说显然是很有帮助的。 1. 使用默认包当一个类不包含包声明时，它被认为是在“默认包”中。一般不建议使用“默认包”，应该避免使用。它会给使用@ComponentScan、@EntityScan或@SpringBootApplication注解的Spring引导应用程序带来特别的问题，因为每个jar的每个类都被读取。 我们建议您遵循Java推荐的包命名约定，并使用一个反向的域名(例如，com.example.project)。 2. 定位 main application class我们通常建议您将main class置于其他类之上的root packge中。@SpringBootApplication注释通常放在主类上，它隐式地为某些项定义了基本的“搜索包”。例如，如果我们正在编写一个JPA应用程序，则使用@ SpringBootApplication带注释的类的包来搜索@Entity项。使用根包还允许组件扫描只应用于项目。 如果我们不想使用@SpringBootApplication，那么它导入的@EnableAutoConfiguration和@ComponentScan注释定义了这种行为，因此我们也可以使用它。 下面的清单展示了一个典型的布局: com +- example +- myapplication +- Application.java | +- customer | +- Customer.java | +- CustomerController.java | +- CustomerService.java | +- CustomerRepository.java | +- order +- Order.java +- OrderController.java +- OrderService.java +- OrderRepository.java Application.java文件将声明主方法和基本的@SpringBootApplication，如下所示: 12345678910111213package com.example.myapplication;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 配置类Spring Boot支持基于java的配置。虽然可以将SpringApplication与XML源一起使用，但是我们通常建议您的配置源是一个@Configuration类。通常，定义主方法的类作为主要的@Configuration是一个很好的选择。 许多Spring配置示例已经在Internet上发布，它们使用XML配置。如果可能的话，始终尝试使用等效的基于java的配置。搜索Enable*注释可能是一个很好的起点。 1. 导入额外的配置类不需要将所有的@Configuration放在一个类中。可以使用@Import注释来导入其他配置类，或者我们可以使用@ComponentScan自动提取所有Spring组件，包括@Configuration类。 2. 导入XML配置如果必须使用基于XML的配置，建议从一个@Configuration类开始。然后可以使用@ImportResource注释来加载XML配置文件。 下节预告： Auto-configuration Spring bean和依赖项注入 使用@SpringBootApplication注释……敬请期待 ~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础专题（一）：基本数据类型]]></title>
    <url>%2F2018%2F05%2F30%2FJava%E5%9F%BA%E7%A1%80%E4%B8%93%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[前言今天我们来聊一下Java这门语言的数据类型，众所周知，Java是一种强类型语言。在Java中，一共有8种基本类型，其中4种整形，2种浮点类型，1种用于表示Unicode编码的字符单元的字符类型char和1种用于表示真值的boolean类型。 整型整形用于表示没有小数部分的数值，允许为负。 类型 存储大小 取值范围 int 4字节 -2,147,483,648 ~ 2,147,483,647 short 2字节 -32,768 ~ 32,767 long 8字节 -9,223,372,036,854,775,808 ~ 9223,372,036,854,775,807 byte 1字节 -128 ~ 127 在Java中，整形的范围与运行Java代码的机器无关。这解决了软件从一个平台移植到另外一个平台，或者在同一个平台的不同操作系统之间进行移植给程序员带来的麻烦。 长整形（Long类型）数值后有一个后缀 L 或 l（这里建议不要使用小写的 l 来标识，因为在某些字体的格式下，1和 l 几乎没有任何区别，给月阅读的人带来很大的困扰）。 十六进制数值前缀为 0x 或 0X，这里需要说一点，八进制的前缀是0，比如010，这样的写法比较容易让人混淆，所以我们一般不要使用八进制来表示数据。 二进制数值的前缀为 0b 或 0B，例如0b1001所代表的十进制数据就是9。 从Java7开始，可以在数字字面量加下划线，比如1_000_000，这些下划线的作用仅仅是使代码的易读性更高，编译器在编译的时候会去除这些下划线。 浮点类型浮点类型用于表示有小数部分的数值，在Java中有两种浮点类型。 类型 存储大小 取值范围 float 4字节 大约 ± 3.402,823,47E+38F(有效位为6-7位) double 8字节 大约 ± 1.79769313486231570E+308（有效位15位） double表示这种类型的数值精度是float类型的两倍（故有人称double为双精度数值），事实上我们在使用的过程中，绝大多数情况都会选用double，因为float的精度通常无法满足我们的要求。 float类型的数值有一个后缀 f 或 F，没有后缀的浮点值就是double类型的。 可以使用十六进制来表示浮点数值，例如 0.125（2的负三次方）可以表示为 0x1.0p-3。在十六进制中，使用p表示指数，而不是e。 三个特殊的浮点数值： 1. 正无穷大（Double.POSITIVE_INFINITY） 2. 负无穷大（Double.NEGATIVE_INFINITY） 3. NAN（Double.NaN） char类型一个或两个char类型的数值可以用来表示一个Unicode字符，在代码中，char类型的字面量值需要用单引号括起来，char类型的值可以表示为以 \u 开头的16进制数值，用于表示一些标点和特殊符号所用。 一些较为特殊的字符的转移序列如下： 转义序列 名称 Unicode值 \b 退格 \u000 \t 制表 \u0009 \n 换行 \u000a \r 回车 \u000d \“ 双引号 \u0022 \‘ 单引号 \u0027 \\ 反斜杠 \u005c Unicode转义序列会在解析代码之前得到处理（大坑慎入！） 1// download uri d:\user\a，这里会报语法错误，因为 \u 后面没有跟着4个十六进制数。 布尔类型布尔类型有两个值：false和true，用来判定逻辑条件，整型值和布尔值之间不能互相转换，这一点与C或C++不同，需要留意一下。 参考文献 《Core Java Volume Ⅰ-Fundamentals》 – Cay S.Horstmann 下集预告下一期我们来见识一下Java中各种各样运算符的奥秘，三天一更，我们不见不散~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 2.0 系列（一）：快速开始]]></title>
    <url>%2F2018%2F05%2F28%2FSpring-Boot-2-0-%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[写在前面 SpringBoot版本：2.0.2 RELEASE 开发工具：IDEA 2017.2 相关资料：SpringBoot官方文档 1. 介绍SpringBootSpring Boot可以使我们轻松地创建独立的、生产级的基于Spring的应用程序，由于整合了一些对Spring和第三方库的配置，我们可以快速开始一个应用程序。大多数Spring Boot应用程序都需要很少的Spring配置。 我们可以使用Spring Boot来创建Java应用程序，这些应用程序可以通过使用 java -jar 或更传统的war部署来启动。Spring Boot还提供了一个运行“spring脚本”的命令行工具。 Spring Boot 为我们都做了什么: 为所有Spring开发人员提供一种快速而广泛的入门体验。 由于整合了一些对Spring和第三方库的配置解决了深受XML配置困扰的Spring开发人员的痛点 提供一系列非功能特性，这些特性在大型项目中是常见的(例如嵌入式服务器、安全、度量、健康检查和外部化配置)。 2.系统环境需求 Java 8 或 9 Spring 5.0.6 RELEASE 或 以上 构建工具 Maven 3.2 + Gradle 4 Spring Boot支持以下servlet容器: Tomcat 8.5 Jetty 9.4 Undertow 1.4 3. 构建项目的方式1.基于Maven的构建 pom.xml 内容如下： 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;myproject&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- Inherit defaults from Spring Boot --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;!-- Add typical dependencies for a web application --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- Package as an executable jar --&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2.基于Gradle的构建 bulid.gradle 内容如下： 123456789101112131415161718plugins &#123; id 'org.springframework.boot' version '2.0.2.RELEASE' id 'java'&#125;jar &#123; baseName = 'myproject' version = '0.0.1-SNAPSHOT'&#125;repositories &#123; jcenter()&#125;dependencies &#123; compile("org.springframework.boot:spring-boot-starter-web") testCompile("org.springframework.boot:spring-boot-starter-test")&#125; 4.开发Spring Boot 的Hello World 项目(使用maven构建工具) 第一步：创建pom文件 123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;myproject&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;!-- Additional lines to be added here... --&gt;&lt;/project&gt; 第二步：添加依赖 Spring Boot提供了许多“starter”，可以让您将jar添加到classpath 中。上文已经在POM的父部分使用了spring-boot-starter-parent。spring-boot-starter-parent是一个特殊的“starter”，它提供有用的Maven默认值。它还提供了一个依赖管理部分，这样我们就就可以为关联的依赖项省略版本标记。其他”starter”提供了在开发特定类型的应用程序时可能需要的依赖项。由于我们正在开发一个web应用程序，所以我们添加了一个spring-boot-starter-web依赖项。在此之前，我们可以通过运行以下命令查看当前所拥有的内容。 123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 第三步：编写代码 要完成我们的应用程序，我们需要创建一个Java文件，Java文件包含以下代码: 123456789101112131415161718import org.springframework.boot.*;import org.springframework.boot.autoconfigure.*;import org.springframework.web.bind.annotation.*;@RestController@EnableAutoConfigurationpublic class Example &#123; @RequestMapping("/") String home() &#123; return "Hello World!"; &#125; public static void main(String[] args) throws Exception &#123; SpringApplication.run(Example.class, args); &#125;&#125; 注：在我们的示例类上的第一个注释是@RestController。这被称为构造型注释。它为阅读代码的人们提供了一些提示，并且为Spring提供了一个特定的角色。在本例中，我们的类是一个web @Controller，所以Spring在处理传入web请求时考虑它。@RequestMapping注释提供路由信息。它告诉Spring，任何带有/ path的HTTP请求都应该映射到home方法。@RestController注释告诉Spring将生成的字符串直接呈现给调用者。 第二个类级别注释是@EnableAutoConfiguration。这个注释告诉Spring Boot基于您添加的jar依赖项“猜测”您想如何配置Spring，。因为Spring-boot-starter-web添加了Tomcat和Spring MVC，所以自动配置假设您正在开发一个web应用程序，并相应地设置Spring。 我们的应用程序的最后一部分是主方法。这只是遵循应用程序入口点的Java约定的标准方法。通过调用run，我们的main方法委托给Spring Boot的SpringApplication类。SpringApplication引导我们的应用程序启动Spring，而Spring又启动了自动配置的Tomcat web服务器。我们需要通过例子。类作为运行方法的参数，以告诉SpringApplication是主Spring组件。args数组也被传递，以公开任何命令行参数。 第四步：运行程序： 运行main方法，或者在根目录运行 mvn spring-boot: run命令。 12345678910111213$ mvn spring-boot:run . ____ _ __ _ _ /\\ / ___'_ __ _ _(_)_ __ __ _ \ \ \ \( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \ \\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.0.2.RELEASE)....... . . ........ . . . (log output here)....... . . ......... Started Example in 2.222 seconds (JVM running for 6.514) 打开浏览器，输入localhost:8080，你可以看到 1Hello World! 第五步：创建可执行的jar 将下列代码添加到pom.xml文件中： 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 保存文件，并在命令行输入maven package，可以看到： 123456789101112131415$ mvn package[INFO] Scanning for projects...[INFO][INFO] ------------------------------------------------------------------------[INFO] Building myproject 0.0.1-SNAPSHOT[INFO] ------------------------------------------------------------------------[INFO] .... ..[INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ myproject ---[INFO] Building jar: /Users/developer/example/spring-boot-example/target/myproject-0.0.1-SNAPSHOT.jar[INFO][INFO] --- spring-boot-maven-plugin:2.0.2.RELEASE:repackage (default) @ myproject ---[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------ 这时你会发现target目录下多了一个名为myprojectname-0.0.1-SNAPSHOT.jar的文件，文件大概10MB，如果你想查看文件的详细内容，可以使用 1$ jar tvf target/myproject-0.0.1-SNAPSHOT.jar 如果你想运行，可以使用 java -jar，如下： 12345678910111213$ java -jar target/myproject-0.0.1-SNAPSHOT.jar . ____ _ __ _ _ /\\ / ___'_ __ _ _(_)_ __ __ _ \ \ \ \( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \ \\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.0.2.RELEASE)....... . . ........ . . . (log output here)....... . . ......... Started Example in 2.536 seconds (JVM running for 2.864) 若知后事如何，且听下回分解~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《用户体验要素》读后笔记[完]（三）]]></title>
    <url>%2F2018%2F05%2F05%2F%E3%80%8A%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%A6%81%E7%B4%A0%E3%80%8B%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[结构层在定义好用户需求并排序好优先级别之后，我们对于最终差您将会包括什么特性已经有了清楚的图像，然而这些需求并没有说明如何将这些分散的片段组成一个整体，这就是范围层的上面一层：为网站建立一个概念结构。 结构层适当的将我们的关注点从抽象的决策与范围问题，转移到更能影响最后的用户体验的具体因素，传统的软件开发行业，涉及”为用户设计结构化体验”的方法被称为交互设计。在内容建设方面，主要是通过信息架构来构建用户体验。这两个都强调一个重点：确定各个将要呈现给用户的元素的“模式”和“顺序”。与其针对机器的最佳工作方式来设计系统，还不如设计一个对用户而言最好的系统，用户对于“交互组件将怎么样工作”的观点成为概念模型。概念模型是用于在交互设计的开发过程中保持使用方式的一致性的，交互设计会处理每一个级别的错误，以确保更高比例的用户能有积极的体验。 信息架构 信息架构所研究的是人们如何认知信息的过程，对于产品而言，信息架构关注的是呈现给用户的信息是否合理并具有意义 信息架构要求创建分类体系，创建分类体系的方法有从上向下和从下向上，但是这两种方法都有一定的局限性，唯一可避免两者缺点的方法是在两种方法中找到一个平衡点 一个高效结构的优点就是具备“容纳成长和适应变动”的能力 信息架构的基本单位是节点 节点的结构包括层级结构（树状、辐射）、矩阵结构、自然结构、线性结构 节点在信息架构是依据组织原则来安置的 我们的困难不是创建一个结构，而是在创建一个能与“我们的目标”和“用户的需求”相对应、正确的结构 成功的用户体验，就是能事先预知用户的期望并将其带入到设计当中去 “使用客户的语言”并且“保持一致性”是非常重要的，我们把用来强调一致性的工具称为受控词典 元数据的意思，简单地说就是“关于信息的信息”，即以一个结构化的方式来描述内容的信息。 框架层在充满概念的结构层中开始形成大量的需求，这些需求都是来自我们的战略目标的需求。在框架层，我们要更进一步的提炼这些结构，确定很详细的界面外观，导航和信息设计，这能让晦涩的结构变得实在。对于功能性产品，我们通过界面设计来确定框架，对于信息型产品，要解决的问题是导航设计，但是这两者都应解决信息设计这一方面。 提供给用户做某些事的能力，这属于界面设计。 提供给用户去某个地方的能力，这是导航设计。 传达想法给用户，那就是信息设计。 传统的习惯并非一定要死守，当某种方式有着不错的收益时，应该谨慎的试着违背一些习惯。 有效的使用比喻，即减少用户在理解你的产品时对猜测的要求。 界面设计的全部事情就是选择正确的界面元素 设计复杂系统的界面所面临的最大挑战之一，是弄清楚用户不需要哪些东西，并减少他们的可发现性。 导航设计必须完成以下三个目标： ① 提供用户一种在网页间跳转的方法 ② 元素与所包含内容之间的关系 ③ 内容与当前用户浏览页面之间的关系 多重导航系统： 全局导航，局部导航，辅助导航，上下文导航，友好导航，远程导航，网络地图，索引表 将信息设计和导航设计结合到一起，有一个重要的作用：支持指示标识。 页面布局是将信息设计、界面设计和导航设计放置到一起，形成一个统一的，有内在凝聚力的架构，这个架构的具体文档的展示方式为线框图。 线框图是整合在框架层的全部三种要素的方法：通过安排和选择界面元素来整合界面设计；通过识别和定义核心导航系统来整合导航设计；通过放置和排列信息组成部分的优先级来整合信息设计。 表现层在这五个模型的顶端，我们把注意力转移到产品用户会首先注意到的地方：感知设计，这里，内容、功能和美学汇集到一起来缠身一个最终设计，完成其他四个层面的所有目标，并同时满足用户的感官感受。 表现层中几乎所有的产品都会涉及到视觉设计，在视觉设计中，我们用于吸引用户注意的一个主要工具就是对比。 在你的设计中保持一致性是另一个重要的组成部分，它能使你的设计有效地传达信息，而不会导致用户迷惑或焦虑。“一致性”在视觉设计的许多不同方面都会起到作用。 内部和外部的一致性： ① 内部一致性的问题。这是说，在产品的两个不同的地方反映了不同的设计方法。 ② 外部一致性的问题。这是说，这个产品没有在同一个企业的其他产品中，反映出被使用的，相同的设计方法。 配色方案与排版对于品牌形象的建立，以及对于公众的影响显得尤为重要。 在视觉设计领域中对线框图最直接的模拟是视觉模型或设计合成品。 承载这些设计决策的权威性文档是风格指南。这个汇总文档确定了视觉设计的每个方面，从最大到最小的范围内的所有元素]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>UE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《用户体验要素》读后笔记（二）]]></title>
    <url>%2F2018%2F05%2F04%2F%E3%80%8A%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%A6%81%E7%B4%A0%E3%80%8B%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[战略层成功的用户体验，其基础是一个被明确表达的“战略”，知道企业与用户双方对产品的期许和目标，有助于促进用户体验各方面战略的确定和制定。 明确两个问题：我们要通过这个产品得到什么？ 我们的客户要通过这个产品得到什么？ ① 产品目标 ② 用户需求 产品目标： ① 商业目标（商业驱动因素） ② 品牌识别 ③ 成功标识 用户需求： ① 用户细分 1. 人口统计学 2. 消费心理档案 ② 可用性和用户研究 1. 市场调研方法 2. 现场调研 3. 任务分析 4. 用户测试 5. 卡片排序法 6. 用户模型 这是就需要一篇战略文档，而战略文档的关键在于简洁明了并切中要点，战略是设计用户体验设计流程中的起点。 范围层带着“我们想要什么”、“我们的用户想要什么”的明确认识，我们才能弄清楚如何去满足这些战略的目标，当你把用户需求和产品目标转变成产品应该提供给用户什么样的内容和功能时，战略就变成了范围。 用文档定义产品需求的必要性： ① 这样你才知道你在建设什么 ② 这样你才知道你不需要建设什么 范围层被功能型产品和信息型产品分为了功能规格和内容需求，定义需求的详略层度往往取决于该项目的具体范围。 功能规格说明： 文档不能解决问题，但定义可以，我们需要的不是文档有厚或有多详细，而是要足够清楚和准确。 乐观：描述这个系统将要做什么事情去“防止”不好的情况发生 具体：尽可能详细的解释清楚情况 在文档中要尽量避免主观的语气 内容需求： 应该提供每一个特性规模的文档预估：文本的字数，图片的像素大小，下载的文件字节、PDF或音频文件等独立元素的大小等。 内容特性的更新频率来自于产品的战略目标，必须确定一个频率，它是介于你的用户期望值和有效值之间 确定需求优先级： 有些特性可能会因为技术上的局限无法实现，有些则是因为资源与时间上的不足 很少有功能时独立存在的 如果你的战略计划或愿景文档在战略目标的范围内制定了一个清晰的优先级别顺序，那么这些优先级别应该是决定是否采纳人们所建议的相关特性的首要因素]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>UE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《用户体验要素》 读后笔记（一）]]></title>
    <url>%2F2018%2F05%2F04%2F%E3%80%8A%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%A6%81%E7%B4%A0%E3%80%8B%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[最近有幸拜读了Jesse James Garrett所著的用户体验要素这本书，感触颇多，感觉对于UE这门课程有了一个较为系统的认识，知道了用户体验为什么是如此的重要，以及用户体验的五个元素。 在产品开发过程中,人们更多的关注what to do, 设计师经常忽略的另一个因素是how to do, 而这一因素恰恰是决定产品成败的关键因素。 “外形服从于功能” 这种观点对于产品的内部运作(用户不可见的部分)是完全适用的, 但是, 对于产品直接面向用户的那些部分—按钮, 布局, 文字, 也包括外观, 正确的产品形态绝对不是由”功能”所决定的, 而是应该由”用户自身的心理感受和行为“来决定的 提供优质的用户体验, 是一个重要的可持续的竞争优势 —— 不仅仅对网站是这样, 对所有类型的产品和服务都是如此 创建吸引人的,高效的用户体验的方法称为”以用户为中心的设计”. 以用户为中心的设计思想非常简单,: 在开发产品的每一个步骤中, 都要把用户列入考虑范围，下面我们来认识一下这些要素。 五个要素用户体验开发时的五个要素(5s) 表现层(surface) 一系列的网页, 由图片和文字组成 框架层(skeleton) 按钮, 控件, 照片和文本区域的位置, 优化设计布局, 以达到这些元素的最大效果和效率 结构层(structure) 框架是结构的具体表达方式 范围层(scope) 结构层确定网站各种特性和功能最合适的组合方式, 而这些特性和功能就构成了网站的范围层 战略层(strategy) 网站的范围基本上是由网站战略层决定的 双重性自下而上的建设，并且让每一个层面的工作在下一个层面可以结束之前完成，网站具有基本的双重性，描述功能型的平台类产品和描述信息的媒介类产品。 功能性产品, 主要关注的任务, 所有的操作都被纳入一个过程, 去思考人们如何完成这个过程, 这里的网站实际上是用户用于完成任务的一种工具 信息性产品, 主要的关注点是信息, 创建一个富信息的用户体验, 就是提供给用户一个可以寻找, 理解且有意义的组合 区别和联系1.战略层所关注的内容都是一样的, 来自企业外部的用户需求和来自自己对网站的期望目标。 2.由范围层进入战略层, 在功能型产品一侧转化为功能规格: 对产品的&quot;功能组合&quot;的详细描述. 而在信息型产品一侧, 范围则是以内容需求的形式出现: 对各种内容元素的要求的详细描述。 3.在功能性产品一侧, 结构层将从范围转化为交互设计, 在这里我们可以定义系统如何响应用户的请求,另一侧是信息架构: 合理的安排内容元素以促进人类理解信息 4.在框架层, 必不可少的是信息设计, 功能性产品偏向于界面设计, 而信息类产品, 则偏向于导航设计. 5.最后, 在表现层, 关注点都在于最终产品创建用户体验]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>UE</tag>
      </tags>
  </entry>
</search>
