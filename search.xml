<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python3 系列（一）：HelloWorld]]></title>
    <url>%2F2018%2F06%2F21%2FPython3-%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AHelloWorld%2F</url>
    <content type="text"><![CDATA[前言：本系列教程面向有一定编程基础的人，熟悉IDE的操作，有面向对象的基础更佳。 简介:Python是著名的“龟叔”Guido van Rossum在1989年圣诞节期间，为了打发无聊的圣诞节而编写的一个编程语言。龟叔给Python的定位是“优雅”、“明确”、“简单”，所以Python程序看上去总是简单易懂，初学者学Python，不但入门容易，而且将来深入下去，可以编写那些非常非常复杂的程序。总的来说，Python的哲学就是极简既极美。 应用场景： 网络应用（网站，后台服务） 小工具（爬虫） 缺点： 运行速度非常慢，因为Python是解释型语言，就是你的代码在运行的时候会一行一行的翻译成机器码，与C相比，这个效率要慢许多。（不过无伤大雅，用户基本无感） 代码不能加密，发布你的Python的程序的时候，实际上就是在公布你的源码。 安装： 下载地址 下载完成之后，双击打开，这里需要注意一点： 打开命令行窗口，输入python，结果如下所示： Pycharm下编写第一个HelloWorld Pycharm下载 破解 修改hosts文件 将 0.0.0.0 account.jetbrains.com 添加到hosts文件最后，注意hosts文件无后缀，如果遇到无法修改或权限问题，可以采用覆盖的方法去替换hosts文件 修改后请检查hosts文件是否修改，激活码无法激活的原因99.99%是因为hosts没有修改正确 Windows系统hosts文件路径为：c:\windows\system32\drivers\etc 复制激活码 打开PyCharm选择Activation code激活，然后复制下面的激活码点击激活。 1EB101IWSWD-eyJsaWNlbnNlSWQiOiJFQjEwMUlXU1dEIiwibGljZW5zZWVOYW1lIjoibGFuIHl1IiwiYXNzaWduZWVOYW1lIjoiIiwiYXNzaWduZWVFbWFpbCI6IiIsImxpY2Vuc2VSZXN0cmljdGlvbiI6IkZvciBlZHVjYXRpb25hbCB1c2Ugb25seSIsImNoZWNrQ29uY3VycmVudFVzZSI6ZmFsc2UsInByb2R1Y3RzIjpbeyJjb2RlIjoiSUkiLCJwYWlkVXBUbyI6IjIwMTgtMTAtMTQifSx7ImNvZGUiOiJSUzAiLCJwYWlkVXBUbyI6IjIwMTgtMTAtMTQifSx7ImNvZGUiOiJXUyIsInBhaWRVcFRvIjoiMjAxOC0xMC0xNCJ9LHsiY29kZSI6IlJEIiwicGFpZFVwVG8iOiIyMDE4LTEwLTE0In0seyJjb2RlIjoiUkMiLCJwYWlkVXBUbyI6IjIwMTgtMTAtMTQifSx7ImNvZGUiOiJEQyIsInBhaWRVcFRvIjoiMjAxOC0xMC0xNCJ9LHsiY29kZSI6IkRCIiwicGFpZFVwVG8iOiIyMDE4LTEwLTE0In0seyJjb2RlIjoiUk0iLCJwYWlkVXBUbyI6IjIwMTgtMTAtMTQifSx7ImNvZGUiOiJETSIsInBhaWRVcFRvIjoiMjAxOC0xMC0xNCJ9LHsiY29kZSI6IkFDIiwicGFpZFVwVG8iOiIyMDE4LTEwLTE0In0seyJjb2RlIjoiRFBOIiwicGFpZFVwVG8iOiIyMDE4LTEwLTE0In0seyJjb2RlIjoiUFMiLCJwYWlkVXBUbyI6IjIwMTgtMTAtMTQifSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjAxOC0xMC0xNCJ9LHsiY29kZSI6IlBDIiwicGFpZFVwVG8iOiIyMDE4LTEwLTE0In0seyJjb2RlIjoiUlNVIiwicGFpZFVwVG8iOiIyMDE4LTEwLTE0In1dLCJoYXNoIjoiNjk0NDAzMi8wIiwiZ3JhY2VQZXJpb2REYXlzIjowLCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-Gbb7jeR8JWOVxdUFaXfJzVU/O7c7xHQyaidCnhYLp7v32zdeXiHUU7vlrrm5y9ZX0lmQk3plCCsW+phrC9gGAPd6WDKhkal10qVNg0larCR2tQ3u8jfv1t2JAvWrMOJfFG9kKsJuw1P4TozZ/E7Qvj1cupf/rldhoOmaXMyABxNN1af1RV3bVhe4FFZe0p7xlIJF/ctZkFK62HYmh8V3AyhUNTzrvK2k+t/tlDJz2LnW7nYttBLHld8LabPlEEjpTHswhzlthzhVqALIgvF0uNbIJ5Uwpb7NqR4U/2ob0Z+FIcRpFUIAHEAw+RLGwkCge5DyZKfx+RoRJ/In4q/UpA==-MIIEPjCCAiagAwIBAgIBBTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE1MTEwMjA4MjE0OFoXDTE4MTEwMTA4MjE0OFowETEPMA0GA1UEAwwGcHJvZDN5MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQC9WZuYgQedSuOc5TOUSrRigMw4/+wuC5EtZBfvdl4HT/8vzMW/oUlIP4YCvA0XKyBaCJ2iX+ZCDKoPfiYXiaSiH+HxAPV6J79vvouxKrWg2XV6ShFtPLP+0gPdGq3x9R3+kJbmAm8w+FOdlWqAfJrLvpzMGNeDU14YGXiZ9bVzmIQbwrBA+c/F4tlK/DV07dsNExihqFoibnqDiVNTGombaU2dDup2gwKdL81ua8EIcGNExHe82kjF4zwfadHk3bQVvbfdAwxcDy4xBjs3L4raPLU3yenSzr/OEur1+jfOxnQSmEcMXKXgrAQ9U55gwjcOFKrgOxEdek/Sk1VfOjvS+nuM4eyEruFMfaZHzoQiuw4IqgGc45ohFH0UUyjYcuFxxDSU9lMCv8qdHKm+wnPRb0l9l5vXsCBDuhAGYD6ss+Ga+aDY6f/qXZuUCEUOH3QUNbbCUlviSz6+GiRnt1kA9N2Qachl+2yBfaqUqr8h7Z2gsx5LcIf5kYNsqJ0GavXTVyWh7PYiKX4bs354ZQLUwwa/cG++2+wNWP+HtBhVxMRNTdVhSm38AknZlD+PTAsWGu9GyLmhti2EnVwGybSD2Dxmhxk3IPCkhKAK+pl0eWYGZWG3tJ9mZ7SowcXLWDFAk0lRJnKGFMTggrWjV8GYpw5bq23VmIqqDLgkNzuoog== 开始编写 打开Pycharm，点击 Create new project 新建一个HelloWorld的项目 目录结构如下（关于venv虚拟环境会在后面单独讲解） 新建文件 文件内容 启动项目，展示成果 HelloWorld至此就大功告成了~ 下节预告:下节我们来一起学习Python的基础语法~ 公众号扫码或微信搜索Vi的技术博客，关注公众号，不定期送书活动各种福利~]]></content>
      <categories>
        <category>Python3</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础专题（三）：字符串]]></title>
    <url>%2F2018%2F06%2F18%2FJava%E5%9F%BA%E7%A1%80%E4%B8%93%E9%A2%98%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[前言从概念上来讲，Java字符串就是Unicode字符序列。例如，”Java\u2122” 由5个Unicode字符J，a，v，a，和 ™。Java没有内置的字符串类型，而是在标准Java类库中提供了一个预定义类，叫做String。每个用双引号括起来的字符串都是String类的一个实例。 子串String类的substring方法可以从一个较大的字符串提取出一个子串。例如：12String greeting = "Hello"String s = greeting.substring(0,3) // s = "Hel" substring方法的第二个参数是不想复制的第一个位置。这里要复制位置为0，1和2（从0到2，包括0和2）的字符。在substring中从0开始计数，直到3为止，但不包括3。substring有一个优点：容易计算字串的长度。即substring（a,b）的长度为b-a。例如，子串“Hel”的长度为3-0=3 拼接与绝大多数的程序设计语言一样，Java语言允许使用 + 号连接（拼接）两个字符串。 123String expletive = "Expletive"String PG13 = "deleted"String message = expletive + PG13 // message = "Expletivedeleted" 当将一个字符串与一个非字符串的值进行拼接时，后者被转换成字符串。 12int age = 13;String rating = "PG" + age; //rating为 PG13 如果需要将多个字符串连接在一起，并用定界符分离，可以使用静态join方法 12String size = String.join(" / ", "S", "M", "L", "XL"); //size = "S / M / L / XL" 不可变字符串由于不能修改Java字符串中的字符，所以在Java文档中将String类对象称为不可变字符串，如同数字3永远是数字3一样，字符串“Hello”永远包含字符 H，e，l，l 和 o 的代码单元序列，而不能修改戏中的任何一个字符。当然，可以修改字符串变量，让它引用另一个字符串。 不可变字符串的优点是：编译器可以让字符串共享，即各种字符串存储在公共的存储池中，字符串变量值相存储池中相应的位置，如果复制一个字符串变量，原始字符串与复制的字符串共享相同的字符。 Java的设计者认为共享所带来的高效率远远胜于提取，拼接字符串所带来的低效率，因为我们很少需要修改字符串，更多的，我们是对字符串进行比较。 检测字符串是否相等可以使用equals方法判断两个字符串是否相等，对于表达式：1s.equals(t) 如果字符串 s 与字符串 t 相等，则返回true；否则，返回false。需要注意，s和t可以是字符串变量，也可以是字符串字面量。如果要想检测两个字符串是否相等，而不区分大小写，可以使用equalsIgnoreCase方法。 1"Hello".equalsIgnoreCase("hello") // true 一定不要使用==运算符检测两个字符串是否相等！！！这个运算符只能确定两个字符串是否放在同一个位置上，当然，如果字符串放置在同一个位置上，他们必然相等。但是，完全有可能将内容相同的多个字符串的拷贝放在不同的位置上。 123String greeting = "hello";if (greeting == "hello") // trueif (greeting.substring(0,3) == "hel") // false 因为只有字符串常量是共享的，而 + 或substring产生的结果并不是共享的。所以千万不要用 == 运算符测试字符串的相等性！ 空串与null串空串 “” 是长度为0的字符串。可以调用以下代码检查一个字符串是否为空：1if (str.length() == 0) 或1if (str.equals("")) 空串是一个Java对象，有自己的串长度（0）和内容（空）。不过，String变量还可以存放一个特殊的值，名为null，这表示目前没有任何对象与该变量关联 常用String API char charAt (int index)返回给定位置的代码单元。除非对底层的代码单元感兴趣，否则不需要调用这个方法。 int compareTo(String other)按照字典顺序，如果字符串位于other之前，返回一个负数；如果字符串位于other之后，返回一个正数；如果两个字符串相等，返回0 boolean equals(Object other)如果字符串与other相等，返回true boolean equalsIgnoreCase(String other)如果字符串与other相等（忽略大小写），返回true boolean startWith(String prefix) boolean endWith(String suffix)如果字符串以prefix（suffix）开头（结尾），则返回true int indexOf(String str) int indexOf(String str, int fromIndex) int indexOf(int cp) int indexOf(int cp, int fromIndex)返回与字符串str或代码点cp匹配的第一个子串的开始位置。这个位置从索引0或fromIndex开始计算。如果原始串中不存在str，返回-1 int lastIndexOf(String str) int lastIndexOf(String str, int fromIndex) int lastIndexOf(int cp) int lastIndexOf(int cp, int fromIndex)返回与字符串str或代码点cp匹配的最后一个子串的位置。这个位置从原始串尾端或fromIndex开始计算 int length()返回字符串的长度 String replace(CharSequence oldString, CharSequence newString)返回一个新字符串，这个字符串用newString代替原始字符串中的所有oldString。可以用String或StringBuilder对象作为CharSequence参数 String substring(int beginIndex) String substring(int beginIndex, int endIndex)返回一个新字符串。这个字符串包含原始字符串中从beginIndex到串尾或endIndex - 1的所有代码单元 String toLowerCase() String toUpperCase()返回一个新字符串，这个字符串将原始字符串中的大写字母改为小写，或者将原始字符串中的所有小写字母改成了大写字母。 String trim()返回一个新字符串，这个字符串将删除了原始字符串头部和尾部的空格。 String join(CharSequence delimiter, CharSequence…elements)返回一个新字符串，用给定的定界符连接所有元素。 参考资料Core Java Volume Ⅰ-Fundamentals 下期预告控制流程：块作用域，条件语句，循环，等等~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 2.0 系列（三）：流程详解（下）]]></title>
    <url>%2F2018%2F06%2F11%2FSpring-Boot-2-0-%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%89%EF%BC%89%EF%BC%9A%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[自动配置Spring Boot自动配置尝试根据添加的jar依赖项自动配置Spring应用程序。例如，如果HSQLDB在我们的类路径上，并且我们没有手动配置任何数据库连接bean，那么Spring Boot将自动配置内存中的数据库。我们如果需要选择加入到自动配置可以通过将@EnableAutoConfiguration或@SpringBootApplication注释添加到我们的@Configuration类中。 我们应该只添加一个@SpringBootApplication或@EnableAutoConfiguration注释。我们通常建议只将一个或另一个添加到 @Configuration 主类中。 自定义自动配置自动配置具有良好的非侵入性。在任何时候，我们都可以开始定义自己的配置，以替换自动配置的特定部分。例如，如果我们添加自己的数据源bean，默认的嵌入式数据库支持就会退居幕后,而采用我们所配置的数据源bean。如果我们需要了解当前正在应用的自动配置，以及为什么要使用这些配置，可以使用--debug开关启动应用程序。这样做可以为核心日志记录器的选择提供调试日志，并将条件报告记录到控制台。 禁用特定类的自动配置如果我们发现我们不希望的特定自动配置类被应用，我们可以使用@EnableAutoConfiguration的排除属性来禁用它们，如下面的示例所示: 12345678import org.springframework.boot.autoconfigure.*;import org.springframework.boot.autoconfigure.jdbc.*;import org.springframework.context.annotation.*;@Configuration@EnableAutoConfiguration(exclude=&#123;DataSourceAutoConfiguration.class&#125;)public class MyConfiguration &#123;&#125; 如果类不在类路径上，则可以使用注释的 excludeName 属性并指定完全限定的名称。最后，我们还可以通过使用spring.autoconfigure.exclude排除属性来控制自动配置类的列表。 我们可以在注释级别和通过使用属性定义排除。 Spring bean和依赖项注入我们可以自由地使用任何标准Spring框架技术来定义bean及其注入的依赖项。为了简单起见，我们经常发现使用@ComponentScan(查找bean)和使用@Autowired(进行构造函数注入)非常有效。如果我们按照上面的建议构造代码(将应用程序类定位到根包中)，我们可以添加@ComponentScan，而不需要任何参数。所有应用程序组件(@Component， @Service， @Repository， @Controller等)都自动注册为Spring bean。下面的示例显示了一个@Service Bean： 12345678910111213141516import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class DatabaseAccountService implements AccountService &#123; private final RiskAssessor riskAssessor; @Autowired public DatabaseAccountService(RiskAssessor riskAssessor) &#123; this.riskAssessor = riskAssessor; &#125; // ...&#125; 如果一个bean有一个构造函数，可以省略@Autowired，如下面的示例所示: 123456789101112@Servicepublic class DatabaseAccountService implements AccountService &#123; private final RiskAssessor riskAssessor; public DatabaseAccountService(RiskAssessor riskAssessor) &#123; this.riskAssessor = riskAssessor; &#125; // ...&#125; 注意：如何使用构造函数注入让riskAssessor字段被标记为final，表明它不能随后更改。 使用@SpringBootApplication注解许多Spring Boot开发人员喜欢他们的应用程序使用自动配置、组件扫描并能够在“application class”上定义额外的配置。可以使用一个@SpringBootApplication注释来启用这三个特性，即:@EnableAutoConfiguration:启用Spring Boot的自动配置机制@ComponentScan:在应用程序所在的包上启用@Component扫描@Configuration:允许在上下文中注册额外的bean或导入额外的配置类@SpringBootApplication注释相当于使用@Configuration、@EnableAutoConfiguration和@ComponentScan的默认属性，如下面的示例所示: 1234567891011import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication // same as @Configuration @EnableAutoConfiguration @ComponentScanpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; @SpringBootApplication还提供别名来定制@EnableAutoConfiguration和@ComponentScan的属性。 这些特性中没有一个是强制性的，我们可以选择使用它支持的任何特性来替换这个单一注释。例如，我们可能不想在应用程序中使用组件扫描: 12345678910111213141516import org.springframework.boot.SpringApplication;import org.springframework.context.annotation.ComponentScanimport org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Import;@Configuration@EnableAutoConfiguration@Import(&#123; MyConfig.class, MyAnotherConfig.class &#125;)public class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 在本例中，应用程序与任何其他Spring Boot应用程序一样，只是不会自动检测到@component - anno类，并且显式地导入用户定义的bean(根据@Import)。 运行应用将应用程序打包为jar并使用嵌入式HTTP服务器的最大好处之一是，可以像运行其他应用程序一样运行应用程序。调试SpringBoot应用程序也很容易。我们不需要任何特殊的IDE插件或扩展。 本节只讨论基于jar的打包。如果我们选择将应用程序打包为war文件，我们应该参考服务器和IDE文档。 通过IDE启动我们可以将IDE中的SpringBoot应用程序作为一个简单的Java应用程序运行。但是，我们首先需要导入项目。导入步骤取决于我们的IDE和构建系统。大多数ide都可以直接导入Maven项目。如果我们不能直接将项目导入IDE，那么我们可以使用build插件生成IDE元数据。Maven包含Eclipse和IDEA的插件。Gradle提供各种ide的插件。 如果我们不小心运行了两次web应用程序，我们会看到一个“已经使用的端口”错误。STS用户可以使用Relaunch按钮而不是Run按钮来确保关闭任何现有实例。 作为打包的应用程序运行如果我们使用Spring Boot Maven或Gradle插件来创建可执行jar，我们可以使用java -jar来运行应用程序，如下例所示: 1$ java -jar target/myapplication-0.0.1-SNAPSHOT.jar 还可以运行支持远程调试的打包应用程序。这样做可以将调试器附加到打包的应用程序中，如下例所示: 12$ java -Xdebug -Xrunjdwp:server=y,transport=dt_socket,address=8000,suspend=n \ -jar target/myapplication-0.0.1-SNAPSHOT.jar 使用Maven插件Spring Boot Maven插件包含一个可以用来快速编译和运行应用程序的运行目标。应用程序迅速运行，就像它们在IDE中一样。下面的示例显示了运行Spring引导应用程序的典型Maven命令: 1$ mvn spring-boot:run 我们可能还想使用MAVEN_OPTS操作系统环境变量，如下面的示例所示: 1$ export MAVEN_OPTS=-Xmx1024m 使用Gradle插件Spring Boot Gradle插件还包含一个bootRun任务，该任务可用于迅速运行应用程序。每当应用org.springframework时，都会添加bootRun任务。引导和java插件，如下例所示: 1$ gradle bootRun 我们可能还想使用JAVA_OPTS操作系统环境变量，如下例所示: 1$ export JAVA_OPTS=-Xmx1024m ####下节预告： 详细介绍基于Spring Boot的热加载~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础专题（二）：运算符]]></title>
    <url>%2F2018%2F06%2F04%2FJava%E5%9F%BA%E7%A1%80%E4%B8%93%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[前言计算机的最基本用途之一就是执行数学运算，作为一门计算机语言，Java也提供了一套丰富的运算符来操纵变量。我们可以把运算符分成以下几组： 算术运算符 关系运算符 位运算符 逻辑运算符 赋值运算符 其他运算符 算术运算符算术运算符的运算结果为整型值或者浮点值 算术运算符如下表所示： 设 a = 1 , b = 2 运算符 描述 例子 + 将运算符两侧数值相加 a + b = 3 - 将运算符左侧数值减去右侧数值 a - b = -1 * 将运算符两侧数值相乘 a * b = 2 / 将运算符左侧数值除以右侧数值 b / a = 2 % 运算符左侧除以右侧的余数 b % a = 0 ++ 自增，当前数值 +1 b++， b = 3 – 自减，当前数值 -1 b–， b = 1 注意：自增和自减有两种形态：”前缀“和”后缀“，当单独使用的时候，两者并无区别，都是使当前操作的数值 +1 或 -1 ，但是当在表达式中使用的时候，二者就不太一样了，前缀形式会先完成 + 1；而后缀形式则会采用变量原来的值。 1234int m = 7;int n = 7;int a = 2 * ++m; // a = 16, m = 8int b = 2 * n++ // b = 14, n = 7 关系运算符关系运算符的结果为布尔值（ true / false）设 a = 1，b = 2 运算符 描述 例子 == 运算符两侧数值是否相等，如果相等结果为true a == b 为 false != 运算符两侧数值是否不相等，如果不相等结果为true a != b 为 true &gt; 运算符左侧的数值大于右侧，结果为true b &gt; a 为true &lt; 运算符左侧的数值小于右侧，结果为true a &lt; b 为true &gt;= 运算符左侧的数值大于等于右侧，结果为true b &gt;= a 为 true &lt;= 运算符左侧的数值小于等于右侧，结果为true a &lt;= b 为true 位运算符Java定义了位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。 位运算符作用在所有的位上，并且按位运算。假设a = 60，b = 13;它们的二进制格式表示将如下： 1234567a = 0011 1100b = 0000 1101a &amp; b = 0000 1100a | b = 0011 1101a ^ b = 0011 0001~a = 1100 0011 运算规则如下： 操作符 描述 例子 &amp; 同1为1 ，否则为0 a &amp; b = 0000 1100 丨 同0为0 ，否则为1 a 丨b = 0011 1101 ^ 相同为0，否则为1 a ^ b = 0011 0001 ~ 按位取反 ~a 即 1100 0011 &lt;&lt; 按位左移运算符。左操作数按位左移右操作数指定的位数。 a &lt;&lt; 2 即 1111 0000 >&gt; 按位右移运算符。左操作数按位右移右操作数指定的位数。 a &gt;&gt; 2 即 1111 >>&gt; 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。 a &gt;&gt;&gt;2 即 0000 1111 逻辑运算符a 为 true，b 为 false 操作符 描述 例子 &amp;&amp; 逻辑与运算符。当且仅当两个操作数都为真，条件才为真。 a &amp;&amp; b 为 false 丨丨 逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。 a 丨丨 b 为真 ! 逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。 ！（a &amp;&amp; b）为真。 注意：&amp;&amp; 和 || 具有短路的特性，也就是当第一个条件可以判断最终结果的时候，就不会去判断第二个条件。 赋值运算符 操作符 描述 例子 = 基础的赋值运算符，将右边的值赋给左边 c = a + b 就是将 a + b 的值赋给 c +(-，*，/，%，&lt;&lt;, &gt;&gt; ,&amp; ,^, )= 运算符左侧数值和右侧数值进行对应操作后赋给左侧 例如c += a 等价于 c = c + a 条件运算符（？：）条件运算符也被称为三元运算符。该运算符有3个操作数，并且需要判断布尔表达式的值。该运算符的主要是决定哪个值应该赋值给变量。 12345678int a , b; a = 10; // 如果 a 等于 1 成立，则设置 b 为 20，否则为 30 b = (a == 1) ? 20 : 30; System.out.println( "Value of b is : " + b ); // 如果 a 等于 10 成立，则设置 b 为 20，否则为 30 b = (a == 10) ? 20 : 30; System.out.println( "Value of b is : " + b ); 123运算结果如下：Value of b is : 30Value of b is : 20 instanceof 运算符该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。 instanceof运算符使用格式如下： 123Vehicle a = new Car();boolean result = a instanceof Car;System.out.println( result); 结果如下：1true Java运算符优先级最高优先级的在该表上方，最低优先级的在该表底部 类别 操作符 关联性 后缀 （）[].(点操作符) 左到右 一元 ++ - ！~ 右到左 乘性 * / % 左到右 加性 + - 左到右 移位 >> >>> &lt;&lt; 左到右 关系 > >= = &lt; &lt;= 左到右 相等 == ~= 左到右 按位与 &amp; 左到右 按位异或 ^ 左到右 按位或 \丨 左到右 逻辑与 &amp;&amp; 左到右 逻辑或 丨丨 左到右 条件 ？： 从右到左 赋值 =，+=，-=，等等 从右到左 逗号 ， 左到右 参考资料Java运算符|菜鸟驿站 Core Java Volume Ⅰ-Fundamentals 下期预告下一期我们来聊一下关于字符串的前世今生~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot 2.0 系列（二）：流程详解（上）]]></title>
    <url>%2F2018%2F06%2F01%2FSpringBoot-2-0-%E7%B3%BB%E5%88%97%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写在前面本节将详细介绍如何使用Spring Boot。它涵盖了诸如项目管理及自动构建工具、自动配置以及如何运行应用程序等主题。我们还介绍了一些Spring Boot最佳实践。Spring Boot没有什么特别之处(它只是另一个我们可以使用的库)，但是有一些约定俗成的建议（“习惯优于配置”），如果遵循这些建议，将使我们的开发过程变得更容易一些。 项目管理及自动构建工具强烈建议您选择一个支持依赖项管理的构建系统，我们可以使用该系统得到发布到Maven中心仓库的组件。这里建议选择Maven或Gradle。虽然Spring Boot可以与其他构建系统(例如Ant)一起工作，但是它们并没有得到很好的支持。 1. 依赖关系管理Spring Boot的每一个版本都提供了它所支持的一个被整理的依赖项列表。实际上，我们不需要为构建配置中的任何依赖项提供版本，因为Spring Boot会为我们管理这些依赖项，当我们升级Spring Boot的时候，这些依赖项也会以一致的方式升级。 当然如果需要，我们仍然可以指定一个版本并覆盖Spring Boot的默认项。 Spring引导的每个版本都与Spring框架的一个基本版本相关联。我们强烈建议您不要指定它的版本。 2. MavenMaven用户可以从spring-boot-starter-parent项目继承来获得合理的默认值。parent项目提供以下特性: Java 1.8作为默认的编译器级别。 UTF - 8编码。 一个继承自spring-boot-dependencies pom的依赖管理部分，管理通用依赖项的版本。这个依赖项管理可以在自己的pom中使用这些依赖项时省略&lt; version&gt;标记。 合理的插件配置(exec插件，Git commit ID和shade)。 合理的资源过滤（例如：application.properties和application.yml）。包含特定于概要文件的文件（例如：application-dev.properties和application-dev.yml） 2.1 继承 Parent POM如果需要将项目配置为从spring-boot-starter-parent继承，请将 parent 设置为: 123456&lt;!-- Inherit defaults from Spring Boot --&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt;&lt;/parent&gt; 我们应该仅在此依赖项上指定Spring Boot版本号。如果我们导入其他starter，我们可以放心地省略版本号。 通过这种设置，我们还可以通过在自己的项目中覆盖属性来覆盖各个依赖项。例如，要升级到另一个Spring-Data release系列，我们可以在我们的pom.xml中添加以下内容: 123&lt;properties&gt; &lt;spring-data-releasetrain.version&gt;Fowler-SR2&lt;/spring-data-releasetrain.version&gt;&lt;/properties&gt; 2.2 不继承Parent POM不是每个人都喜欢从spring-boot-starter那里继承。我们可能需要使用您自己的企业标准parent，或者我们可能希望显式声明所有的Maven配置。如果我们不想使用spring-boot-starter-parent，我们仍然可以通过使用scope=import dependency来保持依赖关系管理(而不是插件管理)的好处，如下所示: 123456789101112&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;!-- Import dependency management from Spring Boot --&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 前面的示例设置不允许我们通过使用属性来覆盖各个依赖项，如上所述。要实现相同的结果，我们需要在spring-boot-dependencies条目之前在我们的项目的依赖项管理中添加一个条目。例如，要升级到另一个Spring Data release，我们可以在我们的pom.xml中添加以下元素: 12345678910111213141516171819&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- Override Spring Data release train provided by Spring Boot --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-releasetrain&lt;/artifactId&gt; &lt;version&gt;Fowler-SR2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 在前面的示例中，我们指定了一个BOM，但是任何依赖类型都可以以相同的方式重写。 3. 使用Spring Boot Maven PluginSpring Boot包含一个Maven插件，可以将项目打包为可执行jar。如果我们想使用这个插件，请将这个插件添加到&lt; plugins&gt;部分，如下例所示: 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 3. Gradlespringboot与gradle的结合篇幅较长，将放在后面单独来讲，敬请期待~ 4. Startersstarters是一组依赖描述符，我们可以在应用程序中包括这些描述符。我们可以为所有Spring和相关技术提供一站式服务，而无需通过示例代码和复制粘贴的依赖描述符来进行搜索。例如，如果我们希望开始使用Spring和JPA进行数据库访问，在项目中包含Spring -boot-starter-data- JPA依赖项就好。starters包含许多依赖项，我们需要这些依赖项来快速启动和运行项目，并且具有一组一致的、受支持的托管传递依赖项。 代码构建Spring Boot不需要任何特定的代码布局来工作。然而，有一些最佳实践对于我们来说显然是很有帮助的。 1. 使用默认包当一个类不包含包声明时，它被认为是在“默认包”中。一般不建议使用“默认包”，应该避免使用。它会给使用@ComponentScan、@EntityScan或@SpringBootApplication注解的Spring引导应用程序带来特别的问题，因为每个jar的每个类都被读取。 我们建议您遵循Java推荐的包命名约定，并使用一个反向的域名(例如，com.example.project)。 2. 定位 main application class我们通常建议您将main class置于其他类之上的root packge中。@SpringBootApplication注释通常放在主类上，它隐式地为某些项定义了基本的“搜索包”。例如，如果我们正在编写一个JPA应用程序，则使用@ SpringBootApplication带注释的类的包来搜索@Entity项。使用根包还允许组件扫描只应用于项目。 如果我们不想使用@SpringBootApplication，那么它导入的@EnableAutoConfiguration和@ComponentScan注释定义了这种行为，因此我们也可以使用它。 下面的清单展示了一个典型的布局: com +- example +- myapplication +- Application.java | +- customer | +- Customer.java | +- CustomerController.java | +- CustomerService.java | +- CustomerRepository.java | +- order +- Order.java +- OrderController.java +- OrderService.java +- OrderRepository.java Application.java文件将声明主方法和基本的@SpringBootApplication，如下所示: 12345678910111213package com.example.myapplication;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; SpringApplication.run(Application.class, args); &#125;&#125; 配置类Spring Boot支持基于java的配置。虽然可以将SpringApplication与XML源一起使用，但是我们通常建议您的配置源是一个@Configuration类。通常，定义主方法的类作为主要的@Configuration是一个很好的选择。 许多Spring配置示例已经在Internet上发布，它们使用XML配置。如果可能的话，始终尝试使用等效的基于java的配置。搜索Enable*注释可能是一个很好的起点。 1. 导入额外的配置类不需要将所有的@Configuration放在一个类中。可以使用@Import注释来导入其他配置类，或者我们可以使用@ComponentScan自动提取所有Spring组件，包括@Configuration类。 2. 导入XML配置如果必须使用基于XML的配置，建议从一个@Configuration类开始。然后可以使用@ImportResource注释来加载XML配置文件。 下节预告： Auto-configuration Spring bean和依赖项注入 使用@SpringBootApplication注释……敬请期待 ~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础专题（一）：基本数据类型]]></title>
    <url>%2F2018%2F05%2F30%2FJava%E5%9F%BA%E7%A1%80%E4%B8%93%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[前言今天我们来聊一下Java这门语言的数据类型，众所周知，Java是一种强类型语言。在Java中，一共有8种基本类型，其中4种整形，2种浮点类型，1种用于表示Unicode编码的字符单元的字符类型char和1种用于表示真值的boolean类型。 整型整形用于表示没有小数部分的数值，允许为负。 类型 存储大小 取值范围 int 4字节 -2,147,483,648 ~ 2,147,483,647 short 2字节 -32,768 ~ 32,767 long 8字节 -9,223,372,036,854,775,808 ~ 9223,372,036,854,775,807 byte 1字节 -128 ~ 127 在Java中，整形的范围与运行Java代码的机器无关。这解决了软件从一个平台移植到另外一个平台，或者在同一个平台的不同操作系统之间进行移植给程序员带来的麻烦。 长整形（Long类型）数值后有一个后缀 L 或 l（这里建议不要使用小写的 l 来标识，因为在某些字体的格式下，1和 l 几乎没有任何区别，给月阅读的人带来很大的困扰）。 十六进制数值前缀为 0x 或 0X，这里需要说一点，八进制的前缀是0，比如010，这样的写法比较容易让人混淆，所以我们一般不要使用八进制来表示数据。 二进制数值的前缀为 0b 或 0B，例如0b1001所代表的十进制数据就是9。 从Java7开始，可以在数字字面量加下划线，比如1_000_000，这些下划线的作用仅仅是使代码的易读性更高，编译器在编译的时候会去除这些下划线。 浮点类型浮点类型用于表示有小数部分的数值，在Java中有两种浮点类型。 类型 存储大小 取值范围 float 4字节 大约 ± 3.402,823,47E+38F(有效位为6-7位) double 8字节 大约 ± 1.79769313486231570E+308（有效位15位） double表示这种类型的数值精度是float类型的两倍（故有人称double为双精度数值），事实上我们在使用的过程中，绝大多数情况都会选用double，因为float的精度通常无法满足我们的要求。 float类型的数值有一个后缀 f 或 F，没有后缀的浮点值就是double类型的。 可以使用十六进制来表示浮点数值，例如 0.125（2的负三次方）可以表示为 0x1.0p-3。在十六进制中，使用p表示指数，而不是e。 三个特殊的浮点数值： 1. 正无穷大（Double.POSITIVE_INFINITY） 2. 负无穷大（Double.NEGATIVE_INFINITY） 3. NAN（Double.NaN） char类型一个或两个char类型的数值可以用来表示一个Unicode字符，在代码中，char类型的字面量值需要用单引号括起来，char类型的值可以表示为以 \u 开头的16进制数值，用于表示一些标点和特殊符号所用。 一些较为特殊的字符的转移序列如下： 转义序列 名称 Unicode值 \b 退格 \u000 \t 制表 \u0009 \n 换行 \u000a \r 回车 \u000d \“ 双引号 \u0022 \‘ 单引号 \u0027 \\ 反斜杠 \u005c Unicode转义序列会在解析代码之前得到处理（大坑慎入！） 1// download uri d:\user\a，这里会报语法错误，因为 \u 后面没有跟着4个十六进制数。 布尔类型布尔类型有两个值：false和true，用来判定逻辑条件，整型值和布尔值之间不能互相转换，这一点与C或C++不同，需要留意一下。 参考文献 《Core Java Volume Ⅰ-Fundamentals》 – Cay S.Horstmann 下集预告下一期我们来见识一下Java中各种各样运算符的奥秘，三天一更，我们不见不散~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot 2.0 系列（一）：快速开始]]></title>
    <url>%2F2018%2F05%2F28%2FSpring-Boot-2-0-%E7%B3%BB%E5%88%97%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[写在前面 SpringBoot版本：2.0.2 RELEASE 开发工具：IDEA 2017.2 相关资料：SpringBoot官方文档 1. 介绍SpringBootSpring Boot可以使我们轻松地创建独立的、生产级的基于Spring的应用程序，由于整合了一些对Spring和第三方库的配置，我们可以快速开始一个应用程序。大多数Spring Boot应用程序都需要很少的Spring配置。 我们可以使用Spring Boot来创建Java应用程序，这些应用程序可以通过使用 java -jar 或更传统的war部署来启动。Spring Boot还提供了一个运行“spring脚本”的命令行工具。 Spring Boot 为我们都做了什么: 为所有Spring开发人员提供一种快速而广泛的入门体验。 由于整合了一些对Spring和第三方库的配置解决了深受XML配置困扰的Spring开发人员的痛点 提供一系列非功能特性，这些特性在大型项目中是常见的(例如嵌入式服务器、安全、度量、健康检查和外部化配置)。 2.系统环境需求 Java 8 或 9 Spring 5.0.6 RELEASE 或 以上 构建工具 Maven 3.2 + Gradle 4 Spring Boot支持以下servlet容器: Tomcat 8.5 Jetty 9.4 Undertow 1.4 3. 构建项目的方式1.基于Maven的构建 pom.xml 内容如下： 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;myproject&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;!-- Inherit defaults from Spring Boot --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;!-- Add typical dependencies for a web application --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- Package as an executable jar --&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2.基于Gradle的构建 bulid.gradle 内容如下： 123456789101112131415161718plugins &#123; id 'org.springframework.boot' version '2.0.2.RELEASE' id 'java'&#125;jar &#123; baseName = 'myproject' version = '0.0.1-SNAPSHOT'&#125;repositories &#123; jcenter()&#125;dependencies &#123; compile("org.springframework.boot:spring-boot-starter-web") testCompile("org.springframework.boot:spring-boot-starter-test")&#125; 4.开发Spring Boot 的Hello World 项目(使用maven构建工具) 第一步：创建pom文件 123456789101112131415161718&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;myproject&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;!-- Additional lines to be added here... --&gt;&lt;/project&gt; 第二步：添加依赖 Spring Boot提供了许多“starter”，可以让您将jar添加到classpath 中。上文已经在POM的父部分使用了spring-boot-starter-parent。spring-boot-starter-parent是一个特殊的“starter”，它提供有用的Maven默认值。它还提供了一个依赖管理部分，这样我们就就可以为关联的依赖项省略版本标记。其他”starter”提供了在开发特定类型的应用程序时可能需要的依赖项。由于我们正在开发一个web应用程序，所以我们添加了一个spring-boot-starter-web依赖项。在此之前，我们可以通过运行以下命令查看当前所拥有的内容。 123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 第三步：编写代码 要完成我们的应用程序，我们需要创建一个Java文件，Java文件包含以下代码: 123456789101112131415161718import org.springframework.boot.*;import org.springframework.boot.autoconfigure.*;import org.springframework.web.bind.annotation.*;@RestController@EnableAutoConfigurationpublic class Example &#123; @RequestMapping("/") String home() &#123; return "Hello World!"; &#125; public static void main(String[] args) throws Exception &#123; SpringApplication.run(Example.class, args); &#125;&#125; 注：在我们的示例类上的第一个注释是@RestController。这被称为构造型注释。它为阅读代码的人们提供了一些提示，并且为Spring提供了一个特定的角色。在本例中，我们的类是一个web @Controller，所以Spring在处理传入web请求时考虑它。@RequestMapping注释提供路由信息。它告诉Spring，任何带有/ path的HTTP请求都应该映射到home方法。@RestController注释告诉Spring将生成的字符串直接呈现给调用者。 第二个类级别注释是@EnableAutoConfiguration。这个注释告诉Spring Boot基于您添加的jar依赖项“猜测”您想如何配置Spring，。因为Spring-boot-starter-web添加了Tomcat和Spring MVC，所以自动配置假设您正在开发一个web应用程序，并相应地设置Spring。 我们的应用程序的最后一部分是主方法。这只是遵循应用程序入口点的Java约定的标准方法。通过调用run，我们的main方法委托给Spring Boot的SpringApplication类。SpringApplication引导我们的应用程序启动Spring，而Spring又启动了自动配置的Tomcat web服务器。我们需要通过例子。类作为运行方法的参数，以告诉SpringApplication是主Spring组件。args数组也被传递，以公开任何命令行参数。 第四步：运行程序： 运行main方法，或者在根目录运行 mvn spring-boot: run命令。 12345678910111213$ mvn spring-boot:run . ____ _ __ _ _ /\\ / ___'_ __ _ _(_)_ __ __ _ \ \ \ \( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \ \\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.0.2.RELEASE)....... . . ........ . . . (log output here)....... . . ......... Started Example in 2.222 seconds (JVM running for 6.514) 打开浏览器，输入localhost:8080，你可以看到 1Hello World! 第五步：创建可执行的jar 将下列代码添加到pom.xml文件中： 12345678&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 保存文件，并在命令行输入maven package，可以看到： 123456789101112131415$ mvn package[INFO] Scanning for projects...[INFO][INFO] ------------------------------------------------------------------------[INFO] Building myproject 0.0.1-SNAPSHOT[INFO] ------------------------------------------------------------------------[INFO] .... ..[INFO] --- maven-jar-plugin:2.4:jar (default-jar) @ myproject ---[INFO] Building jar: /Users/developer/example/spring-boot-example/target/myproject-0.0.1-SNAPSHOT.jar[INFO][INFO] --- spring-boot-maven-plugin:2.0.2.RELEASE:repackage (default) @ myproject ---[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------ 这时你会发现target目录下多了一个名为myprojectname-0.0.1-SNAPSHOT.jar的文件，文件大概10MB，如果你想查看文件的详细内容，可以使用 1$ jar tvf target/myproject-0.0.1-SNAPSHOT.jar 如果你想运行，可以使用 java -jar，如下： 12345678910111213$ java -jar target/myproject-0.0.1-SNAPSHOT.jar . ____ _ __ _ _ /\\ / ___'_ __ _ _(_)_ __ __ _ \ \ \ \( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \ \\/ ___)| |_)| | | | | || (_| | ) ) ) ) ' |____| .__|_| |_|_| |_\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v2.0.2.RELEASE)....... . . ........ . . . (log output here)....... . . ......... Started Example in 2.536 seconds (JVM running for 2.864) 若知后事如何，且听下回分解~]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《用户体验要素》读后笔记[完]（三）]]></title>
    <url>%2F2018%2F05%2F05%2F%E3%80%8A%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%A6%81%E7%B4%A0%E3%80%8B%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[结构层在定义好用户需求并排序好优先级别之后，我们对于最终差您将会包括什么特性已经有了清楚的图像，然而这些需求并没有说明如何将这些分散的片段组成一个整体，这就是范围层的上面一层：为网站建立一个概念结构。 结构层适当的将我们的关注点从抽象的决策与范围问题，转移到更能影响最后的用户体验的具体因素，传统的软件开发行业，涉及”为用户设计结构化体验”的方法被称为交互设计。在内容建设方面，主要是通过信息架构来构建用户体验。这两个都强调一个重点：确定各个将要呈现给用户的元素的“模式”和“顺序”。与其针对机器的最佳工作方式来设计系统，还不如设计一个对用户而言最好的系统，用户对于“交互组件将怎么样工作”的观点成为概念模型。概念模型是用于在交互设计的开发过程中保持使用方式的一致性的，交互设计会处理每一个级别的错误，以确保更高比例的用户能有积极的体验。 信息架构 信息架构所研究的是人们如何认知信息的过程，对于产品而言，信息架构关注的是呈现给用户的信息是否合理并具有意义 信息架构要求创建分类体系，创建分类体系的方法有从上向下和从下向上，但是这两种方法都有一定的局限性，唯一可避免两者缺点的方法是在两种方法中找到一个平衡点 一个高效结构的优点就是具备“容纳成长和适应变动”的能力 信息架构的基本单位是节点 节点的结构包括层级结构（树状、辐射）、矩阵结构、自然结构、线性结构 节点在信息架构是依据组织原则来安置的 我们的困难不是创建一个结构，而是在创建一个能与“我们的目标”和“用户的需求”相对应、正确的结构 成功的用户体验，就是能事先预知用户的期望并将其带入到设计当中去 “使用客户的语言”并且“保持一致性”是非常重要的，我们把用来强调一致性的工具称为受控词典 元数据的意思，简单地说就是“关于信息的信息”，即以一个结构化的方式来描述内容的信息。 框架层在充满概念的结构层中开始形成大量的需求，这些需求都是来自我们的战略目标的需求。在框架层，我们要更进一步的提炼这些结构，确定很详细的界面外观，导航和信息设计，这能让晦涩的结构变得实在。对于功能性产品，我们通过界面设计来确定框架，对于信息型产品，要解决的问题是导航设计，但是这两者都应解决信息设计这一方面。 提供给用户做某些事的能力，这属于界面设计。 提供给用户去某个地方的能力，这是导航设计。 传达想法给用户，那就是信息设计。 传统的习惯并非一定要死守，当某种方式有着不错的收益时，应该谨慎的试着违背一些习惯。 有效的使用比喻，即减少用户在理解你的产品时对猜测的要求。 界面设计的全部事情就是选择正确的界面元素 设计复杂系统的界面所面临的最大挑战之一，是弄清楚用户不需要哪些东西，并减少他们的可发现性。 导航设计必须完成以下三个目标： ① 提供用户一种在网页间跳转的方法 ② 元素与所包含内容之间的关系 ③ 内容与当前用户浏览页面之间的关系 多重导航系统： 全局导航，局部导航，辅助导航，上下文导航，友好导航，远程导航，网络地图，索引表 将信息设计和导航设计结合到一起，有一个重要的作用：支持指示标识。 页面布局是将信息设计、界面设计和导航设计放置到一起，形成一个统一的，有内在凝聚力的架构，这个架构的具体文档的展示方式为线框图。 线框图是整合在框架层的全部三种要素的方法：通过安排和选择界面元素来整合界面设计；通过识别和定义核心导航系统来整合导航设计；通过放置和排列信息组成部分的优先级来整合信息设计。 表现层在这五个模型的顶端，我们把注意力转移到产品用户会首先注意到的地方：感知设计，这里，内容、功能和美学汇集到一起来缠身一个最终设计，完成其他四个层面的所有目标，并同时满足用户的感官感受。 表现层中几乎所有的产品都会涉及到视觉设计，在视觉设计中，我们用于吸引用户注意的一个主要工具就是对比。 在你的设计中保持一致性是另一个重要的组成部分，它能使你的设计有效地传达信息，而不会导致用户迷惑或焦虑。“一致性”在视觉设计的许多不同方面都会起到作用。 内部和外部的一致性： ① 内部一致性的问题。这是说，在产品的两个不同的地方反映了不同的设计方法。 ② 外部一致性的问题。这是说，这个产品没有在同一个企业的其他产品中，反映出被使用的，相同的设计方法。 配色方案与排版对于品牌形象的建立，以及对于公众的影响显得尤为重要。 在视觉设计领域中对线框图最直接的模拟是视觉模型或设计合成品。 承载这些设计决策的权威性文档是风格指南。这个汇总文档确定了视觉设计的每个方面，从最大到最小的范围内的所有元素]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>UE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《用户体验要素》读后笔记（二）]]></title>
    <url>%2F2018%2F05%2F04%2F%E3%80%8A%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%A6%81%E7%B4%A0%E3%80%8B%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[战略层成功的用户体验，其基础是一个被明确表达的“战略”，知道企业与用户双方对产品的期许和目标，有助于促进用户体验各方面战略的确定和制定。 明确两个问题：我们要通过这个产品得到什么？ 我们的客户要通过这个产品得到什么？ ① 产品目标 ② 用户需求 产品目标： ① 商业目标（商业驱动因素） ② 品牌识别 ③ 成功标识 用户需求： ① 用户细分 1. 人口统计学 2. 消费心理档案 ② 可用性和用户研究 1. 市场调研方法 2. 现场调研 3. 任务分析 4. 用户测试 5. 卡片排序法 6. 用户模型 这是就需要一篇战略文档，而战略文档的关键在于简洁明了并切中要点，战略是设计用户体验设计流程中的起点。 范围层带着“我们想要什么”、“我们的用户想要什么”的明确认识，我们才能弄清楚如何去满足这些战略的目标，当你把用户需求和产品目标转变成产品应该提供给用户什么样的内容和功能时，战略就变成了范围。 用文档定义产品需求的必要性： ① 这样你才知道你在建设什么 ② 这样你才知道你不需要建设什么 范围层被功能型产品和信息型产品分为了功能规格和内容需求，定义需求的详略层度往往取决于该项目的具体范围。 功能规格说明： 文档不能解决问题，但定义可以，我们需要的不是文档有厚或有多详细，而是要足够清楚和准确。 乐观：描述这个系统将要做什么事情去“防止”不好的情况发生 具体：尽可能详细的解释清楚情况 在文档中要尽量避免主观的语气 内容需求： 应该提供每一个特性规模的文档预估：文本的字数，图片的像素大小，下载的文件字节、PDF或音频文件等独立元素的大小等。 内容特性的更新频率来自于产品的战略目标，必须确定一个频率，它是介于你的用户期望值和有效值之间 确定需求优先级： 有些特性可能会因为技术上的局限无法实现，有些则是因为资源与时间上的不足 很少有功能时独立存在的 如果你的战略计划或愿景文档在战略目标的范围内制定了一个清晰的优先级别顺序，那么这些优先级别应该是决定是否采纳人们所建议的相关特性的首要因素]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>UE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《用户体验要素》 读后笔记（一）]]></title>
    <url>%2F2018%2F05%2F04%2F%E3%80%8A%E7%94%A8%E6%88%B7%E4%BD%93%E9%AA%8C%E8%A6%81%E7%B4%A0%E3%80%8B%E8%AF%BB%E5%90%8E%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[最近有幸拜读了Jesse James Garrett所著的用户体验要素这本书，感触颇多，感觉对于UE这门课程有了一个较为系统的认识，知道了用户体验为什么是如此的重要，以及用户体验的五个元素。 在产品开发过程中,人们更多的关注what to do, 设计师经常忽略的另一个因素是how to do, 而这一因素恰恰是决定产品成败的关键因素。 “外形服从于功能” 这种观点对于产品的内部运作(用户不可见的部分)是完全适用的, 但是, 对于产品直接面向用户的那些部分—按钮, 布局, 文字, 也包括外观, 正确的产品形态绝对不是由”功能”所决定的, 而是应该由”用户自身的心理感受和行为“来决定的 提供优质的用户体验, 是一个重要的可持续的竞争优势 —— 不仅仅对网站是这样, 对所有类型的产品和服务都是如此 创建吸引人的,高效的用户体验的方法称为”以用户为中心的设计”. 以用户为中心的设计思想非常简单,: 在开发产品的每一个步骤中, 都要把用户列入考虑范围，下面我们来认识一下这些要素。 五个要素用户体验开发时的五个要素(5s) 表现层(surface) 一系列的网页, 由图片和文字组成 框架层(skeleton) 按钮, 控件, 照片和文本区域的位置, 优化设计布局, 以达到这些元素的最大效果和效率 结构层(structure) 框架是结构的具体表达方式 范围层(scope) 结构层确定网站各种特性和功能最合适的组合方式, 而这些特性和功能就构成了网站的范围层 战略层(strategy) 网站的范围基本上是由网站战略层决定的 双重性自下而上的建设，并且让每一个层面的工作在下一个层面可以结束之前完成，网站具有基本的双重性，描述功能型的平台类产品和描述信息的媒介类产品。 功能性产品, 主要关注的任务, 所有的操作都被纳入一个过程, 去思考人们如何完成这个过程, 这里的网站实际上是用户用于完成任务的一种工具 信息性产品, 主要的关注点是信息, 创建一个富信息的用户体验, 就是提供给用户一个可以寻找, 理解且有意义的组合 区别和联系1.战略层所关注的内容都是一样的, 来自企业外部的用户需求和来自自己对网站的期望目标。 2.由范围层进入战略层, 在功能型产品一侧转化为功能规格: 对产品的&quot;功能组合&quot;的详细描述. 而在信息型产品一侧, 范围则是以内容需求的形式出现: 对各种内容元素的要求的详细描述。 3.在功能性产品一侧, 结构层将从范围转化为交互设计, 在这里我们可以定义系统如何响应用户的请求,另一侧是信息架构: 合理的安排内容元素以促进人类理解信息 4.在框架层, 必不可少的是信息设计, 功能性产品偏向于界面设计, 而信息类产品, 则偏向于导航设计. 5.最后, 在表现层, 关注点都在于最终产品创建用户体验]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>UE</tag>
      </tags>
  </entry>
</search>
